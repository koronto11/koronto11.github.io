<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>刻写未来！</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-24T08:30:28.991Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>黄上</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Boot之路(二)--Thymeleaf模板引擎</title>
    <link href="http://yoursite.com/2018/03/24/springboot03/"/>
    <id>http://yoursite.com/2018/03/24/springboot03/</id>
    <published>2018-03-24T05:23:22.000Z</published>
    <updated>2018-03-24T08:30:28.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="静态资源访问"><a href="#静态资源访问" class="headerlink" title="静态资源访问"></a>静态资源访问</h1><p>在我们开发Web应用的时候，需要引用大量的js、css、图片等静态资源。</p><h1 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h1><p>Spring Boot默认提供静态资源目录位置需置于classpath下，目录名需符合如下规则：</p><pre><code>/static/public/resources/META-INF/resources</code></pre><p>举例：我们可以在src/main/resources/目录下创建static，在该位置放置一个图片文件。启动程序后，尝试访问<a href="http://localhost:8088/D.jpg。如能显示图片，配置成功。" target="_blank" rel="noopener">http://localhost:8088/D.jpg。如能显示图片，配置成功。</a></p><p>在之前的示例中，我们都是通过@RestController来处理请求，所以返回的内容为json对象。那么如果需要渲染html页面的时候，要如何实现呢？</p><p>在动态HTML实现上Spring Boot依然可以完美胜任，并且提供了多种模板引擎的默认配置支持，所以在推荐的模板引擎下，我们可以很快的上手开发动态网站。</p><p>Spring Boot提供了默认配置的模板引擎（抛弃传统的JSP动态网页）主要有以下几种：</p><p>Thymeleaf<br>FreeMarker<br>Velocity<br>Groovy<br>Mustache</p><p>Spring Boot建议使用这些模板引擎，避免使用<strong>JSP</strong>，若一定要使用JSP将无法实现Spring Boot的多种特性，具体可见后文：支持JSP的配置</p><p>当你使用上述模板引擎中的任何一个，它们默认的模板配置路径为：src/main/resources/templates。当然也可以修改这个路径，具体如何修改，可在后续各模板引擎的配置属性中查询并修改。</p><h1 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h1><p>在实际的公司开发中，传统的JSP技术由于前段后端结合太过紧密，而且后端人员需要随时测试数据能不能渲染在界面上，这就需要前端与后端部门过于紧耦合，不利于实际开发，反而是模板引擎用的较多（当然也不排除一些老的公司需要维护公司以前的动态JSP网页）</p><p>thymeleaf最大的优势后缀为html,就是只需要浏览器就可以展现页面了,还有就是thymeleaf可以很好的和spring集成.</p><p>Thymeleaf是一个XML/XHTML/HTML5模板引擎，可用于Web与非Web环境中的应用开发。它是一个开源的Java库，基于Apache License 2.0许可，由Daniel Fernández创建，该作者还是Java加密库Jasypt的作者。</p><p>Thymeleaf提供了一个用于整合Spring MVC的可选模块，在应用开发中，你可以使用Thymeleaf来完全代替JSP或其他模板引擎，如Velocity、FreeMarker等。Thymeleaf的主要目标在于提供一种可被浏览器正确显示的、格式良好的模板创建方式，因此也可以用作静态建模。你可以使用它创建经过验证的XML与HTML模板。相对于编写逻辑或代码，开发者只需将标签属性添加到模板中即可。接下来，这些标签属性就会在DOM（文档对象模型）上执行预先制定好的逻辑。</p><p>示例：</p><pre><code>&lt;table&gt;  &lt;thead&gt;    &lt;tr&gt;      &lt;th th:text=&quot;#{msgs.headers.name}&quot;&gt;Name&lt;/td&gt;      &lt;th th:text=&quot;#{msgs.headers.price}&quot;&gt;Price&lt;/td&gt;    &lt;/tr&gt;  &lt;/thead&gt;  &lt;tbody&gt;    &lt;tr th:each=&quot;prod : ${allProducts}&quot;&gt;      &lt;td th:text=&quot;${prod.name}&quot;&gt;Oranges&lt;/td&gt;      &lt;td th:text=&quot;${#numbers.formatDecimal(prod.price,1,2)}&quot;&gt;0.99&lt;/td&gt;    &lt;/tr&gt;  &lt;/tbody&gt;&lt;/table&gt;</code></pre><p>可以看到Thymeleaf主要以<strong>属性</strong>的方式加入到html标签中，浏览器在解析html时，当检查到没有的属性时候会忽略，所以Thymeleaf的模板可以通过浏览器直接打开展现，这样非常有利于前后端的分离。</p><p>在Spring Boot中使用Thymeleaf，只需要引入下面依赖，并在默认的模板路径src/main/resources/templates下编写模板文件即可完成。</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>在完成配置之后，举一个简单的例子，在快速入门工程的基础上，举一个简单的示例来通过Thymeleaf渲染一个页面。</p><pre><code>package com.example.springboot.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class IndexController {    @RequestMapping(&quot;/index&quot;)    public String index(ModelMap map){        map.addAttribute(&quot;hello&quot;, &quot;i love you@com&quot;);        return &quot;index&quot;;    }}</code></pre><p>相应的index.html界面代码为</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/meta&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1 th:text=&quot;${hello}&quot;&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>启动程序后，页面输入<a href="http://localhost:8088/index，所出现的显示数据是：i" target="_blank" rel="noopener">http://localhost:8088/index，所出现的显示数据是：i</a> love you@com，并没有出现Hello World<br>展现的是IndexController中的hello的属性值，做到了不破坏HTML自身内容的数据逻辑分离。</p><p>注意：我们建立模板测试或者是实际开发中，我们都需要严格遵守thymeleaf的HTML5页面规范，不然会报错<br>包括我上面写的<meta>标签则需要双标签来自正常结束才可以，否则页面将出现错误，你可以使用严格的标签，也就是每个标签都有结束标签，这种可能比较麻烦。</p><p>那么如何在thymeleaf中声明使用非严格的html5规范呢？</p><p>maven添加依赖</p><pre><code>&lt;dependency&gt;        &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt;        &lt;artifactId&gt;nekohtml&lt;/artifactId&gt;        &lt;version&gt;1.9.22&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>application.properties属性文件中添加</p><p>spring.thymeleaf.mode = LEGACYHTML5</p><p>声明thymeleaf使用非严格的html即可。最后更新下maven仓库即可生效。</p><h1 id="关于Thymeleaf的默认参数配置"><a href="#关于Thymeleaf的默认参数配置" class="headerlink" title="关于Thymeleaf的默认参数配置"></a>关于Thymeleaf的默认参数配置</h1><p>如有需要修改默认配置的时候，只需复制下面要修改的属性到application.properties中，并修改成需要的值，如修改模板文件的扩展名，修改默认的模板路径等。</p><p>-Enable template caching.<br>spring.thymeleaf.cache=true<br>-Check that the templates location exists.<br>spring.thymeleaf.check-template-location=true<br>-Content-Type value.<br>spring.thymeleaf.content-type=text/html<br>-Enable MVC Thymeleaf view resolution.<br>spring.thymeleaf.enabled=true<br>-Template encoding.<br>spring.thymeleaf.encoding=UTF-8<br>-Comma-separated list of view names that should be excluded from resolution.<br>spring.thymeleaf.excluded-view-names=<br>-Template mode to be applied to templates. See also StandardTemplateModeHandlers.<br>spring.thymeleaf.mode=HTML5<br>-Prefix that gets prepended to view names when building a URL.<br>spring.thymeleaf.prefix=classpath:/templates/<br>-Suffix that gets appended to view names when building a URL.<br>spring.thymeleaf.suffix=.html  spring.thymeleaf.template-resolver-order= # Order of the template resolver in the chain. spring.thymeleaf.view-names= # Comma-separated list of view names that can be resolved.</p><h1 id="关于Thymeleaf语法"><a href="#关于Thymeleaf语法" class="headerlink" title="关于Thymeleaf语法"></a>关于Thymeleaf语法</h1><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>对于Thymeleaf语法来说，很多资料中会写应用Thymeleaf语法需要先在<html>标签中引入<br>在html中引入此命名空间，可避免编辑器出现html验证错误，虽然加不加命名空间对Thymeleaf的功能没有任何影响。</html></p><pre><code>&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</code></pre><p>才可以使用Thymeleaf语法，但是我在上面的案例中并没有声明html标签的属性也可以用，也让我很费解。（不过为了一些不必要的麻烦还是把这个声明加上）</p><h2 id="输出内容"><a href="#输出内容" class="headerlink" title="输出内容"></a>输出内容</h2><p>例如:</p><pre><code>Controller:    map.addAttribute(&quot;hello&quot;, &quot;i love you@com&quot;);HTML:    &lt;h1 th:text=&quot;${hello}&quot;&gt;Hello World&lt;/h1&gt;1. th:text  用来将内容输出到所在标签的body中。2. ${hello} 用来引用hello属性值3. 可以用th:utext 用来显示“unescaped ” 的html内容。(unescaped即非转义字符)</code></pre><p>例如：</p><pre><code>&lt;p th:text=&quot;#{home.welcome}&quot;&gt;Welcome to our grocery store!&lt;/p&gt;`#{home.welcome} 用来引入数据home对象中的 welcome属性。`</code></pre><h2 id="标准表达式语法"><a href="#标准表达式语法" class="headerlink" title="标准表达式语法"></a>标准表达式语法</h2><p>它们分为四类：</p><p>1.变量表达式<br>2.选择或星号表达式<br>3.文字国际化表达式<br>4.URL表达式</p><h3 id="变量表达式"><a href="#变量表达式" class="headerlink" title="变量表达式"></a>变量表达式</h3><p>变量表达式即OGNL表达式或Spring EL表达式(在Spring术语中也叫model attributes)。如下所示：</p><p>${session.user.name}<br>${hello}</p><p>它们将以HTML标签的一个属性来表示：</p><pre><code>&lt;span th:text=&quot;${book.author.name}&quot;&gt;  &lt;li th:each=&quot;book : ${books}&quot;&gt;  </code></pre><h3 id="选择-星号-表达式"><a href="#选择-星号-表达式" class="headerlink" title="选择(星号)表达式"></a>选择(星号)表达式</h3><p>选择表达式很像变量表达式，不过它们用一个预先选择的对象来代替上下文变量容器(map)来执行，如下：</p><p>*{customer.name}</p><p>被指定的object由th:object属性定义：</p><pre><code>&lt;div th:object=&quot;${book}&quot;&gt;    ...    &lt;span th:text=&quot;*{title}&quot;&gt;...&lt;/span&gt;    ...  &lt;/div&gt;  </code></pre><h3 id="文字国际化表达式"><a href="#文字国际化表达式" class="headerlink" title="文字国际化表达式"></a>文字国际化表达式</h3><p>文字国际化表达式允许我们从一个外部文件获取区域文字信息(.properties)，用Key索引Value，还可以提供一组参数(可选).</p><pre><code>`#{main.title} ``#{message.entrycreated(${entryId})} `</code></pre><p>可以在模板文件中找到这样的表达式代码：</p><pre><code>&lt;table&gt;    ...    &lt;th th:text=&quot;#{header.address.city}&quot;&gt;...&lt;/th&gt;    &lt;th th:text=&quot;#{header.address.country}&quot;&gt;...&lt;/th&gt;    ...  &lt;/table&gt; </code></pre><h3 id="URL表达式"><a href="#URL表达式" class="headerlink" title="URL表达式"></a>URL表达式</h3><p>URL表达式指的是把一个有用的上下文或回话信息添加到URL，这个过程经常被叫做URL重写。<br>@{/order/list}</p><p>URL还可以设置参数：<br>@{/order/details(id=${orderId})}</p><p>相对路径：<br>@{../documents/report}</p><p>让我们看这些表达式：</p><pre><code>&lt;form th:action=&quot;@{/createOrder}&quot;&gt;  &lt;a href=&quot;main.html&quot; th:href=&quot;@{/main}&quot;&gt;</code></pre><p>变量表达式和星号表达有什么区别吗？</p><p>如果不考虑上下文的情况下，两者没有区别；星号语法评估在选定对象上表达，而不是整个上下文<br>什么是选定对象？就是父标签的值，如下：（相当于星号表达式会去全局中找这个属性，如果找不到则默认不显示）</p><pre><code>&lt;div th:object=&quot;${session.user}&quot;&gt;   &lt;p&gt;Name: &lt;span th:text=&quot;*{firstName}&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;   &lt;p&gt;Surname: &lt;span th:text=&quot;*{lastName}&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;   &lt;p&gt;Nationality: &lt;span th:text=&quot;*{nationality}&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt;</code></pre><p>完全等价于</p><pre><code>&lt;div th:object=&quot;${session.user}&quot;&gt;     &lt;p&gt;Name: &lt;span th:text=&quot;${session.user.firstName}&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;     &lt;p&gt;Surname: &lt;span th:text=&quot;${session.user.lastName}&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;     &lt;p&gt;Nationality: &lt;span th:text=&quot;${session.user.nationality}&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt;</code></pre><p>当然，美元符号和星号语法可以混合使用：</p><pre><code>&lt;div th:object=&quot;${session.user}&quot;&gt;      &lt;p&gt;Name: &lt;span th:text=&quot;*{firstName}&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;      &lt;p&gt;Surname: &lt;span th:text=&quot;${session.user.lastName}&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;      &lt;p&gt;Nationality: &lt;span th:text=&quot;*{nationality}&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt;</code></pre><h2 id="表达式支持的语法"><a href="#表达式支持的语法" class="headerlink" title="表达式支持的语法"></a>表达式支持的语法</h2><ul><li>字面（Literals）</li></ul><p>文本文字（Text literals）: ‘one text’, ‘Another one!’,…<br>数字文本（Number literals）: 0, 34, 3.0, 12.3,…<br>布尔文本（Boolean literals）: true, false<br>空（Null literal）: null<br>文字标记（Literal tokens）: one, sometext, main,…</p><ul><li>文本操作（Text operations）</li></ul><p>字符串连接(String concatenation): +<br>文本替换（Literal substitutions）: |The name is ${name}|</p><ul><li>算术运算（Arithmetic operations）</li></ul><p>二元运算符（Binary operators）: +, -, *, /, %<br>减号（单目运算符）Minus sign (unary operator): -</p><ul><li>布尔操作（Boolean operations）</li></ul><p>二元运算符（Binary operators）:and, or<br>布尔否定（一元运算符）Boolean negation (unary operator):!, not</p><ul><li>比较和等价(Comparisons and equality)</li></ul><p>比较（Comparators）: &gt;, &lt;, &gt;=, &lt;= (gt, lt, ge, le)<br>等值运算符（Equality operators）:==, != (eq, ne)</p><ul><li>条件运算符（Conditional operators）</li></ul><p>If-then: (if) ? (then)<br>If-then-else: (if) ? (then) : (else)<br>Default: (value) ?: (defaultvalue)</p><p>所有这些特征可以被组合并嵌套：</p><pre><code>&apos;User is of type &apos; + (${user.isAdmin()} ? &apos;Administrator&apos; : (${user.type} ?: &apos;Unknown&apos;))</code></pre><h2 id="常用th标签都有那些？"><a href="#常用th标签都有那些？" class="headerlink" title="常用th标签都有那些？"></a>常用th标签都有那些？</h2><p><img src="/2018/03/24/springboot03/p1.png" alt="logo"><br><img src="/2018/03/24/springboot03/p2.png" alt="logo"><br><img src="/2018/03/24/springboot03/p3.png" alt="logo"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;静态资源访问&quot;&gt;&lt;a href=&quot;#静态资源访问&quot; class=&quot;headerlink&quot; title=&quot;静态资源访问&quot;&gt;&lt;/a&gt;静态资源访问&lt;/h1&gt;&lt;p&gt;在我们开发Web应用的时候，需要引用大量的js、css、图片等静态资源。&lt;/p&gt;
&lt;h1 id=&quot;默认配置&quot;
      
    
    </summary>
    
      <category term="springboot" scheme="http://yoursite.com/categories/springboot/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
      <category term="springboot" scheme="http://yoursite.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot之路(二)--Nosql支持</title>
    <link href="http://yoursite.com/2018/03/23/springboot02/"/>
    <id>http://yoursite.com/2018/03/23/springboot02/</id>
    <published>2018-03-23T08:49:42.000Z</published>
    <updated>2018-03-23T18:25:07.681Z</updated>
    
    <content type="html"><![CDATA[<p>在SpringBoot中对常用的数据库支持外，对nosql 数据库也进行了封装自动化。</p><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。<br>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。<br>它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><a id="more"></a><p>Redis学习手册：<a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/redis/redis-tutorial.html</a></p><p>Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。<br>Redis 与其他 key - value 缓存产品有以下三个特点：</p><p>1.Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。<br>2.Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。<br>3.Redis支持数据的备份，即master-slave模式的数据备份。</p><p>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。<br>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。<br>原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。<br>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</p><p>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。<br>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</p><h2 id="什么是BSD协议？"><a href="#什么是BSD协议？" class="headerlink" title="什么是BSD协议？"></a>什么是BSD协议？</h2><p>BSD开源协议是一个给于使用者很大自由的协议。可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。当你发布使用了BSD协议的代码，或者以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：<br>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。<br>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。<br>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。<br>BSD代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销 售，因此是对商业集成很友好的协议。<br>很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者 二次开发。</p><h2 id="安装及使用"><a href="#安装及使用" class="headerlink" title="安装及使用"></a>安装及使用</h2><p>Windows下的安装教程：</p><p>下载地址（已在Github上开源）：<a href="https://github.com/MSOpenTech/redis/releases" target="_blank" rel="noopener">https://github.com/MSOpenTech/redis/releases</a></p><p>Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，这里我们下载 Redis-x64-xxx.zip压缩包到 F 盘，解压后，将文件夹重新命名为 redis。</p><p>打开一个 cmd 窗口 使用cd命令切换目录到 C:\redis 运行 redis-server.exe redis.windows.conf 。<br>如果想方便的话，可以把 redis 的路径加到系统的环境变量里，这样就省得再输路径了，后面的那个 redis.windows.conf 可以省略，如果省略，会启用默认的。输入之后，会显示如下界面：</p><p><img src="/2018/03/23/springboot02/redis-install1.png" alt="logo"></p><p>这时候另启一个cmd窗口，原来的不要关闭，不然就无法访问服务端了。<br>切换到redis目录下运行 redis-cli.exe -h 127.0.0.1 -p 6379 。<br>设置键值对 set myKey abc<br>取出键值对 get myKey</p><p><img src="/2018/03/23/springboot02/redis-install2.png" alt="logo"></p><p>Redis是目前业界使用最广泛的内存数据存储。相比memcached，Redis支持更丰富的数据结构，例如hashes, lists, sets等，同时支持数据持久化。除此之外，Redis还提供一些类数据库的特性，比如事务，HA，主从库。可以说Redis兼具了缓存系统和数据库的一些特性，因此有着丰富的应用场景。本文介绍Redis在Spring Boot中两个典型的应用场景。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>1、引入 spring-boot-starter-redis</p><pre><code>&lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;  &lt;/dependency&gt;</code></pre><p>2、添加配置文件</p><p>编辑配置<br>你可以通过修改 redis.conf 文件或使用 CONFIG set 命令来修改配置。</p><p>CONFIG SET 命令基本语法：<br>redis 127.0.0.1:6379&gt; CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE</p><p>通过修改application.properties中配置Redis连接信息文件修改如下：</p><ul><li>REDIS (RedisProperties)</li><li>Redis数据库索引（默认为0）<br>spring.redis.database=0  </li><li>Redis服务器地址<br>spring.redis.host=192.168.0.58</li><li>Redis服务器连接端口<br>spring.redis.port=6379  </li><li>Redis服务器连接密码（默认为空）<br>spring.redis.password=  </li><li>连接池最大连接数（使用负值表示没有限制）<br>spring.redis.pool.max-active=8  </li><li>连接池最大阻塞等待时间（使用负值表示没有限制）<br>spring.redis.pool.max-wait=-1  </li><li>连接池中的最大空闲连接<br>spring.redis.pool.max-idle=8  </li><li>连接池中的最小空闲连接<br>spring.redis.pool.min-idle=0  </li><li>连接超时时间（毫秒）<br>spring.redis.timeout=0  </li></ul><p>3、修改项目启动类</p><p>增加注解@EnableCaching，开启缓存功能，如下：</p><pre><code>package springboot;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cache.annotation.EnableCaching;import org.springframework.scheduling.annotation.EnableScheduling;@SpringBootApplication@EnableScheduling@EnableCachingpublic class SpringbootApplication{    public static void main(String[] args) {        SpringApplication.run(SpringbootApplication.class, args);    }}</code></pre><p>4、新建Redis缓存配置类RedisConfig，如下：</p><pre><code>package springboot.config;import org.springframework.beans.factory.annotation.Value;import org.springframework.cache.CacheManager;import org.springframework.cache.annotation.CachingConfigurerSupport;import org.springframework.cache.annotation.EnableCaching;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.cache.RedisCacheManager;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;/** * Redis缓存配置类 * @author szekinwin * */@Configuration@EnableCachingpublic class RedisConfig extends CachingConfigurerSupport{    @Value(&quot;${spring.redis.host}&quot;)    private String host;    @Value(&quot;${spring.redis.port}&quot;)    private int port;    @Value(&quot;${spring.redis.timeout}&quot;)    private int timeout;    //自定义缓存key生成策略//    @Bean//    public KeyGenerator keyGenerator() {//        return new KeyGenerator(){//            @Override//            public Object generate(Object target, java.lang.reflect.Method method, Object... params) {//                StringBuffer sb = new StringBuffer();//                sb.append(target.getClass().getName());//                sb.append(method.getName());//                for(Object obj:params){//                    sb.append(obj.toString());//                }//                return sb.toString();//            }//        };//    }    //缓存管理器    @Bean     public CacheManager cacheManager(@SuppressWarnings(&quot;rawtypes&quot;) RedisTemplate redisTemplate) {        RedisCacheManager cacheManager = new RedisCacheManager(redisTemplate);        //设置缓存过期时间         cacheManager.setDefaultExpiration(10000);        return cacheManager;    }    @Bean    public RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory factory){        StringRedisTemplate template = new StringRedisTemplate(factory);        setSerializer(template);//设置序列化工具        template.afterPropertiesSet();        return template;    }     private void setSerializer(StringRedisTemplate template){            @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })            Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);            ObjectMapper om = new ObjectMapper();            om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);            om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);            jackson2JsonRedisSerializer.setObjectMapper(om);            template.setValueSerializer(jackson2JsonRedisSerializer);     }}</code></pre><p>5、新建UserMapper</p><pre><code>package springboot.dao;import org.apache.ibatis.annotations.Delete;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Param;import org.apache.ibatis.annotations.Select;import org.apache.ibatis.annotations.Update;import org.springframework.cache.annotation.CacheConfig;import org.springframework.cache.annotation.CacheEvict;import org.springframework.cache.annotation.CachePut;import org.springframework.cache.annotation.Cacheable;import springboot.domain.User;@Mapper@CacheConfig(cacheNames = &quot;users&quot;)public interface UserMapper {    @Insert(&quot;insert into user(name,age) values(#{name},#{age})&quot;)    int addUser(@Param(&quot;name&quot;)String name,@Param(&quot;age&quot;)String age);    @Select(&quot;select * from user where id =#{id}&quot;)    @Cacheable(key =&quot;#p0&quot;)     User findById(@Param(&quot;id&quot;) String id);    @CachePut(key = &quot;#p0&quot;)    @Update(&quot;update user set name=#{name} where id=#{id}&quot;)    void updataById(@Param(&quot;id&quot;)String id,@Param(&quot;name&quot;)String name);    //如果指定为 true，则方法调用后将立即清空所有缓存    @CacheEvict(key =&quot;#p0&quot;,allEntries=true)    @Delete(&quot;delete from user where id=#{id}&quot;)    void deleteById(@Param(&quot;id&quot;)String id);}</code></pre><p>@Cacheable将查询结果缓存到redis中，（key=”#p0”）指定传入的第一个参数作为redis的key。</p><p>@CachePut，指定key，将更新的结果同步到redis中</p><p>@CacheEvict，指定key，删除缓存数据，allEntries=true,方法调用后将立即清除缓存</p><h2 id="共享Session-spring-session-data-redis"><a href="#共享Session-spring-session-data-redis" class="headerlink" title="共享Session-spring-session-data-redis"></a>共享Session-spring-session-data-redis</h2><p>分布式系统中，sessiong共享有很多的解决方案，其中托管到缓存中应该是最常用的方案之一，</p><p>多台分布式机器共享Session的解决方案</p><h3 id="如何使用-1"><a href="#如何使用-1" class="headerlink" title="如何使用"></a>如何使用</h3><ul><li><p>引入依赖</p>  <dependency><br>      <groupid>org.springframework.session</groupid><br>      <artifactid>spring-session-data-redis</artifactid><br>  </dependency>　</li><li><p>Session配置</p><p>  @Configuration<br>  @EnableRedisHttpSession(maxInactiveIntervalInSeconds = 86400*30)<br>  public class SessionConfig {<br>  }</p></li></ul><p>maxInactiveIntervalInSeconds: 设置Session失效时间，使用Redis Session之后，原Boot的server.session.timeout属性不再生效</p><ul><li>测试</li></ul><p>添加测试方法获取sessionid</p><pre><code>@RequestMapping(&quot;/uid&quot;)String uid(HttpSession session) {    UUID uid = (UUID) session.getAttribute(&quot;uid&quot;);    if (uid == null) {        uid = UUID.randomUUID();    }    session.setAttribute(&quot;uid&quot;, uid);    return session.getId();}</code></pre><p>登录redis 输入 keys ‘<em>sessions</em>‘ xml t&lt;spring:session:sessions:db031986-8ecc-48d6-b471-b137a3ed6bc4 t(spring:session:expirations:1472976480000  其中 1472976480000为失效时间，意思是这个时间后session失效，db031986-8ecc-48d6-b471-b137a3ed6bc4 为sessionId,登录<a href="http://localhost:8080/uid" target="_blank" rel="noopener">http://localhost:8080/uid</a> 发现会一致，就说明session 已经在redis里面进行有效的管理了。<br>这条session作为数据储存在Redis数据库中。</p><h3 id="如何在两台或者多台中共享session"><a href="#如何在两台或者多台中共享session" class="headerlink" title="如何在两台或者多台中共享session"></a>如何在两台或者多台中共享session</h3><p>其实就是按照上面的步骤在另一个项目中再次配置一次，启动后自动就进行了session共享。</p><p>多台机器可以共享这个Redis数据库，里面自然有Session数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在SpringBoot中对常用的数据库支持外，对nosql 数据库也进行了封装自动化。&lt;/p&gt;
&lt;h1 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。&lt;br&gt;Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。&lt;br&gt;它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://yoursite.com/categories/springboot/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
      <category term="springboot" scheme="http://yoursite.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot之路(一)--概念介绍及注解配置</title>
    <link href="http://yoursite.com/2018/03/22/springboot/"/>
    <id>http://yoursite.com/2018/03/22/springboot/</id>
    <published>2018-03-22T06:13:19.000Z</published>
    <updated>2018-03-23T18:25:07.680Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。也被称为spring的脚手架。<br>该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。</p><p>spring boot 致力于简洁，让开发者写更少的配置，程序能够更快的运行和启动。它是下一代javaweb框架，并且它是spring cloud（微服务）的基础。(spring cloud的基础就是基于spring boot来进行配置)，spring boot就是为了让开发人员从繁重的配置工作解放出来，快速参与开发。</p><ol><li>创建独立的Spring应用程序</li><li>嵌入的Tomcat，无需部署WAR文件</li><li>简化Maven配置</li><li>自动配置Spring</li><li>提供生产就绪型功能，如指标，健康检查和外部配置</li><li>绝对没有代码生成和对XML没有要求配置（由java配置替代XML配置，也就是零XML配置）</li></ol><a id="more"></a><p>从最根本上来讲，Spring Boot就是一些库的集合，它能够被任意项目的构建系统所使用。简便起见，该框架也提供了命令行界面，它可以用来运行和测试Boot应用。框架的发布版本，包括集成的CLI（命令行界面），可以在Spring仓库中手动下载和安装。一种更为简便的方式是使用Groovy环境管理器（Groovy enVironment Manager，GVM），它会处理Boot版本的安装和管理。Boot及其CLI可以通过GVM的命令行gvm install springboot进行安装。</p><p>要进行打包和分发的工程会依赖于像Maven或Gradle这样的构建系统。为了简化依赖图，Boot的功能是模块化的，通过导入Boot所谓的“starter”模块，可以将许多的依赖添加到工程之中。为了更容易地管理依赖版本和使用默认配置，框架提供了一个parent POM，工程可以继承它。</p><h1 id="如何spring-boot快速开发"><a href="#如何spring-boot快速开发" class="headerlink" title="如何spring boot快速开发"></a>如何spring boot快速开发</h1><p>如何进行spring boot的快速开发和学习，以便于熟悉这个框架所带来的方便。<br>最好的办法就是在项目中去参与开发，体验会所带来的FEEL！！</p><p>首先我们需要一个项目以方便我们了解利用spirng boot框架的项目里面到底有什么？</p><h2 id="Test项目下载"><a href="#Test项目下载" class="headerlink" title="Test项目下载"></a>Test项目下载</h2><p>spring官网为我们提供了可方便快速上手体验的Test项目<br><a href="http://start.spring.io/" target="_blank" rel="noopener">http://start.spring.io/</a></p><p>在里面根据自己的选择JDK的版本，项目名和包名等等，点击下方的Switch to the full version可以选择java的版本（还可以引入所依赖的组件，这里我们先下载默认的项目，若是以后有需要的jar包再通过maven导入即可）</p><p>我的选择界面如下：</p><p><img src="/2018/03/22/springboot/p1.png" alt="logo"></p><p>选择好后然后点击Generate Project下载项目压缩包</p><p>解压后，使用eclipse，Import -&gt; Existing Maven Projects -&gt; Next -&gt;选择解压后的文件夹-&gt; Finsh，OK done!</p><h2 id="项目目录结构分析"><a href="#项目目录结构分析" class="headerlink" title="项目目录结构分析"></a>项目目录结构分析</h2><p><img src="/2018/03/22/springboot/p2.png" alt="logo"></p><p>可以看到Spring Boot的基础结构共三个文件</p><p>src/main/java  程序开发以及主程序入口<br>src/main/resources 配置文件<br>src/test/java  测试程序</p><p>这里跟我们平时在eclipse中建立的maven项目目录结构一致</p><p>spingboot建议的目录结果如下（根据你的公司的开发格式要求为重）：</p><p>root package结构：com.example.myproject</p><pre><code>com  +- example    +- myproject      +- Application.java      |      +- domain      |  +- Customer.java      |  +- CustomerRepository.java      |      +- service      |  +- CustomerService.java      |      +- controller      |  +- CustomerController.java      |</code></pre><p>其实也就是分包，按照以往的springmvc的开发模式，Entity中方实体类，也就是数据库与服务端的字段映射POJO，Controller中放控制层（负责页面访问控制），Service中负责处理相关业务逻辑，Dao层负责处理数据库交互，Util负责放入一些工具类，aspect为切面组件，converter为消息转化组件等等。</p><p>而spring boot中建议以java配置取代繁重的XML配置（或者用更简化的Groovy来代替），这个项目用java配置演示。</p><p>1、Application.java  建议放到跟目录下面,主要用于做一些框架配置（java配置文件）</p><p>2、domain  目录主要用于实体（Entity）与数据访问层（Repository）</p><p>3、service  层主要是业务类代码</p><p>4、controller  负责页面访问控制</p><p>采用默认配置可以省去很多配置，当然也可以根据自己的喜欢来进行更改</p><p>最后，启动Application main方法，至此一个java项目搭建好了！</p><h2 id="项目POM-XML"><a href="#项目POM-XML" class="headerlink" title="项目POM.XML"></a>项目POM.XML</h2><p>在项目的POM.xml文件中引入父POM，来初始化一些常用的功能（不用重新去导入其他包，当然也有办法不用这个父POM），项目自动配好了，若是自己编写项目则需要手动配置。</p><pre><code>&lt;!-- Inherit defaults from Spring Boot --&gt;&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;1.5.2.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;    &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;!-- spring-boot-maven-plugin插件 在SpringBoot项目中开启的方式有两种  一种是run java.application 还有一种就是这个插件开启--&gt;&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;&lt;!--支持springboot所需的jar包依赖&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>以上这些就是官网提供项目的POM配置。</p><p>还需要引入一个web模块</p><pre><code>&lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>pom.xml文件中默认有两个模块：</p><p>spring-boot-starter：核心模块，包括自动配置支持、日志和YAML；</p><p>spring-boot-starter-test：测试模块，包括JUnit、Hamcrest、Mockito。</p><p>测试一下页面访问的Controller看看效果</p><pre><code>package com.example.springboot.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;//springboot特有注解，包含@Controller和@ResponseBody//所以这里就相当于控制层组件和输出Json格式字符串，极其方便@RestControllerpublic class HelloController {  @RequestMapping(&quot;/hel&quot;)  public String index(){    return &quot;Hello World&quot;;  }  //测试成功！}</code></pre><p>注意：本机的tomcat端口若是自己设置的，需要在application.properties中去设置端口号，否则将访问不到。</p><p>我的设置是：server.port=8088</p><p>配置完后直接测试 <a href="http://localhost:8088/hel" target="_blank" rel="noopener">http://localhost:8088/hel</a></p><p>出现结果</p><p><img src="/2018/03/22/springboot/p3.png" alt="logo"></p><p>@RestController的意思就是controller里面的方法都以json格式输出，不用再写什么jackjson配置的了！<br>跟我们之前所使用的@ResponseBody一样，向浏览器直接输出Json格式的数据</p><p>当然在这里我贴出一些可能出现问题的解法包括我自己是怎么解决的</p><h2 id="出现的问题及解决方案"><a href="#出现的问题及解决方案" class="headerlink" title="出现的问题及解决方案"></a>出现的问题及解决方案</h2><p>当我们部署完后可以直接run运行这个Test项目看下是否输入路径能否得到这个json字符串<br>这时候可能会出现Whitelabel Error Page的提示，这时候表示这个项目并没运行成功<br>我去网上找找方法，常见的解决方法是去看看SpringbootApplication.java这个类是否放在项目根目录下（目录结构不对的问题）<br>因为springboot是默认加载这个配置文件下的所有子包，我查看了一下我的包结构</p><p><img src="/2018/03/22/springboot/p4.png" alt="logo"><br>发现并没有问题，SpringbootApplication.java配置也放在根目录下了，controller是其子包没错。</p><p>后来发现是springboot项目在运行的时候，eclipse需要你去手动配置springboot的项目以及执行配置的main方法所在类<br>这时候我们可以在所运行的项目下右键–&gt;run Configuations，然后在Main标签上的project中选择你所要执行的springboot项目<br>Main Class位置选择执行配置的main方法所在类，这时候重新运行就生效了，这是因为我之前也有用过springboot框架建了一个项目，这时候以为内原来的配置是上一个项目的，这时候需要我们手动去将项目重新设置。</p><p>另外这是我的解决方法，每个人都可能遇到不同的问题，所以这就是需要我们要去融入问题本身，再加上eclipse的debug模式去发现系统报给我们的错误的真正原因。</p><h2 id="如何做单元测试"><a href="#如何做单元测试" class="headerlink" title="如何做单元测试"></a>如何做单元测试</h2><p>利用我们刚刚做的这个Test类，我们要做个单元测试，将服务端和浏览器的交互数据都给打印出来，包括Springmvc各组件的数据交互。<br>打开的src/test/下的测试入口，编写简单的http请求来测试；使用mockmvc进行，利用MockMvcResultHandlers.print()打印出执行结果。</p><p>注意：@SpringApplicationConfiguration(classes = Application.class) 报错，注解不能导入。</p><pre><code>//springJunit支持，由于引入了Spring-Test框架支持。@RunWith(SpringJUnit4ClassRunner.class)//这个注解在1.5版本后移除了，所以用两个注解就可以实现测试，//@SpringApplicationConfiguration(classes = MockServletContext.class)//由于是web项目，Junit需要模拟ServletContext，需要给测试类加上@WebAppConfiguration注解@WebAppConfigurationpublic class HelloWorldControlerTests {     private MockMvc mvc;        @Before        public void setUp() throws Exception {            mvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();        }        @Test        public void getHello() throws Exception {        mvc.perform(MockMvcRequestBuilders.get(&quot;/hel&quot;).accept(MediaType.APPLICATION_JSON))                    .andExpect(MockMvcResultMatchers.status().isOk())                    .andDo(MockMvcResultHandlers.print())                    .andReturn();        }}</code></pre><p>热启动在正常开发项目中已经很常见了吧，虽然平时开发web项目过程中，改动项目启重启总是报错；但springBoot对调试支持很好，修改之后可以实时生效，需要添加以下的配置：</p><pre><code>&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;   &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;configuration&gt;                &lt;fork&gt;true&lt;/fork&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;   &lt;/plugins&gt;&lt;/build&gt;</code></pre><p>该模块在完整的打包环境下运行的时候会被禁用。如果你使用java -jar启动应用或者用一个特定的classloader启动，它会认为这是一个“生产环境”。</p><h2 id="关于Eclipse的热启动及热部署"><a href="#关于Eclipse的热启动及热部署" class="headerlink" title="关于Eclipse的热启动及热部署"></a>关于Eclipse的热启动及热部署</h2><p> Tomcat的热部署（以后就不用重启了）<br>1、 tomcat上的部署问题，有时候也是个麻烦的问题，要是不采用热部署，我们就只能每次对原来的文件做一次改动的时候就要重新部署，<br>而每次重新部署都要关闭tomcat，部署完重起tomcat，可见这是一个多么烦人的事情。现在，我们可以采用热部署了，以后，就不用做凡人的关闭重起工作。<br> 实现方式：<br>编辑Tomcat的server.xml<br>    <host name="localhost" debug="0" appbase="webapps" unpackwars="true" autodeploy="true" xmlvalidation="false" xmlnamespaceaware="false"></host></p><p>  在host节点内加入<br>    <!-- auto append ,then reload --><br>      <context path="/myapp" docbase="myapp" debug="99" reloadable="true"><br>“myapp” 为要部署的应用程序，通常在webapps目录下    <context>元素的属性:   path:指定访问该Web应用的URL入口。<br> docBase:指定Web应用的文件路径，可以给定绝对路径，也可以给定相对于 <host>的appBase属性的相对路径，<br>如果Web应用采用开放目录结构，则指定Web应用的根目录，如果Web应用是个war文件，则指定war文件的路径。<br> reloadable:如果这个属性设为true，tomcat服务器在运行状态下会监视在WEB-INF/classes和WEB-INF/lib目录下class文件的改动，<br>如果监测到有class文件被更新的，服务器会自动重新加载Web应用。    在开发阶段将reloadable属性设为true，<br>有助于调试servlet和其它的class文件，但这样用加重服务器运行负荷，建议在Web应用的发存阶段将reloadable设为false。</host></context></context></p><p>2、双击tomcat 服务器，切换到modules 界面，把项目的auto_reload 设置为Disabled 保存</p><p>这种方法只适用于改变类的方法实现，如果当一个类改变结构、或者配置文件修改了，tomcat是没办法热加载的，需要重启tomcat。<br>搞定！</p><p>使用spring boot可以非常方便、快速搭建项目，使我们不用关心框架之间的兼容性，适用版本等各种问题，我们想使用任何东西，仅仅添加一个配置就可以，所以使用sping boot非常适合构建微服务。</p><p>——————更新线——————</p><h1 id="关于SpringBootApplication的各项注解配置"><a href="#关于SpringBootApplication的各项注解配置" class="headerlink" title="关于SpringBootApplication的各项注解配置"></a>关于SpringBootApplication的各项注解配置</h1><p><img src="/2018/03/22/springboot/p5.png" alt="logo"></p><p>较为常用的注解有以下这些：</p><p>@SpringBootApplication:</p><p>包含@Configuration、@EnableAutoConfiguration、@ComponentScan<br>通常用在主类上。</p><p>@Repository:<br>用于标注数据访问组件，即DAO组件。</p><p>@Service:<br>用于标注业务层组件。 </p><p>@RestController:<br>4.0重要的一个新的改进是@RestController注解，它继承自@Controller注解。4.0之前的版本，Spring MVC的组件都使用@Controller来标识当前类是一个控制器servlet。使用这个特性，我们可以开发REST服务的时候不需要使用@Controller而专门的@RestController。<br>当你实现一个RESTful web services的时候，response将一直通过response body发送。为了简化开发，Spring 4.0提供了一个专门版本的controller。<br>用于标注控制层组件(如struts中的action)，包含@Controller和@ResponseBody。</p><p>@ResponseBody：<br>表示该方法的返回结果直接写入HTTP response body中<br>一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。</p><p>@Controller<br>如果我们需要使用页面开发只要使用 @Controller </p><p>@Component：<br>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p><p>@ComponentScan：<br>组件扫描。个人理解相当于<a href="context:component-scan" target="_blank" rel="noopener">context:component-scan</a>，如果扫描到有@Component @Controller @Service等这些注解的类，则把这些类注册为bean。</p><p>@Configuration：<br>指出该类是 Bean 配置的信息源，相当于XML中的<beans></beans>，一般加在主类上。</p><p>@Bean:<br>相当于XML中的<bean></bean>,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。</p><p>@EnableAutoConfiguration：<br>让 Spring Boot 根据应用所声明的依赖来对 Spring 框架进行自动配置，一般加在主类上。</p><p>@AutoWired:<br>byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。<br>当加上（required=false）时，就算找不到bean也不报错。</p><p>@Qualifier：<br>当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用</p><p>@Resource(name=”name”,type=”type”)：<br>没有括号内内容的话，默认byName。与@Autowired干类似的事。</p><p>@RequestMapping：<br>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。<br>该注解有六个属性：<br>params:指定request中必须包含某些参数值是，才让该方法处理。<br>headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。<br>value:指定请求的实际地址，指定的地址可以是URI Template 模式<br>method:指定请求的method类型， GET、POST、PUT、DELETE等<br>consumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html;<br>produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回</p><p>@RequestParam：<br>用在方法的参数前面。可以有效规避浏览器传参与服务端属性名字不一致的问题，最好每个参数前面都要加<br>@RequestParam String a =request.getParameter(“a”)。</p><p>@PathVariable:</p><p>路径变量。参数与大括号里的名字一样要相同。</p><pre><code>RequestMapping(&quot;user/get/mac/{macAddress}&quot;)public String getByMacAddress(@PathVariable String macAddress){　　//do something;}</code></pre><p>@Profiles<br>Spring Profiles提供了一种隔离应用程序配置的方式，并让这些配置只能在特定的环境下生效。<br>任何@Component或@Configuration都能被@Profile标记，从而限制加载它的时机。</p><pre><code>@Configuration@Profile(&quot;prod&quot;)public class ProductionConfiguration {    // ...}</code></pre><p>@ConfigurationProperties<br>Spring Boot将尝试校验外部的配置，默认使用JSR-303（如果在classpath路径中）。<br>你可以轻松的为你的@ConfigurationProperties类添加JSR-303 javax.validation约束注解：</p><pre><code>@Component@ConfigurationProperties(prefix=&quot;connection&quot;)public class ConnectionSettings {@NotNullprivate InetAddress remoteAddress;// ... getters and setters}</code></pre><p>全局异常处理</p><p>@ControllerAdvice：<br>包含@Component。可以被扫描到。<br>统一处理异常。</p><p>@ExceptionHandler（Exception.class）：<br>用在方法上面表示遇到这个异常就执行以下方法。</p><h2 id="自定义Filter"><a href="#自定义Filter" class="headerlink" title="自定义Filter"></a>自定义Filter</h2><p>我们常常在项目中会使用filters用于录调用日志、排除有XSS威胁的字符、执行权限验证等等。Spring Boot自动添加了OrderedCharacterEncodingFilter和HiddenHttpMethodFilter，并且我们可以自定义Filter。</p><p>两个步骤：</p><p>1.实现Filter接口，实现Filter方法<br>2.添加@Configuration 注解，将自定义Filter加入过滤链</p><pre><code>@Configurationpublic class WebConfiguration {    @Bean    public RemoteIpFilter remoteIpFilter() {        return new RemoteIpFilter();    }    @Bean    public FilterRegistrationBean testFilterRegistration() {        FilterRegistrationBean registration = new FilterRegistrationBean();        registration.setFilter(new MyFilter());        registration.addUrlPatterns(&quot;/*&quot;);        registration.addInitParameter(&quot;paramName&quot;, &quot;paramValue&quot;);        registration.setName(&quot;MyFilter&quot;);        registration.setOrder(1);        return registration;    }    public class MyFilter implements Filter {        @Override        public void destroy() {            // TODO Auto-generated method stub        }        @Override        public void doFilter(ServletRequest srequest, ServletResponse sresponse, FilterChain filterChain)                throws IOException, ServletException {            // TODO Auto-generated method stub            HttpServletRequest request = (HttpServletRequest) srequest;            System.out.println(&quot;this is MyFilter,url :&quot;+request.getRequestURI());            filterChain.doFilter(srequest, sresponse);        }        @Override        public void init(FilterConfig arg0) throws ServletException {            // TODO Auto-generated method stub        }    }}</code></pre><h2 id="自定义Property"><a href="#自定义Property" class="headerlink" title="自定义Property"></a>自定义Property</h2><p>在web开发的过程中，我经常需要自定义一些配置文件，如何使用呢</p><p>配置在application.properties中，例如：</p><pre><code>com.neo.title=路飞com.neo.description=海贼王@Component//配置好后，直接在类中用EL表达式引用即可，所有的参数配置都是写在这里，都是为了避免将程序写死public class NeoProperties {    @Value(&quot;${com.neo.title}&quot;)    private String title;    @Value(&quot;${com.neo.description}&quot;)    private String description;    //省略getter settet方法    }</code></pre><h2 id="log配置"><a href="#log配置" class="headerlink" title="log配置"></a>log配置</h2><p>配置输出的地址和输出级别，同样也是在application.properties里面设置参数即可</p><pre><code>logging.path=/user/local/loglogging.level.com.favorites=DEBUGlogging.level.org.springframework.web=INFOlogging.level.org.hibernate=ERROR</code></pre><p>path为本机的log地址，logging.level  后面可以根据包路径配置不同资源的log级别（关于等级说明在java常用类库–log日志 里面可以找到）</p><p>将日志输出到指定位置</p><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><p>重点讲述mysql、spring data jpa的使用，其中mysql 就不用说了大家很熟悉，jpa是利用Hibernate生成各种自动化的sql，如果只是简单的增删改查，基本上不用手写了，spring内部已经帮大家封装实现了。<br>实现了Mysql与Hibernate的结合，既可以自动生成sql语句简化开发，又可以利用mysql的快速方便不冗余的特点。</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>数据库及jpa配置文件（写在application.properties里）</p><pre><code>spring.datasource.url=jdbc:mysql://localhost:3306/testspring.datasource.username=rootspring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.jpa.properties.hibernate.hbm2ddl.auto=updatespring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialectspring.jpa.show-sql= true</code></pre><p>其实这个hibernate.hbm2ddl.auto参数的作用主要用于：自动创建|更新|验证数据库表结构,有四个值：</p><p>1.create： 每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。</p><p>2.create-drop ：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。</p><p>3.update：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据 model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等 应用第一次运行起来后才会。</p><p>4.validate ：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。</p><p>dialect 主要是指定生成表名的存储引擎为InneoDB<br>show-sql 是否打印出自动生产的SQL，方便调试的时候查看</p><p>添加实体类和Dao：</p><pre><code>@Entitypublic class User implements Serializable {    private static final long serialVersionUID = 1L;    @Id    @GeneratedValue    private Long id;    @Column(nullable = false, unique = true)    private String userName;    @Column(nullable = false)    private String passWord;    @Column(nullable = false, unique = true)    private String email;    @Column(nullable = true, unique = true)    private String nickName;    @Column(nullable = false)    private String regTime;    //省略getter settet方法、构造方法}</code></pre><p>关于@Column 注解详情</p><p>@Column标记表示所持久化属性所映射表中的字段，该注释的属性定义如下：</p><pre><code>@Target({METHOD, FIELD}) @Retention(RUNTIME)public @interface Column {    String name() default &quot;&quot;;    boolean unique() default false;    boolean nullable() default true;    boolean insertable() default true;    boolean updatable() default true;    String columnDefinition() default &quot;&quot;;    String table() default &quot;&quot;;    int length() default 255;    int precision() default 0;    int scale() default 0;}</code></pre><p>在使用此@Column标记时，需要注意以下几个问题：<br>此标记可以标注在getter方法或属性前，例如以下的两种标注方法都是正确的：</p><p>标注在属性前：</p><pre><code>@Entity@Table(name = &quot;contact&quot;)public class ContactEO{    @Column(name=&quot; contact_name &quot;)    private String name;}</code></pre><p>标注在getter方法前：</p><pre><code>@Entity@Table(name = &quot;contact&quot;)public class ContactEO{    @Column(name=&quot; contact_name &quot;)    public String getName() {        return name;    }}</code></pre><p>JPA规范中并没有明确指定那种标注方法，只要两种标注方式任选其一都可以。这根据个人的喜好来选择</p><p>属性都是什么意思：</p><p>unique属性表示该字段是否为唯一标识，默认为false。如果表中有一个字段需要唯一标识，则既可以使用该标记，也可以使用@Table标记中的@UniqueConstraint。</p><p>nullable属性表示该字段是否可以为null值，默认为true。</p><p>insertable属性表示在使用“INSERT”脚本插入数据时，是否需要插入该字段的值。</p><p>updatable属性表示在使用“UPDATE”脚本插入数据时，是否需要更新该字段的值。insertable和updatable属性一般多用于只读的属性，例如主键和外键等。这些字段的值通常是自动生成的。</p><p>columnDefinition属性表示创建表时，该字段创建的SQL语句，一般用于通过Entity生成表定义时使用。</p><p>table属性表示当映射多个表时，指定表的表中的字段。默认值为主表的表名。有关多个表的映射将在本章的5.6小节中详细讲述。</p><p>length属性表示字段的长度，当字段的类型为varchar时，该属性才有效，默认为255个字符。</p><p>precision属性和scale属性表示精度，当字段类型为double时，precision表示数值的总长度，scale表示小数点所占的位数。</p><p>dao只要继承JpaRepository类就可以，几乎可以不用写方法，还有一个特别有尿性的功能非常赞，就是可以根据方法名来自动的生产SQL，比如findByUserName 会自动生产一个以 userName 为参数的查询方法，比如 findAlll 自动会查询表里面的所有数据，比如自动分页等等</p><p>Entity中不映射成列的字段得加@Transient 注解，不加注解也会映射成列</p><pre><code>package com.example.springboot.domain;import org.springframework.data.jpa.repository.JpaRepository;public interface UserDao extends JpaRepository&lt;User, Long&gt;{    User findByUserName(String userName);    User findByUserNameOrEmail(String username, String email);}</code></pre><p>测试：</p><pre><code>@RunWith(SpringJUnit4ClassRunner.class)//@SpringApplicationConfiguration(Application.class)public class UserDaoTest {    @Autowired    private UserDao userDao;    @Test    public void test() throws Exception {        Date date = new Date();        DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG);                String formattedDate = dateFormat.format(date);        userDao.save(new User(&quot;1&quot;,&quot;aaa&quot;,&quot;123456&quot;,&quot;123@com&quot;,&quot;AAA&quot;,formattedDate));        userDao.save(new User(&quot;2&quot;,&quot;bbb&quot;,&quot;123456&quot;,&quot;123@com&quot;,&quot;BBB&quot;,formattedDate));        userDao.save(new User(&quot;3&quot;,&quot;ccc&quot;,&quot;123456&quot;,&quot;123@com&quot;,&quot;CCC&quot;,formattedDate));        Assert.assertEquals(9, userDao.findAll().size());        Assert.assertEquals(&quot;bb&quot;, userDao.findByUserNameOrEmail(&quot;bbb&quot;, &quot;123@com&quot;).getNickName());        userDao.delete(userDao.findByUserName(&quot;aaa&quot;));    }}</code></pre><h2 id="thymeleaf模板"><a href="#thymeleaf模板" class="headerlink" title="thymeleaf模板"></a>thymeleaf模板</h2><p>Spring boot 推荐使用来代替jsp</p><p>Thymeleaf是一款用于渲染XML/XHTML/HTML5内容的模板引擎。类似JSP，Velocity，FreeMaker等，它也可以轻易的与Spring MVC等Web框架进行集成作为Web应用的模板引擎。与其它模板引擎相比，Thymeleaf最大的特点是能够直接在浏览器中打开并正确显示模板页面，而不需要启动整个Web应用。</p><p>1.Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。</p><p>2.Thymeleaf 开箱即用的特性。它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。</p><p>3.Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。</p><p>我们已经习惯使用了什么 velocity,FreMaker，beetle之类的模版，那么到底好在哪里呢？ 比一比吧 Thymeleaf是与众不同的，因为它使用了自然的模板技术。这意味着Thymeleaf的模板语法并不会破坏文档的结构，模板依旧是有效的XML文档。模板还可以用作工作原型，Thymeleaf会在运行期替换掉静态值。Velocity与FreeMarker则是连续的文本处理器。 下面的代码示例分别使用Velocity、FreeMarker与Thymeleaf打印出一条消息：</p><pre><code>Velocity: &lt;p&gt;$message&lt;/p&gt;FreeMarker: &lt;p&gt;${message}&lt;/p&gt;Thymeleaf: &lt;p th:text=&quot;${message}&quot;&gt;Hello World!&lt;/p&gt;</code></pre><p>注意：由于Thymeleaf使用了XML DOM解析器，因此它并不适合于处理大规模的XML文件。</p><p>具体的在组件官方网站有详细介绍：<a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#introducing-thymeleaf" target="_blank" rel="noopener">https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#introducing-thymeleaf</a></p><p>涵盖了常见的前端操作，比如，判断，循环，引入模板，常用函数（日期格式化，字符串操作）下拉，js和css中使用，基本可以应对一般场景。</p><ul><li><p>引用命名空间 </p>  <html xmlns:th="http://www.thymeleaf.org"> </html></li></ul><p>在html中引入此命名空间，可避免编辑器出现html验证错误，虽然加不加命名空间对Thymeleaf的功能没有任何影响。</p><ul><li>URL</li></ul><p>URL在Web应用模板中占据着十分重要的地位，需要特别注意的是Thymeleaf对于URL的处理是通过语法@{…}来处理的。Thymeleaf支持绝对路径URL：</p><pre><code>&lt;a th:href=&quot;@{http://www.thymeleaf.org}&quot;&gt;Thymeleaf&lt;/a&gt;</code></pre><ul><li>条件求值</li></ul><p><a th:href="@{/login}" th:unless="${session.user" !="null}">Login</a></p><p>等等，在开发文档中都有介绍</p><ul><li>页面即原型</li></ul><p>在Web开发过程中一个绕不开的话题就是前端工程师与后端工程师的写作，在传统Java Web开发过程中，前端工程师和后端工程师一样，也需要安装一套完整的开发环境，然后各类Java IDE中修改模板、静态资源文件，启动/重启/重新加载应用服务器，刷新页面查看最终效果。</p><p>但实际上前端工程师的职责更多应该关注于页面本身而非后端，使用JSP，Velocity等传统的Java模板引擎很难做到这一点，因为它们必须在应用服务器中渲染完成后才能在浏览器中看到结果，而Thymeleaf从根本上颠覆了这一过程，通过属性进行模板渲染不会引入任何新的浏览器不能识别的标签。</p><p>Thymeleaf的用法也可参考：<a href="https://www.cnblogs.com/topwill/p/7434955.html" target="_blank" rel="noopener">https://www.cnblogs.com/topwill/p/7434955.html</a></p><h2 id="WebJars"><a href="#WebJars" class="headerlink" title="WebJars"></a>WebJars</h2><p>WebJars是一个很神奇的东西，可以让大家以jar包的形式来使用前端的各种框架、组件。</p><p>什么是WebJars？WebJars是将客户端（浏览器）资源（JavaScript，Css等）打成jar包文件，以对资源进行统一依赖管理。WebJars的jar包部署在Maven中央仓库上。</p><p>我们在开发Java web项目的时候会使用像Maven，Gradle等构建工具以实现对jar包版本依赖管理，以及项目的自动化管理，但是对于JavaScript，Css等前端资源包，我们只能采用拷贝到webapp下的方式，这样做就无法对这些资源进行依赖管理。那么WebJars就提供给我们这些前端资源的jar包形势，我们就可以进行依赖管理。</p><p>WebJars官网：<a href="http://www.webjars.org/" target="_blank" rel="noopener">http://www.webjars.org/</a><br>WebJars教程整理：<a href="https://www.cnblogs.com/liaojie970/p/7852576.html" target="_blank" rel="noopener">https://www.cnblogs.com/liaojie970/p/7852576.html</a></p><p>如何学习Spring Boot：<a href="https://www.zhihu.com/question/53729800/answer/255785661" target="_blank" rel="noopener">https://www.zhihu.com/question/53729800/answer/255785661</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。也被称为spring的脚手架。&lt;br&gt;该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。&lt;/p&gt;
&lt;p&gt;spring boot 致力于简洁，让开发者写更少的配置，程序能够更快的运行和启动。它是下一代javaweb框架，并且它是spring cloud（微服务）的基础。(spring cloud的基础就是基于spring boot来进行配置)，spring boot就是为了让开发人员从繁重的配置工作解放出来，快速参与开发。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建独立的Spring应用程序&lt;/li&gt;
&lt;li&gt;嵌入的Tomcat，无需部署WAR文件&lt;/li&gt;
&lt;li&gt;简化Maven配置&lt;/li&gt;
&lt;li&gt;自动配置Spring&lt;/li&gt;
&lt;li&gt;提供生产就绪型功能，如指标，健康检查和外部配置&lt;/li&gt;
&lt;li&gt;绝对没有代码生成和对XML没有要求配置（由java配置替代XML配置，也就是零XML配置）&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://yoursite.com/categories/springboot/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
      <category term="springboot" scheme="http://yoursite.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>好用的代码规范检查工具--checkstyle</title>
    <link href="http://yoursite.com/2018/03/22/checkstyle/"/>
    <id>http://yoursite.com/2018/03/22/checkstyle/</id>
    <published>2018-03-22T05:22:32.000Z</published>
    <updated>2018-03-22T06:22:00.889Z</updated>
    
    <content type="html"><![CDATA[<p>CheckStyle是SourceForge下的一个项目，提供了一个帮助Java开发人员遵守某些编码规范的工具。它能够自动化代码规范检查过程，从而使得开发人员从这项重要但枯燥的任务中解脱出来。它可以根据设置好的编码规则来检查代码。比如符合规范的变量命名，方法体的最大行数，重复代码检查等等。</p><p>如果你的项目经理开会时说：“我希望我们写出来的代码就象一个人写的!”，那么用Checkstyle绝对是正确选择！</p><a id="more"></a><h1 id="如何在Eclipse上安装插件"><a href="#如何在Eclipse上安装插件" class="headerlink" title="如何在Eclipse上安装插件"></a>如何在Eclipse上安装插件</h1><p>在eclipse上安装插件，这里直接以安装checkstyle为例子，以后的插件安装根据这个流程来就可以了。</p><p>列举了几个网上的方法（大概有5种方法可以将插件安装到eclipse上）</p><h2 id="第一种：直接复制法"><a href="#第一种：直接复制法" class="headerlink" title="第一种：直接复制法"></a>第一种：直接复制法</h2><p>假设Eclipse的安装目录在C:\eclipse，解压下载的eclipse 插件或者安装eclipse 插件到指定目录文件夹，打开安装文件夹，在安装文件夹里的根目录分别包含两个文件夹features和plugins ，然后把两个文件夹里的文件分别复制到C:\eclipse下所对应的文件夹下的features 和plugins 下，一般的把插件文件直接复制到eclipse目录里是最直接也是最愚蠢的一种方法！因为日后想要删除这些插件会非常的困难（你根本分不清哪个是哪个），不推荐使用。<br>　注意：直接将插件包解压到plugins文件夹下之后，重启eclipse，可能不会加载新的插件。<br>　解决方法是：<br>　　　1、打开命令行，到当前eclipse的目录下，输入eclipse -clean，重新启动eclipse，这样eclipse就会加上新的插件了。<br>　　　2、如果插件不能生效，则请将eclipse\configuration\org.eclipse.update目录（此目录会记录你插件等更新历史）删除后再启动eclipse；<br>　　你可以在eclipse的菜单”Help”–&gt;”About Eclipse SDK”–&gt;”Feature Details” 和”Plug-in Details”中看到新安装的插件。</p><h2 id="第二种：使用link文件法"><a href="#第二种：使用link文件法" class="headerlink" title="第二种：使用link文件法"></a>第二种：使用link文件法</h2><p>a.假设Eclipse的安装目录在C:\eclipse，在该文件夹下，新建这样的目录结构C:\eclipse\PluginsEclipse\jode\eclipse；<br>　　<br>b.解压下载的eclipse 插件或者安装eclipse 插件到指定目录BB（如：C:\BB）文件夹，打开BB文件夹，然后把 BB文件夹里的两个文件夹features和plugins复制到刚刚新建好 C:\eclipse\PluginsEclipse\jode\eclipse，这样eclipse中就有了两个插件目录features and plugins下。</p><p>c.在C:\eclipse目录中新建links（C:\eclipse\links）目录，在links目录中建立一个以link为扩展名的文本文件如jode.link，内容如下path=C:/eclipse/PluginsEclipse/jode 或者path=C:\eclipse\PluginsEclipse\jode（插件的目录），保存后重启eclipse插件就会安装完成。<br>　注意：link文件中path=插件目录的path路径分隔要用\或是/<br>    /eclipse/<br>    　　links/<br>    　　　　jode.link<br>    　　　　webtools.link<br>    　　　　updateManager.link<br>/eclipse/ links/ jode.link webtools.link updateManager.link … … 可以在eclipse的菜单”Help”–&gt;”AboutEclipse SDK”–&gt;”Feature Details” 和”Plug-in Details”中看到新安装的插件。</p><h2 id="第三种：使用eclipse自带图形界面安装"><a href="#第三种：使用eclipse自带图形界面安装" class="headerlink" title="第三种：使用eclipse自带图形界面安装"></a>第三种：使用eclipse自带图形界面安装</h2><p>选择Help &gt; Software Updates &gt; Manager Configuration，再选择Add &gt; Extension Location 找到你要安装插件的目录就可以了。使用eclipse的help-&gt;SoftwareUpdates -&gt;Find and install… search for new features… 输入软件安装地址进行安装强烈推荐这种方法，优点很多比如可以方便的添加删除，也不用自己写link文件！(注意：这种安装你即使没有下载安装包也可以从远程下载，只要知道链接即可，不过国内下载很多插件由于网络原因很慢，或者不能下载下来。)<br>　　备注：Eclipse插件的目录结构<br>/eclipse-plugins/<br>　　eclipse/<br>　　　　.eclipseextension<br>　　　　　　features/<br>　　　　　　plugins/<br>　　第2.3种方法所指向的目录都指的是”eclipse”目录，如果用第3种方法，在eclipse这个目录下必须有文件.eclipseextension，如果下载的插件没有这个文件，</p><p>那就随便eclipse安装目录下的那个文件拷过去就行，只有有这么个文件就可以了，内容没什么用，主要是一些版本信息。例如：</p><pre><code>id=org.eclipse.platform name=Eclipse Platformversion=3.1.1id=org.eclipse.platform name=Eclipse Platform version=3.1.1</code></pre><h2 id="第四种：使用dropins安装插件"><a href="#第四种：使用dropins安装插件" class="headerlink" title="第四种：使用dropins安装插件"></a>第四种：使用dropins安装插件</h2><p>从Eclipse3.5开始，安装目录下就多了一个dropins目录。只要将插件解压后拖到该目录即可安装插件。比如安装svn插件subclipse-1.8.16.zip，只需要如下的三步即可：<br>　　1、使用winrar等压缩软件将压缩包解压至某一文件夹，比如subclipse-1.8.16<br>　　2、将此目录移动/复制至Eclipse安装目录下的dropins目录<br>　　3、重启Eclipse。<br>　　由于此种安装方式可以将不同的插件安装在不同的目录里，并且不用麻烦地写配置文件，因此管理起来会非常方便，推荐使用。</p><h2 id="使用eclipse-marketplace自动下载"><a href="#使用eclipse-marketplace自动下载" class="headerlink" title="使用eclipse marketplace自动下载"></a>使用eclipse marketplace自动下载</h2><p>这个是我用的方法，不能离线，需要从网上下载，eclipse market在线安装</p><p>在早期的eclipse版本中，market功能不是很好用，经常搜索不到插件或下来。忘记在哪个版本开始，使用market就很方便了。<br>建议采用这种方式来安装，直接搜索，选择要安装的插件内容。无需记录引用插件位置。</p><p>打开Help -&gt; eclipse market，搜索checkstyle<br>选择想要的版本 -&gt; install</p><p>勾选所想要应用的功能</p><p>接受协议，安装完成后，重启eclipse生效。（方便快捷，适用于有网络的环境下）</p><h2 id="检查安装是否生效"><a href="#检查安装是否生效" class="headerlink" title="检查安装是否生效"></a>检查安装是否生效</h2><p>打开eclipse，Window–&gt;Preferences,如果列表中出现了checkstyle的菜单，则表示安装成功了。</p><p>注意：如果启动eclipse时，提示ClassNotFoundException等异常信息，则启动时加上一个“-clean”参数启动即可。</p><p>cd F:\Program Files\eclipse\eclipse.exe -clean</p><h2 id="资源整理"><a href="#资源整理" class="headerlink" title="资源整理"></a>资源整理</h2><p>CheckStyle插件地址：<a href="http://eclipse-cs.sourceforge.net/update" target="_blank" rel="noopener">http://eclipse-cs.sourceforge.net/update</a></p><p>github开源插件地址：<a href="https://github.com/checkstyle/eclipse-cs" target="_blank" rel="noopener">https://github.com/checkstyle/eclipse-cs</a></p><p>eclipse如何安装插件：<a href="http://blog.csdn.net/netdevgirl/article/details/54382301" target="_blank" rel="noopener">http://blog.csdn.net/netdevgirl/article/details/54382301</a></p><p>Eclipse中安装和使用CheckStyle： <a href="http://blog.csdn.net/qq_36871364/article/details/72472059" target="_blank" rel="noopener">http://blog.csdn.net/qq_36871364/article/details/72472059</a></p><p>Eclipse Marketplace地址：<a href="http://marketplace.eclipse.org/" target="_blank" rel="noopener">http://marketplace.eclipse.org/</a></p><h1 id="Checkstyle全局配置"><a href="#Checkstyle全局配置" class="headerlink" title="Checkstyle全局配置"></a>Checkstyle全局配置</h1><p>Window –&gt;Preferences,选择checkstyle菜单，增加项目组统一的规则文件，并设置为默认规则。如下图：</p><p><img src="/2018/03/22/checkstyle/p1.png" alt="logo"></p><p><img src="/2018/03/22/checkstyle/p2.png" alt="logo"></p><p>到此全局配置已经完成。</p><h1 id="Checkstyle项目配置"><a href="#Checkstyle项目配置" class="headerlink" title="Checkstyle项目配置"></a>Checkstyle项目配置</h1><p>项目 –&gt; 右键Properties</p><p><img src="/2018/03/22/checkstyle/p3.png" alt="logo"></p><p>到此项目配置已经完成。成功的话，checkstyle已经开始工作了。</p><p>此次发现项目上有很多红叉叉，说明是代码符合规范造成的。</p><p><img src="/2018/03/22/checkstyle/p4.png" alt="logo"></p><p>根据提示信息修改后，则没有有红色的提示。</p><p><img src="/2018/03/22/checkstyle/p5.png" alt="logo"></p><h1 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h1><p>在项目右键菜单中，checkstyle还有一些快捷操作，如下图所示：</p><p><img src="/2018/03/22/checkstyle/p6.png" alt="logo"></p><h1 id="checkStyle-使用"><a href="#checkStyle-使用" class="headerlink" title="checkStyle 使用"></a>checkStyle 使用</h1><p>选中工程，右键选择checkstyle-&gt;check code withcheckstyle,检查错误即可</p><p>Checkstyle的结果输出</p><p>序号     输出内容意义<br>1         Type is missing a javadoc commentClass 缺少类型说明<br>2        “{” should be on the previous line “{” 应该位于前一行<br>3        Methos is missing a javadoc comment方法前面缺少javadoc注释<br>4        Expected @throws tag for “Exception”在注释中希望有@throws的说明<br>5        “.” Is preceeded with whitespace “.” 前面不能有空格<br>6        “.” Is followed by whitespace“.” 后面不能有空格<br>7        “=” is not preceeded with whitespace“=” 前面缺少空格<br>8        “=” is not followed with whitespace“=” 后面缺少空格<br>9        “}” should be on the same line“}” 应该与下条语句位于同一行<br>10        Unused @param tag for “unused”没有参数“unused”，不需注释<br>11        Variable “CA” missing javadoc变量“CA”缺少javadoc注释<br>12        Line longer than 80characters行长度超过80<br>13        Line contains a tab character行含有”tab” 字符<br>14        Redundant “Public” modifier冗余的“public” modifier<br>15        Final modifier out of order with the JSL suggestionFinalmodifier的顺序错误<br>16        Avoid using the “.<em>” form of importImport格式避免使用“.</em>”<br>17        Redundant import from the same package从同一个包中Import内容<br>18        Unusedimport-java.util.listImport进来的java.util.list没有被使用<br>19        Duplicate import to line 13重复Import同一个内容<br>20        Import from illegal package从非法包中 Import内容<br>21        “while” construct must use “{}”“while” 语句缺少“{}”<br>22        Variable “sTest1” must be private and have accessormethod变量“sTest1”应该是private的，并且有调用它的方法<br>23        Variable “ABC” must match pattern“^[a-z][a-zA-Z0-9]<em>$”变量“ABC”不符合命名规则“^[a-z][a-zA-Z0-9]</em>$”<br>24        “(” is followed by whitespace“(” 后面不能有空格 25“)” is proceededby whitespace“)” 前面不能有空格</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CheckStyle是SourceForge下的一个项目，提供了一个帮助Java开发人员遵守某些编码规范的工具。它能够自动化代码规范检查过程，从而使得开发人员从这项重要但枯燥的任务中解脱出来。它可以根据设置好的编码规则来检查代码。比如符合规范的变量命名，方法体的最大行数，重复代码检查等等。&lt;/p&gt;
&lt;p&gt;如果你的项目经理开会时说：“我希望我们写出来的代码就象一个人写的!”，那么用Checkstyle绝对是正确选择！&lt;/p&gt;
    
    </summary>
    
      <category term="工具类" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
      <category term="软件架构" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
      <category term="插件" scheme="http://yoursite.com/tags/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="eclipse" scheme="http://yoursite.com/tags/eclipse/"/>
    
      <category term="代码规范" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>项目自动构建工具--maven和Gradle</title>
    <link href="http://yoursite.com/2018/03/22/maven01/"/>
    <id>http://yoursite.com/2018/03/22/maven01/</id>
    <published>2018-03-21T17:30:13.000Z</published>
    <updated>2018-03-23T08:30:46.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h1><p>Gradle和Maven都是项目自动构建工具，编译源代码只是整个过程的一个方面，更重要的是，你要把你的软件发布到生产环境中来产生商业价值，所以，你要运行测试，构建分布、分析代码质量、甚至为不同目标环境提供不同版本，然后部署。整个过程进行自动化操作是很有必要的。整个过程可以分成以下几个步骤：</p><ul><li>编译源代码</li><li>运行单元测试和集成测试</li><li>执行静态代码分析、生成分析报告</li><li>创建发布版本</li><li>部署到目标环境</li><li>部署传递过程</li><li>执行冒烟测试和自动功能测试</li></ul><a id="more"></a><p>如果你手工去执行每一个步骤无疑效率比较低而且容易出错，有了自动化构建你只需要自定义你的构建逻辑，剩下的事情交给工具去完成。虽然两者都是项目工具，但是maven现在已经是行业标准，Gradle是后起之秀，很多人对他的了解都是从android studio中得到的，Gradle抛弃了Maven的基于XML的繁琐配置，众所周知XML的阅读体验比较差，对于机器来说虽然容易识别，但毕竟是由人去维护的。取而代之的是Gradle采用了领域特定语言Groovy的配置，大大简化了构建代码的行数，比如在Maven中你要引入一个依赖：<br>    <properties><br>        &lt;kaptcha.version&gt;2.3&lt;/kaptcha.version&gt;<br>    </properties><br>    <dependencies><br>        <dependency><br>            <groupid>com.google.code.kaptcha</groupid><br>            <artifactid>kaptcha</artifactid><br>            <version>${kaptcha.version}</version><br>            <classifier>jdk15</classifier><br>        </dependency><br>        <dependency><br>            <groupid>org.springframework</groupid><br>            <artifactid>spring-core</artifactid><br>        </dependency><br>        <dependency><br>            <groupid>org.springframework</groupid><br>            <artifactid>spring-beans</artifactid><br>        </dependency><br>        <dependency><br>            <groupid>org.springframework</groupid><br>            <artifactid>spring-context</artifactid><br>        </dependency><br>        <dependency><br>            <groupid>junit</groupid><br>            <artifactid>junit</artifactid><br>        </dependency><br>    </dependencies></p><p>然后我将其转换成Gradle脚本，结果是惊人的：<br>    dependencies {<br>        compile(‘org.springframework:spring-core:2.5.6’)<br>        compile(‘org.springframework:spring-beans:2.5.6’)<br>        compile(‘org.springframework:spring-context:2.5.6’)<br>        compile(‘com.google.code.kaptcha:kaptcha:2.3:jdk15’)<br>        testCompile(‘junit:junit:4.7’)<br>    }<br>注意配置从原来的28行缩减至7行！这还不算我省略的一些父POM配置。依赖的groupId、artifactId、 version，scope甚至是classfier，一点都不少。较之于Maven或者Ant的XML配置脚本，Gradle使用的Grovvy脚本杀伤力太大了，爱美之心，人皆有之，相比于七旬老妇松松垮垮的皱纹，大家肯定都喜欢少女紧致的脸蛋，XML就是那老妇的皱纹。Gradle给我最大的有点是两点。其一是简洁，基于Groovy的紧凑脚本实在让人爱不释手，在表述意图方面也没有什么不清晰的地方。其二是灵活，各种在Maven中难以下手的事情，在Gradle就是小菜一碟，比如修改现有的构建生命周期，几行配置就完成了，同样的事情，在Maven中你必须编写一个插件，那对于一个刚入门的用户来说，没个一两天几乎是不可能完成的任务。</p><p>gradle基于groovy领域特定语言，而maven通过xml来配置，比较繁琐</p><p>Gradle和Maven作为自动构建工具，在项目的构建中有着广泛的应用。他们之间有各自的优缺点，这里我们讨论下他们在项目构建中的一些区别并进行比较。</p><p>首先简单介绍下Gradle和Maven。Maven主要服务于基于java平台的项目构建、依赖管理和项目信息管理。无论是小型的开源类库项目，还是大型的企业级应用；无论是传统的瀑布式开发还是流行的敏捷模式，Maven都能大显身手。Gradle是以groovy语言为基础，面向java应用为主，基于DSL语法的自动化构建工具。</p><p>虽然两种构建工具有着很多相似处，但是在依赖管理、构建生命周期、加载构建系统组件等许多方面两者有着许多区别。Maven使用XML来定义生成脚本，而 Gradle构建脚本是用Groovy。 用XML的优势在于它可以更方便地定义构建逻辑，但这是比较复杂的步骤。 用Groovy的好处是写起来比XML标签要简洁许多。 不过熟悉的XML的开发人员比groovy的多，并且复杂的逻辑必须由自己编写。类似于Maven的pom.xml文件，每个Gradle项目都需要有一个对应的build.gradle文件，该文件定义一些任务（task）来完成构建工作，当然，每个任务是可配置的，任务之间也可以依赖，用户亦能配置缺省任务。</p><h2 id="加载构建系统的组件"><a href="#加载构建系统的组件" class="headerlink" title="加载构建系统的组件"></a>加载构建系统的组件</h2><p>Maven中每个用于构建的组件（编译/jar等）都作为一个插件， 每个插件都有它自己的版本和依赖关系树。 Gradle的构建系统组件都是分散的。 Maven插件的优点是在于可以独立更新，无需整个系统更新。Gradle的模型的优点是编译需要核心组件以外的组件时才下载。与此同时Gradle给了用户足够的自由去定义自己的任务，Gradle每个任务都有一个描述,可以分配到一个组。Maven中插件和命令可以描述。比如Gradle你可以排除任何运行的任务。在Maven中没有通用的排除机制，必须用插件来实现它。而且Gradle具有高级任务排序的特性，任务之间的依赖关系被建立之后能够得到完全控制，因为Gradle具有强大的语言结构来描述任务之间的执行顺序，即使任务并不取决于对方的输出。Gradle支持动态任务创建，有时你想要一个任务的行为取决于或无限价值的大范围的参数。一个很好的表达方式提供这样的任务是任务规则。并且执行任务时，Gradle 在遇到第一次失败时不停止，执行每一个要执行的任务其中所有的任务依赖关系都要被完成且没有失败。任务可以被分配去完成其他任务类似于java中的终结原则。他们总是在另一个任务执行之后运行，不管这个任务是否失败了。可以发现在一个单一的执行中许多失败任务会被很好地记录成一个错误报告并最终被汇总。</p><h2 id="构建生命周期"><a href="#构建生命周期" class="headerlink" title="构建生命周期"></a>构建生命周期</h2><p>Maven提供有限的构建生命周期访问，插件可以连接到生命周期的特定阶段，而且只有在核心插件执行。而Gradle可以访问生成的一部分并允许用Groovy代码进行处理。Gradle Java Plugin也定义了构建生命周期，包括编译主代码、处理资源、编译测试代码、执行测试、上传归档等等任务.</p><p>相对于Maven完全线性的生命周期，Gradle的构建生命周期略微复杂，不过也更为灵活，例如jar这个任务是用来打包的，它不像Maven那样依赖于执行测试的test任务，类似的，从图中可以看到，一个最终的build任务也没有依赖于uploadArchives任务。这个生命周期并没有将用户限制得很死，由于Gradle完全是基于灵活的任务模型，因此很多事情包括覆盖现有任务，跳过任务都非常易于实现。而这些事情，在Maven的世界中，实现起来就比较的麻烦，或者说Maven就不希望用户这么做。</p><p>除了以上几个Maven核心内容与Gradle的区别，在面向对象输出模式，GUI操作界面、声明元素等方面Gradle也有良好表现。构建输出是构建用户体验的重要部分。在其他大多数构建工具中默认输出对于一个构建作者试图调试一个问题来说是有关联的。这通常会导致一个非常详细的输出会隐藏重要的警告和消息实际上是相关的开发人员运行构建。Gradle的默认输出是针对开发人员运行构建和只显示消息相关的情况下而不是滥用日志输出作为一种进度，例如在执行测试的时候。构建输出为构建用户体验是非常重要的。如果你与外部工具和库集成他们的控制台输出可能非常冗长。Gradle系统中你可以定义每个外部工具结合的日志级别的输出应该被路由。Gradle提供GUI操作界面，这是一个独立的用户界面，可以启动GUI选项，通过自定义日志模式你可以替换它的日志与自己的UI。Gradle有许多细粒度的声明性元素,如SourceSets或Android Product Flavors。它们的核心Gradle DSL然后让Gradle构建语言更加丰富。他们不断构建简洁、易于使用、维护和理解即使你有复杂的需求。Maven没有细粒声明元素，这是Maven极端顽固的主要原因。在Gradle,每个插件都可以提供自己的粗或细粒声明元素。这使你可以提供一个声明性方法甚至定制域。它还允许其他技术集成在Gradle中,让它被更多人使用。</p><p>整体来讲，Gradle给人一种简洁灵活的体验，然而必须掌握groovy也是他的问题，而且由于其灵活性，导致人们更容易破坏约定以至于让构建变得难以理解。但是Gradle确实是Maven理念的优秀实现。如果足够了解Groovy，也理解Maven的配置和构建，Gradle会是绝佳选择，尤其是它几乎能和现有的Maven系统无缝集成，而且你也能享受到简洁带来的极大乐趣，相信Gradle作为后起之秀在今后能够被完善的更好。</p><h1 id="关于groovy语言"><a href="#关于groovy语言" class="headerlink" title="关于groovy语言"></a>关于groovy语言</h1><p>Groovy 是 用于Java虚拟机的一种敏捷的动态语言，它是一种成熟的面向对象编程语言，既可以用于面向对象编程，又可以用作纯粹的脚本语言。使用该种语言不必编写过多的代码，同时又具有闭包和动态语言中的其他特性。</p><p>Groovy是JVM的一个替代语言（替代是指可以用 Groovy 在Java平台上进行 Java 编程），使用方式基本与使用 Java代码的方式相同，该语言特别适合与Spring的动态语言支持一起使用，设计时充分考虑了Java集成，这使 Groovy 与 Java 代码的互操作很容易。（注意：不是指Groovy替代java，而是指Groovy和java很好的结合编程。</p><p>Groovy 语法与Java 语言的语法很相似，虽然 Groovy 的语法源于Smalltalk和Ruby这类语言的理念，但是可以将它想像成 Java 语言的一种更加简单、表达能力更强的变体。（在这点上，Ruby与 Groovy 不同，因为它的语法与 Java 语法差异很大。）</p><p>许多 Java 开发人员喜欢 Groovy 代码和 Java 代码的相似性。从学习的角度看，如果知道如何编写 Java 代码，那就已经了解 Groovy 了。Groovy 和 Java 语言的主要区别是：完成同样的任务所需的 Groovy 代码比 Java 代码更少。</p><p>Groovy教程参考： <a href="https://www.w3cschool.cn/groovy/" target="_blank" rel="noopener">https://www.w3cschool.cn/groovy/</a></p><p>在现在市场上流行的微服务架构都建议采用Gradle来构建项目而非Maven</p><p>spring 项目建议使用Gradle进行构建项目，相比maven来讲 Gradle更简洁，而且gradle更时候大型复杂项目的构建。gradle吸收了maven和ant的特点而来，不过目前maven仍然是Java界的主流，大家可以先了解了解。</p><p>一个使用gradle配置的项目（在开发人员的角度去看这个会发现比maven构建项目的结构会更加的清晰明了）</p><pre><code>buildscript {    repositories {        maven { url &quot;http://repo.spring.io/libs-snapshot&quot; }        mavenLocal()    }    dependencies {        classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:1.3.6.RELEASE&quot;)    }}apply plugin: &apos;java&apos;  //添加 Java 插件, 表明这是一个 Java 项目apply plugin: &apos;spring-boot&apos; //添加 Spring-boot支持apply plugin: &apos;war&apos;  //添加 War 插件, 可以导出 War 包apply plugin: &apos;eclipse&apos; //添加 Eclipse 插件, 添加 Eclipse IDE 支持, Intellij Idea 为 &quot;idea&quot;war {    baseName = &apos;favorites&apos;    version =  &apos;0.1.0&apos;}sourceCompatibility = 1.7  //最低兼容版本 JDK1.7targetCompatibility = 1.7  //目标兼容版本 JDK1.7repositories {     //  Maven 仓库    mavenLocal()        //使用本地仓库    mavenCentral()      //使用中央仓库    maven { url &quot;http://repo.spring.io/libs-snapshot&quot; } //使用远程仓库}dependencies {   // 各种 依赖的jar包    compile(&quot;org.springframework.boot:spring-boot-starter-web:1.3.6.RELEASE&quot;)    compile(&quot;org.springframework.boot:spring-boot-starter-thymeleaf:1.3.6.RELEASE&quot;)    compile(&quot;org.springframework.boot:spring-boot-starter-data-jpa:1.3.6.RELEASE&quot;)    compile group: &apos;mysql&apos;, name: &apos;mysql-connector-java&apos;, version: &apos;5.1.6&apos;    compile group: &apos;org.apache.commons&apos;, name: &apos;commons-lang3&apos;, version: &apos;3.4&apos;    compile(&quot;org.springframework.boot:spring-boot-devtools:1.3.6.RELEASE&quot;)    compile(&quot;org.springframework.boot:spring-boot-starter-test:1.3.6.RELEASE&quot;)    compile &apos;org.webjars.bower:bootstrap:3.3.6&apos;    compile &apos;org.webjars.bower:jquery:2.2.4&apos;    compile(&quot;org.webjars:vue:1.0.24&quot;)    compile &apos;org.webjars.bower:vue-resource:0.7.0&apos;}bootRun {    addResources = true}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;主要区别&quot;&gt;&lt;a href=&quot;#主要区别&quot; class=&quot;headerlink&quot; title=&quot;主要区别&quot;&gt;&lt;/a&gt;主要区别&lt;/h1&gt;&lt;p&gt;Gradle和Maven都是项目自动构建工具，编译源代码只是整个过程的一个方面，更重要的是，你要把你的软件发布到生产环境中来产生商业价值，所以，你要运行测试，构建分布、分析代码质量、甚至为不同目标环境提供不同版本，然后部署。整个过程进行自动化操作是很有必要的。整个过程可以分成以下几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译源代码&lt;/li&gt;
&lt;li&gt;运行单元测试和集成测试&lt;/li&gt;
&lt;li&gt;执行静态代码分析、生成分析报告&lt;/li&gt;
&lt;li&gt;创建发布版本&lt;/li&gt;
&lt;li&gt;部署到目标环境&lt;/li&gt;
&lt;li&gt;部署传递过程&lt;/li&gt;
&lt;li&gt;执行冒烟测试和自动功能测试&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="工具类" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
      <category term="软件架构" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
      <category term="构建工具" scheme="http://yoursite.com/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
      <category term="maven" scheme="http://yoursite.com/tags/maven/"/>
    
      <category term="Gradle" scheme="http://yoursite.com/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>微服务架构--Dubbo还是Spring Cloud？</title>
    <link href="http://yoursite.com/2018/03/20/%E5%88%86%E5%B8%83%E5%BC%8F02/"/>
    <id>http://yoursite.com/2018/03/20/分布式02/</id>
    <published>2018-03-20T13:04:00.000Z</published>
    <updated>2018-03-22T11:41:48.133Z</updated>
    
    <content type="html"><![CDATA[<p>微服务以及SOA我们在上一篇《微服务架构简析》中已经谈及了，接下来我们来谈谈市面上流行的微服务架构产品有哪些?</p><p>微服务架构是互联网很热门的话题，是互联网技术发展的必然结果。它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。</p><p>虽然微服务架构没有公认的技术标准和规范或者草案，但业界已经有一些很有影响力的开源微服务架构框架提供了微服务的关键思路，例如 Dubbo 和 Spring Cloud。</p><a id="more"></a><h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1><p>Dubbo 是阿里巴巴公司一个开源的高性能服务框架，致力于提供高性能和透明化的 RPC 远程服务调用方案，以及 SOA 服务治理方案，使得应用可通过高性能 RPC 实现服务的输出、输入功能和 Spring 框架无缝集成。(淘宝为了应付双11的高流量并发请求所带来的服务器压力而开发的产品)。</p><p>Dubbo 包含远程通讯、集群容错和自动发现三个核心部分。它提供透明化的远程方法调用，实现像调用本地方法一样调用远程方法，只需简单配置，没有任何 API 侵入。</p><p>同时它具备软负载均衡及容错机制，可在内网替代 F5 等硬件负载均衡器，降低成本，减少单点。</p><p>它可以实现服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的 IP 地址，并且能够平滑添加或删除服务提供者。</p><p>2011 年末，阿里巴巴在 GitHub 上开源了基于 Java 的分布式服务治理框架 Dubbo，之后它成为了国内该类开源项目的佼佼者，许多开发者对其表示青睐。</p><p>同时，先后有不少公司在实践中基于 Dubbo 进行分布式系统架构。目前在 GitHub 上，它的 fork、star 数均已破万。</p><p>Dubbo 核心部件（如下图）:</p><ul><li>Provider：暴露服务的提供方，可以通过 jar 或者容器的方式启动服务。</li><li>Consumer：调用远程服务的服务消费方。</li><li>Registry：服务注册中心和发现中心。</li><li>Monitor：统计服务和调用次数，调用时间监控中心。（Dubbo 的控制台页面中可以显示，目前只有一个简单版本。）</li><li>Container：服务运行的容器。</li></ul><p><img src="/2018/03/20/分布式02/p1.jpg" alt="logo"><br>Dubbo总体架构</p><p>Dubbo 核心功能：</p><p>1.远程通讯，提供对多种基于长连接的 NIO 框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。<br>2.集群容错，提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。<br>3.自动发现，基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</p><p>关于Dubbo的历史可以到这篇知乎文章中去看，人家已经整理了Dubbo的发展历史。<br><a href="https://zhuanlan.zhihu.com/p/31206177" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31206177</a></p><h1 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h1><p>spring cloud 为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等。它运行环境简单，可以在开发人员的电脑上跑。另外说明spring cloud是基于springboot的，所以需要开发中对springboot有一定的了解。</p><p>Spring Cloud的子项目，大致可分成两类，一类是对现有成熟框架”Spring Boot化”的封装和抽象，也是数量最多的项目；第二类是开发了一部分分布式系统的基础设施的实现，如Spring Cloud Stream扮演的就是kafka, ActiveMQ这样的角色。对于我们想快速实践微服务的开发者来说，第一类子项目就已经足够使用，如：</p><ul><li><p>Spring Cloud Netflix<br>　　是对Netflix开发的一套分布式服务框架的封装，包括服务的发现和注册，负载均衡、断路器、REST客户端、请求路由等。</p></li><li><p>Spring Cloud Config<br>　　将配置信息中央化保存, 配置Spring Cloud Bus可以实现动态修改配置文件</p></li><li><p>Spring Cloud Bus<br>　　分布式消息队列，是对Kafka, MQ的封装</p></li><li><p>Spring Cloud Security<br>　　对Spring Security的封装，并能配合Netflix使用</p></li><li><p>Spring Cloud Zookeeper<br>　　对Zookeeper的封装，使之能配置其它Spring Cloud的子项目使用</p></li><li><p>Spring Cloud Eureka<br> Spring Cloud Eureka 是 Spring Cloud Netflix 微服务套件中的一部分，它基于Netflix Eureka 做了二次封装，主要负责完成微服务架构中的服务治理功能。</p></li></ul><p>Spring Cloud对于中小型互联网公司来说是一种福音，因为这类公司往往没有实力或者没有足够的资金投入去开发自己的分布式系统基础设施，使用Spring Cloud一站式解决方案能在从容应对业务发展的同时大大减少开发成本。同时，随着近几年微服务架构和Docker容器概念的火爆，也会让Spring Cloud在未来越来越“云”化的软件开发风格中立有一席之地，尤其是在目前五花八门的分布式解决方案中提供了标准化的、全站式的技术方案，意义可能会堪比当前Servlet规范的诞生，有效推进服务端软件系统技术水平的进步。</p><p>Spring Cloud官方网站：<a href="https://projects.spring.io/spring-cloud/" target="_blank" rel="noopener">https://projects.spring.io/spring-cloud/</a> （包括英文DOC）<br>Spring Cloud中文文档地址：<a href="https://springcloud.cc/" target="_blank" rel="noopener">https://springcloud.cc/</a></p><p><img src="/2018/03/20/分布式02/p1.jpg" alt="logo"></p><p>学习资源整理：</p><p>Spring Cloud基础教程：<a href="http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</a><br>  对应Github项目：<a href="https://github.com/dyc87112/SpringCloud-Learning" target="_blank" rel="noopener">https://github.com/dyc87112/SpringCloud-Learning</a><br>方志朋的专栏 Spring Cloud：<a href="http://blog.csdn.net/forezp/article/details/70148833" target="_blank" rel="noopener">http://blog.csdn.net/forezp/article/details/70148833</a></p><p>Spring Boot基础教程：<a href="http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</a><br>  对应Github项目：<a href="https://github.com/dyc87112/SpringBoot-Learning" target="_blank" rel="noopener">https://github.com/dyc87112/SpringBoot-Learning</a><br>  对应码云：<a href="https://gitee.com/didispace/SpringBoot-Learning" target="_blank" rel="noopener">https://gitee.com/didispace/SpringBoot-Learning</a><br>方志朋的专栏 Spring Boot：<a href="http://blog.csdn.net/forezp/article/details/61472783" target="_blank" rel="noopener">http://blog.csdn.net/forezp/article/details/61472783</a>           </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微服务以及SOA我们在上一篇《微服务架构简析》中已经谈及了，接下来我们来谈谈市面上流行的微服务架构产品有哪些?&lt;/p&gt;
&lt;p&gt;微服务架构是互联网很热门的话题，是互联网技术发展的必然结果。它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。&lt;/p&gt;
&lt;p&gt;虽然微服务架构没有公认的技术标准和规范或者草案，但业界已经有一些很有影响力的开源微服务架构框架提供了微服务的关键思路，例如 Dubbo 和 Spring Cloud。&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="Dubbo" scheme="http://yoursite.com/tags/Dubbo/"/>
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>主流的Web服务实现方案--REST与SOAP和XML-RPC相比有哪些优势？</title>
    <link href="http://yoursite.com/2018/03/20/web%E9%A3%8E%E6%A0%BC/"/>
    <id>http://yoursite.com/2018/03/20/web风格/</id>
    <published>2018-03-20T08:51:36.000Z</published>
    <updated>2018-03-20T13:03:38.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于RESTful"><a href="#关于RESTful" class="headerlink" title="关于RESTful"></a>关于RESTful</h1><p>具象状态传输（REST，英文：Representational State Transfer）是Roy Thomas Fielding博士于2000年在他的博士论文中提出来的一种万维网软件架构风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息。</p><p>目前在三种主流的Web服务实现方案中，因为REST模式与复杂的SOAP和XML-RPC相比更加简洁，越来越多的web服务开始采用REST风格设计和实现。例如，Amazon.com提供接近REST风格的Web服务运行图书查询；雅虎提供的Web服务也是REST风格的。</p><a id="more"></a><p>具象状态传输是设计风格而不是标准。REST通常基于使用HTTP，URI，和XML以及HTML这些现有的广泛流行的协议和标准。<br>一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p><p>1.资源是由URI来指定。<br>2.对资源的操作包括获取、创建、修改和删除资源，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。<br>3.通过操作资源的表现形式来操作资源。<br>4.资源的表现形式则是XML或者HTML，取决于读者是机器还是人，是消费web服务的客户软件还是web浏览器。当然也可以是任何其他的格式。</p><h2 id="RESTful特征"><a href="#RESTful特征" class="headerlink" title="RESTful特征"></a>RESTful特征</h2><ul><li>统一接口(Uniform Interface)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于RESTful&quot;&gt;&lt;a href=&quot;#关于RESTful&quot; class=&quot;headerlink&quot; title=&quot;关于RESTful&quot;&gt;&lt;/a&gt;关于RESTful&lt;/h1&gt;&lt;p&gt;具象状态传输（REST，英文：Representational State Transfer）是Roy Thomas Fielding博士于2000年在他的博士论文中提出来的一种万维网软件架构风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息。&lt;/p&gt;
&lt;p&gt;目前在三种主流的Web服务实现方案中，因为REST模式与复杂的SOAP和XML-RPC相比更加简洁，越来越多的web服务开始采用REST风格设计和实现。例如，Amazon.com提供接近REST风格的Web服务运行图书查询；雅虎提供的Web服务也是REST风格的。&lt;/p&gt;
    
    </summary>
    
      <category term="WEB" scheme="http://yoursite.com/categories/WEB/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="软件架构" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
      <category term="REST" scheme="http://yoursite.com/tags/REST/"/>
    
  </entry>
  
  <entry>
    <title>微服务架构简析</title>
    <link href="http://yoursite.com/2018/03/20/%E5%88%86%E5%B8%83%E5%BC%8F01/"/>
    <id>http://yoursite.com/2018/03/20/分布式01/</id>
    <published>2018-03-19T16:34:06.000Z</published>
    <updated>2018-03-20T13:09:18.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微服务是什么？"><a href="#微服务是什么？" class="headerlink" title="微服务是什么？"></a>微服务是什么？</h1><p>谈及微服务架构，2016年应该是软件业微服务爆发的元年，微服务到底是什么？<br>观察现有的软件业，使用单独一款开发语言区开发一款较为全面的产品很少，大多数都是各种语言编写的功能模块进行组装成完整的业务模型，<br>各语言效率优势互补。<br>微服务架构所强调的特点就是业务系统需要彻底的组件化与模块分割，原有的单个业务系统分割成多个小应用，每个小应用可以进行独立开发，管理，运行和测试，甚至连每个产品的前端（UI加结构），服务端（控制层，逻辑层和持久化层），数据库都是完全独立的产品，通过微服务架构将每个小应用进行整合，交互与集成，每个小应用不仅能够自己完全独立的功能，还可以运行其他小应用的服务，同时也将自己作为可供利用的服务对象。</p><a id="more"></a><p>采用一组服务的方式来构建一个应用，服务独立部署在不同的进程中，不同服务通过一些轻量级交互机制来通信，例如 RPC、HTTP 等，服务可独立扩展伸缩，每个服务定义了明确的边界，不同的服务甚至可以采用不同的编程语言来实现，由独立的团队来维护。简单的来说，一个系统的不同模块转变成不同的服务！而且服务可以使用不同的技术加以实现。</p><p>有了微服务，彻底的将耦合性再次的降低，彼此之间可以高效解耦。</p><p>关于微服务到底是个啥，我这里引用了一个知乎的回答，很有意思：<br>作者：dz902<br>链接：<a href="https://www.zhihu.com/question/37808426/answer/195479692" target="_blank" rel="noopener">https://www.zhihu.com/question/37808426/answer/195479692</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>很久以前的一天，Martin 在跟好友的交流中悟到了一种很棒的架构设计。他总结了一下，然后告诉了好友，好友说，这不是新鲜东西，早有人总结了，叫做 SOA。Martin 很高兴，开始在公司内外推广 SOA。结果，不停有人质疑和挑战他。</p><p>你这不是 SOA 吧？SOA 这里应该是如此这般的。对，这里我对 SOA 的理解是这样的。你看，这本 SOA 的书说的和你说的有出入。粒度？SOA 没有谈到这个呀，你这不是 SOA。分层跟 SOA 没有关系，你为什么要说这个呢？</p><p>…Martin 没办法，心一横，老子就叫它 Martin’s SOA。老子发明的词，老子就是最高权威，有最终解释权。还有谁不服？同事们一看，这思想本身很不错，值得推广，但叫 Martin’s SOA 太没品了吧？还是要取个好一点的名字，最好还能跟 SOA 有某种暗示传承。干脆就叫 Microservices 好了，又新，又有服务含在其中。</p><p>Martin 忿忿地接受了这个建议，心里想着：妈的，明明就是 SOA，一群傻逼非要逼我取个新名字。后来 Martin 发现每次提一个东西就会收到旧恶傻势力对解释权的挑战，所以每次要提一个什么概念，都去发明一个新词，免得一群人在那一边质疑挑战，一边大谈“我的理解”。</p><p>这就是微服务、敏捷、精益企业、持续集成、持续交付背后的故事。一个名词产生之后，命名者的解释权就会随着时间而弱化（比如 Cooper 发明的 Persona 就被无数设计师乱用）。<br>敏捷已经有点烂了，等微服务也烂了，我们还会发明新词。实在没辙，都是被逼的啊。</p><p>微服务有以下几个特征：</p><ol><li>通过服务实现组件化；</li><li>按业务能力来划分服务与组织团队；</li><li>服务即产品；</li><li>智能终端与哑管道；</li><li>去中心统一化；</li><li>基础设施自动化；</li><li>Design for failure；</li><li>进化设计</li></ol><p>上面讲到微服务与SOA的宫斗戏码，又来讲讲什么是SOA？</p><h2 id="SOA架构"><a href="#SOA架构" class="headerlink" title="SOA架构"></a>SOA架构</h2><p>SOA是什么？SOA全英文是Service-Oriented Architecture，中文意思是中文面向服务编程，是一种思想，一种方法论，一种分布式的服务架构</p><p>可以肯定的是SOA和微服务的确是一脉相承的，大神Martin Fowler提出来这一概念可以说把SOA的理念继续升华，精进了一步。其核心思想是在应用开发领域，使用一系列微小服务来实现单个应用的方式途径，或者说微服务的目的是有效的拆分应用，实现敏捷开发和部署 ，可以是使用不同的编程语言编写。而SOA可能包含的意义更泛一些，更不准确一些。</p><p> 用途：SOA解决多服务凌乱问题，SOA架构解决数据服务的复杂程度，同时SOA又有一个名字，叫做服务治理。</p><p>架构由中心式转为分布式的演变过程</p><p>这里给一个电商服务由传统架构改向分布式架构的流程图</p><p><img src="/2018/03/20/分布式01/p1.png" alt="logo"></p><p>当我们的项目比较小时，我们只有一个系统，并且把他们写到一起，放在一个服务器上，但是随着平台越来越大，数据量越来越大，我们不得不通过分库，把多个模块的数据库分别放在对应得服务器上，每个模块调用自己的子系统即可。</p><p><img src="/2018/03/20/分布式01/p2.png" alt="logo"></p><p>随着我们系统的进一步复杂度的提示，我们不得不进一步对系统的性能进行提升，我们将多个模块分成多个子系统，多个子系统直接互相调用（因为SOA一般用于大型项目，比较复杂，所以一般总系统不会再集成，会拆分多个，分别做成服务，相互调用）。当我们的电商UI进行一个下订单的任务时，多个服务直接互相调用，系统通过数据总线，分别调用对应的子系统即可。</p><p>企业数据总线(ESB)：企业数据总线不是对多个子模块的集成，他在这里充当数据通道的作用，数据总线不关心业务，数据总线根据给的地址和协议去调服务，上端不关心服务在哪里是什么，只找数据总线。</p><p>上面几个图应该算是比较清楚了，随着业务的深入，我们不得不对系统进行调整，分别是对数据和业务的拆分，最后每个子系统对面提供服务。</p><p>还要提的一点就是下面那个图，下面的IP库以及几个子系统是公共服务，分别向上提供功能，也是SOA方法论的一部分。</p><p><img src="/2018/03/20/分布式01/p3.png" alt="logo"></p><p>通过上面的图我们可以看出，多个子系统直接相互交互，相互调用非常凌乱，这样我们就很不爽，所以我们就用到了我们的SOA架构，SOA又叫服务治理，SOA就是帮助我们把服务之间调用的乱七八糟的关系给治理起来，然后提供一个统一的标准，把我们的服务治理成下图所示，以前我们的服务是互相交互，现在是只对数据总线进行交互，这样系统就变得统一起来。</p><p><img src="/2018/03/20/分布式01/p4.png" alt="logo"></p><p>统一标准：各系统的协议、地址、交互方式。</p><p>新的交互方式：各个系统分别根据统一标准向数据总线进行注册，各子系统调用其他子系统时，我们并不关心如果找到其他子系统，我们只找数据总线，数据总线再根据统一标准找其他子系统，所以数据总线在这里充当一个只路人的作用。</p><p>首先Martin Fowler提出SOA歧义Service Oriented Ambiguity，认为”什么是SOA”是不可能回答，因为不同的人意味着不同的事情，SOA意味服务接口，意味流程整合，意味资源再利用，意味着管制，在下面SOA组件图中，服务和服务消费者(客户端)之间存在多个约束，当一个服务显式暴露后，客户端能够通过绑定定位到该服务，相当于两者签订了合同，规定了合同内容和如何实施，具体合同的描述是通过消息方式进行</p><p><img src="/2018/03/20/分布式01/soa.png" alt="logo"></p><p>由于Java等传统语言主要是以类表达对象，将功能行为封装在类内部，而业务客户一般都是注重软件的功能，包括同行业公司系统之间数据交流也是以功能服务为接口，因此，面向服务的架构SOA更加贴近业务客户，也更适合业务伙伴之间流程整合，各个行业已经诞生自己行业特点的SOA，例如电信联盟的NGOSS，已经成为电信行业业务支撑系统BOSS的标准。SOA不但是技术用语，也是业务销售用语，通过服务这个中间概念，可以实现业务和技术之间的无缝转换，如今SOA已经和REST DDD以及云计算等新技术方法结合。其内部主要概念有SCA ESB JBI等等，涉及工作流 规则引擎 消息总线等多个技术细节方面。</p><p>通常，一个架构师进行系统架构顶层设计时，必须考虑使用者的利益，不能单单实现软件的功能，还要考虑到软件的性能Scalable 可用性available/usable 安全性等软件质量，还要借鉴社区的最佳实践和经验形成的模式和反模式，避免重蹈覆辙和陷阱，再大胆采取最新的软件技术(比如用REST替代SOAP等)。</p><p>服务的提出其实隐含了两个概念，服务提供者和服务消费者，这两者之间有一个合同约定，这非常类似我们现实生活中签订的服务合同，A单位和B单位分别是服务的提供者和消费者，两者签订了一个服务合同，规定A为B提供某项服务。服务就是提供一些公共需求的设施，通过一个工作过程能提供帮助，使用，让使用者受益。</p><p>服务具体有如下：Windows Service:如PC定位者RPC Locator, 事件日志EventLog, DHCP Client,；. 软件服务Software Service，如分布式服务Distribution Service, 警告服务Alert Service 安全服务 Security Service, 日志服务；业务服务Business Service，如 帐号和客户服务，销售服务，订单服务，采购服务。</p><p>服务两个重要特点：自治和管制，自治代表服务不能被外部势力牵制，比如如果一个服务内部处理中需要调用外部资源或等待外部流程结束，这种等待不能影响服务本身的调用，如果一个服务分为显式对外和隐式内部两个部分，那么自治是针对隐式内部，意味着我们不能在具体一个服务中直接使用同步代码实现复杂功能。如：</p><pre><code>public AServiceImpl implements AService{　　public void productSale(...){　　　　Product product = productService.getProduct();　　　　int inventory = InventoryService.getInventory(product);　　　　int price = priceService.getPrice(product);　　}}</code></pre><p>在AServiceImpl的productSale方法中，我们获得商品的库存和定价，都是通过同步的RPC实现调用的，这样造成productSale方法依赖于InventoryService和priceService，无法实现自身自治。</p><p>实现服务真正自治，实际就是解决类之间依赖耦合的问题，消息是一种方式，但是基于消息又有两种通讯方式，基于请求响应和基于事件的EDA。</p><p>从服务自治可以看出，为什么要提出服务必须自治，因为服务是受管制的，在实际业务活动中，不同服务是被不同部分管理，比如定价服务归属财务部门系统，库存归属仓库系统，涉及系统之间调用协调不能自己使用同步RPC，而是需要消息。</p><p>在实际应用中，很多单位使用SOA主要看中其能够无缝整合新旧系统,称为EAI企业应用整合，下图是苏宁的一种SOA图，使用ESB企业服务总线这样的消息系统整合了新旧各种系统。</p><p><img src="/2018/03/20/分布式01/suning.jpg" alt="logo"></p><h3 id="ESB"><a href="#ESB" class="headerlink" title="ESB"></a>ESB</h3><p>ESB全称为Enterprise Service Bus，即企业服务总线。它是传统中间件技术与XML、Web服务等技术结合的产物。ESB提供了网络中最基本的连接中枢，是构筑企业神经系统的必要元素。ESB的出现改变了传统的软件架构，可以提供比传统中间件产品更为廉价的解决方案，同时它还可以消除不同应用之间的技术差异，让不同的应用服务器协调运作，实现了不同服务之间的通信与整合。从功能上看，ESB提供了事件驱动和文档导向的处理模式，以及分布式的运行管理机制，它支持基于内容的路由和过滤，具备了复杂数据的传输能力，并可以提供一系列的标准接口。</p><p><img src="/2018/03/20/分布式01/p5.png" alt="logo"></p><p>数据总线是起到调度服务的作用，数据总线不是集成服务，数据总线更新一个调度框架，每个服务需要根据约定向数据总线注册服务，那么如何注册那？其实数据总线就像一个字典结构，</p><p>数据总线里面一个key对于一个value，key指的是服务名，value则是服务的调度方式，还有一点需要说明的是，数据总线只是指路人，服务是不经过数据总线的，如上图的黄色线的路径。</p><p>企业服务总线（EnterpriseServiceBus，ESB）从面向服务体系架构（Service-OrientedArchitecture，SOA）发展而来，是传统中间件技术与XML、Web服务等技术结合的产物。<br>ESB提供了网络中最基本的连接中枢，是构筑企业神经系统的必要元素。ESB采用了“总线”这样一种模式来管理和简化应用之间的集成拓扑结构，以广为接受的开放标准为基础来支持应用之间在消息、事件和服务级别上动态的互连互通，是一种在松散耦合的服务和应用之间标准的集成方式。它可以作用于：<br>①面向服务的架构—分布式的应用由可重用的服务组成；<br>②面向消息的架构—应用之间通过ESB发送和接受消息；<br>③事件驱动的架构—应用之间异步地产生和接收消息。<br>ESB的出现改变了传统的软件架构，可以提供比传统中间件产品更为低廉的解决方案，同时它还可以消除不同应用之间的技术差异，让不同的应用服务器协调运作，实现了不同服务之间的通信与整合。从功能上看，ESB提供了事件驱动和文档导向的处理模式，以及分布式的运行管理机制，它支持基于内容的路由和过滤，具备了复杂数据的传输能力，并可以提供一系列的标准接口。</p><p>ESB 是传统中间件技术与XML、Web服务等技术相互结合的产物，ESB的出现改变了传统的软件架构，可以提供比传统中间件产品更为廉价的解决方案，同时它还可以消除不同应用之间的技术差异，让不同的应用服务器协调运作，实现了不同服务之间的通信与整合。从功能上看，ESB提供了事件驱动和文档导向的处理模式，以及分布式的运行管理机制，它支持基于内容的路由和过滤，具备了复杂数据的传输能力，并可以提供一系列的标准接口。</p><p>大规模分布式的企业应用需要相对简单而实用的中间件技术来简化和统一越来越复杂、繁琐的企业级信息系统平台。面向服务体系架构（SOA）是能够将应用程序的不同功能单元通过服务之间定义良好的接口和契约联系起来。SOA使用户可以不受限制地重复使用软件、把各种资源互连起来，只要IT人员选用标准接口包装旧的应用程序、把新的应用程序构建成服务，那么其他应用系统就可以很方便的使用这些功能服务。<br>支撑SOA的关键是其消息传递架构-企业服务总线（ESB）。ESB是传统中间件技术与XML、Web服务等技术相互结合的产物，用于实现企业应用不同消息和信息的准确、高效和安全传递。让不同的应用服务协调运作，实现不同服务之间的通信与整合。ESB在不同领域具有非常广泛的用途:</p><p>电信领域：ESB能够在全方位支持电信行业OSS的应用整合概念。是理想的电信级应用软件承载平台。<br>电力领域：ESB能够在全方位支持电力行业EMS的数据整合概念，是理想的SCADA系统数据交换平台。<br>金融领域：ESB能够在全方位支持银企间业务处理平台的流程整合概念，是理想的B2B交易支撑平台。<br>电子政务：ESB能够在全方位支持电子政务应用软件业务基础平台、信息共享交换平台、决策分析支撑平台和政务门户的平台化实现。</p><p>使用SOA和ESB能够灵活实现业务流程管理，工作流的管理BPM，如下图，一个订单的产生可能需要几个部门批准才能完成，而且这几个部门经常是变化的，如何灵活实现这种批准流程的定制也成为SOA实现的一部分，如下：</p><p><img src="/2018/03/20/分布式01/bpm.png" alt="logo"></p><p>注意图中1 2 3 4 5 6 7 8 9标注的订单处理流程步骤，这种不同服务之间调用处理顺序可通过BPM进行灵活定制。</p><p>目前提供SOA全套解决方案和产品的厂商很多，包括IBM SAP和Oracle，国内金蝶用友浪潮软件等等，比如苏宁的SOA是以SAP为主的八国联军组装，既然SOA中间件服务商已经为我们提供了成熟的架构方案和产品，那么作为SOA使用者是否就无需顶层架构设计了呢？当然不是，SOA使用者要根据自己业务进行模块划分，进行领域建模设计，根据DDD领域驱动设计将业务分解为一个上下文模块，然后再用服务作为对外接口，内部封装的是DDD聚合根，而传统SOA作法是内部封装的是数据表的DTO，从而导致SOA服务内部腐烂堵塞，违背SOA自治和可用性等原则约束。具体可见DDD领域驱动设计。</p><p>SOA的好处<br>1.松耦合：由于服务自治，有一定封装边界，服务调用交互是通过发布接口。这意味着应用程序不感兴趣的服务如何被实现。<br>2.位置透明：服务的消费者不必关系服务位于什么地方。<br>3.可在异构平台间复用。可以将遗留系统包装成服务。<br>4.便于测试，能并行开发，较高可靠性和良好可伸缩性。<br>5.降低用户成本，用户不需要关心各服务之间是什么语言的、不需要知道如果调用他们，只要通过统一标准找数据总线就可以了。<br>6.程序之间关系服务简单<br>7.识别哪些程序有问题（挂掉）</p><p>缺点：提示了系统的复杂程度，性能有相应影响。</p><p>从实现方式上，两者都是中立性，语言无关，协议跨平台，相比SOA，微服务框架将能够带来更大的敏捷性，并为你构建应用提供更轻量级、更高效率的开发。而SOA更适合大型企业中的业务过程编排、应用集成。</p><p>另外还有微服务甚至是去ESB、去中心化、分布式的，而SOA还是以ESB为核心，大量的WS标准实现。再次，从服务粒度上，既然是微，必然微服务更倡导服务的细粒度，重用组合，甚至是每个操作（或方法）都是独立开发的服务，足够小到不能再进行拆分。而SOA没有这么极致的要求，只需要接口契约的规范化，内部实现可以更粗粒度，微服务更多为了可扩充性、负载均衡以及提高吞吐量而去分解应用，但同时也引发了打破数据模型以及维护一致性的问题。</p><p>微服务相比于SOA粒度更细。</p><p>最后，从部署方式上，这个是最大的不同，对比Monolithic（有人翻译为单体）的Java EE部署架构，通过展现层打包WARs，业务层划分到JARs最后部署为EAR一个大包，而微服务则打开了这个黑盒子，把应用拆分成为一个一个的单个服务，应用Docker技术，不依赖任何服务器和数据模型，是一个 全栈应用，可以通过自动化方式独立部署，每个服务运行在自己的进程中，通过轻量的通讯机制联系，经常是基于HTTP资源API，这些服务基于业务能力构建，能实现集中化管理（因为服务太多啦，不集中管理就无法DevOps啦）。</p><p><strong>引用知乎比喻：</strong></p><p>以一个公司为例：有基层员工 有管理层 有老板，最初大家都听老板指挥，谁干什么谁干什么，根据需要，你可能今天干A事情，明天干B事情，后来人越来越多了，事情也越来越多了，做事情的效率越来越多，管理也很混乱，就开始做部门划分（服务化），专门部门做专门事情的，IT部门只做研发，人事部门只做招聘； 这个时候就无法避免的发生跨部门协作（服务器调用）， 但是你怎么知道有这样一个部门可以做这个事情呢，就要依赖行政部门（注册中心），新成立的部门要在行政哪里做一个备案（服务注册），然后公布一下，让其他部门知道了（服务发布），大家就可以在新的工作秩序里面嗨皮的上班了，这个时候依然是在公司的组织架构中运转；</p><p>上述就是我理解的SOA的概念微服务没有具体的实施过，通过自己的一些理解尝试解释一下，勿喷！微服务有一定SOA的概念在里面，只是在粒度中，微服务更加细一点，比如说用户业务服务：登录 注册 个人中心 包含3个业务，都有userService 提供的，但是在微服务中，登录会被独立出来一个服务，注册也会被独立出来，相对SOA的粒度更细，业务场景耦合更低；另外微服务强调一个去中心化，上述的公司的组织架构会被打散，没有老板，没有管理层，每一个人都是一个服务，做着自己的事情，虽然没有完全想明白，把自己的理解放出来，大家可以探讨一下。</p><p>微服务是SOA的一种实现，也可以说微服务是去ESB的SOA</p><p>背后实际上是两种思想的分歧：分布还是集中</p><p>当然这里说的不是服务的分布和集中。服务肯定是分布的，这是大前提，是SOA的本质理念之一。分歧在于对服务的治理，是分布还是集中。</p><p>微服务所提倡的是完完全全的分布式服务。</p><h2 id="微服务架构特征（Characteristics）"><a href="#微服务架构特征（Characteristics）" class="headerlink" title="微服务架构特征（Characteristics）"></a>微服务架构特征（Characteristics）</h2><p>微服务架构是 Martin Fowler 和 James Lewis 定义的一种架构风格。他们将这种风格描述为”一种使用小型服务构建系统的架构方法，每个服务都在自己的进程中，它们通过轻量型协议进行通信”。</p><p>每个服务都是相互独立开发和部署的。每个微服务都专注执行一个它所擅长的相对较小的任务。</p><p>微服务架构是产品或服务所有者跟上或超越 IT 行业的快速发展节奏的推动因素之一。</p><h3 id="小型且专注于业务领域"><a href="#小型且专注于业务领域" class="headerlink" title="小型且专注于业务领域"></a>小型且专注于业务领域</h3><p>小并不能充分描述微服务，使用这个词只是为了尝试表明微服务相对于整体式应用程序的大小。在此上下文中，小的定义可能在各个系统中各不相同，而且没有规则来定义服务必须有多小。<br>我的理解是将传统整体式应用服务拆分为可独立运行互不干扰的最小组件，这个组件涵盖软件设计的全部细节，前段后端数据端，开发者必须熟悉小组件设计的全部设计环节，这岂不是以后每个人都必须是全栈式开发人员？</p><p>微服务的另一个重要特征是，每个服务专注负责一项精细的业务。Vaughn Vernon 在他撰写的图书《实现领域驱动设计》中定义了术语业务领域。他将业务领域定义为，”某个组织执行的操作和它执行操作的环境。”他还指定，”每个组织都有自己独特的知识范围和操作方式。这个理解范围和它执行操作的方法就是它的领域。”被分解为微服务的单元实际上就是领域内的业务实体，<strong>这意味着每个微服务处理完成一个完整的业务任务</strong>。例如：Mortgage Services 是一个业务领域。Loan Origination 是该领域中一个可能的微服务。Loan Refinancing 可能是同一个领域中的另一个微服务。跨服务边界的调用和更改通常很耗资源，必须避免。拥有这些服务的团队成为相应业务领域或子领域的专家，而不是任意技术领域的专家。</p><p>微服务通常负责一个精细的工作单元，所以它在规模上相对较小。一条著名的指导原则是”两块披萨的团队规模”方案，意思是说，如果两块披萨不能将整个团队喂饱，那么这个开发微服务的团队可能太大了。微服务必须足够小，使得团队中的每个人都能理解该服务的整体设计和实现。另外，它的大小必须足以让团队在必要时轻松地维护或重写服务。</p><h3 id="与技术中立"><a href="#与技术中立" class="headerlink" title="与技术中立"></a>与技术中立</h3><p>开发微服务的团队必须使用他们熟悉的技术。不要规定开发团队应该使用何种编程语言。让开发人员自由选择对任务最有意义的技术和执行任务的人。这种工作方式能够充分利用团队成员拥有的最佳技术和技能。微服务架构仍需要技术决策；举例而言，使用具象状态传输 (REST) 应用编程接口 (API) 访问更好一些（即RESTful API），还是使用某种类型的排队来访问更好一些？但是，一般而言，您可以为微服务架构选择广泛范围内的任何技术。</p><ul><li>具象状态传输 (REST)<br>具象状态传输（REST，英文：Representational State Transfer）是Roy Thomas Fielding博士于2000年在他的博士论文中提出来的一种万维网软件架构风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息。<br>目前在三种主流的Web服务实现方案中，因为REST模式与复杂的SOAP和XML-RPC相比更加简洁，越来越多的web服务开始采用REST风格设计和实现。例如，Amazon.com提供接近REST风格的Web服务运行图书查询；雅虎提供的Web服务也是REST风格的。<br>这个后期会将互联网WEB架构单独开篇讲解。</li></ul><h3 id="松散耦合"><a href="#松散耦合" class="headerlink" title="松散耦合"></a>松散耦合</h3><p>松散耦合对基于微服务的系统至关重要。每个微服务都必须采用使其与其他服务的关联很小的方式来设计接口。这样，在更改一个服务并部署它时，就无需更改和重新部署系统的其他部分。（完全可独立运行的最小服务组件）</p><p>为了避免服务之间的耦合，必须了解导致紧密耦合的原因。紧密耦合的一个原因是通过 API 公开服务的内部实现。这种公开方式将服务的使用者与它的内部实现绑定在一起，从而导致更高的耦合度。在这种情况下，如果更改微服务的内部架构，可能还需要更改服务的使用者，否则就会破坏使用者。这可能会增加更改的成本，给实现更改带来潜在隐患，进而增加服务中的技术债务。必须避免任何导致公开服务的内部实现的方法，以确保微服务之间松散耦合。</p><p>另一个错误是让服务的 API 太过精细。如果 API 太过精细，服务之间的调用可能变得太过频繁，也就是说，会通过网络执行更多的调用。除了前缀的性能问题，过度频繁的通信还可能造成紧密耦合。因此，设计服务接口的方式必须能够最大限度地减少网络中执行的来回调用。</p><p>必须避免一个服务内的实现过于分散，方法是将表示业务实体的相关属性、行为放在尽可能相近的地方。将相关属性放在一个微服务中；如果更改某个属性或行为，可以在一个位置更改它并快速部署该更改。否则，必须在不同部分中执行更改，然后同时一起部署这些散乱的部分；这会导致这些部门之间紧密耦合。</p><p>每个微服务必须有自己的源代码管理存储，以及用于构建和部署的交付管道。这样即可在必要时部署每个服务，而不需要与其他服务的所有者进行协调。如果您有两个服务，而且始终在一次部署中一起发布这两个服务，这可能表明两个服务最好合并为一个服务，而且必须对当前服务执行更多分解工作。松散耦合还支持更频繁、更快速的部署，最终提高应用程序对其用户需求的响应能力。</p><h3 id="实现容易观察"><a href="#实现容易观察" class="headerlink" title="实现容易观察"></a>实现容易观察</h3><p>微服务架构要求您能够可视化系统中所有服务的健康状态，以及它们之间的连接。这使您能快速找到并响应可能发生的问题。实现可视化的工具包含一种全面的日志机制，能够记录日志，存储日志，并使日志容易搜索，以便执行更有效的分析。</p><p>向系统中配置和添加的新服务越多，让这些服务变得可观察就会越难。因为在添加更多动态部分时，微服务架构会增加复杂性，所以观察设计必须明确，使可视化的日志和监视数据能为分析提供有帮助的信息。</p><h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><p>自动化是有效设计和实现软件应用程序的一个重要要求。对于微服务，自动化是一个至关重要但又充满挑战的任务。除了需要在生产中运行系统之外，微服务架构还向系统的实现引入了更多复杂性。在处理的机器和组件数量较少时，可能可以接受手动配置机器，安装中间件，部署组件，或者手动登录到服务器并收集日志，以及执行其他手动任务。但是，当组件数量增加时，在某个时刻后，您可能无法使用手动方法。</p><p>自动化可帮助组建一个服务器并安装必要的运行时环境。然后，只需使用几行代码，就能快速将微服务放在这些运行时环境上。这种自动化使您能编写微结构代码，访问用于部署生产服务的准确的工具链，从而及早发现问题。自动化是连续集成和连续交付方法的核心推动力量。如果您想将微服务架构的复杂性保持在控制范围内，推崇自动化文化是关键。为此，您需要一种综合的、端到端的方法，以便在整个软件开发生命周期中推广自动化。这个生命周期涉及通过一些操作执行测试驱动开发，比如 IBM Bluemix® Garage Method。有关更多信息，请访问网站。<br><a href="https://www.ibm.com/cloud/garage/" target="_blank" rel="noopener">https://www.ibm.com/cloud/garage/</a></p><h3 id="有界上下文"><a href="#有界上下文" class="headerlink" title="有界上下文"></a>有界上下文</h3><p>开发模型时，请记住识别它的有界上下文，即模型的有效范围。有界上下文是具有明确边界的模型，模型在该边界内是没有歧义的。如果您不在模型周围设置一条边界，最终使用的上下文可能不在您的应用程序内。适合应用程序的某个部分的上下文不得适合另一个部分，即使它们具有相同的名称，而且指向相同的实体。例如，如果您构建一个预约系统，则必须知道客户的基本信息。但是，如果您在账单上下文中有一个账单系统，您可能希望在其中包含客户的联系信息和支付信息，而在预约系统上下文中，不需要该信息。如果您尝试在多个地方重用完全相同的客户模型，可能会在系统中导致不一致的行为。这是一个放入预约系统的上下文中的简单模型，包含一些除客户名称外的行为。</p><p>例如，您可能决定在客户模型上包含某种形式的验证，以确保拥有足够的信息来向他们收账。如果您不够小心，验证可能意外地阻止您使用客户模型安排预约；这不是那您想要的行为。账单系统可能要求客户拥有有效的信用卡，然后才能保存更改。但是，如果缺少信用卡信息，则会阻止您将客户预约信息保存到预约系统中，这是不合理的。</p><p>在这个示例中，您有两个上下文，但它们之间的边界是模糊和重叠的。Eric Evans 在他撰写的图书《领域驱动设计》中说道”模型仅在特定的上下文内有效。因此，最好显式定义应用该模型的上下文。您可以避免损坏该上下文内的模型，将它严格保持在这些边界内，并避免被外部问题分心或混淆。”</p><p>当显示定义了有界上下文后，通常能看到您是否拥有一个尝试扩展到多个上下文中的模型元素。在这个示例中，您希望在预约系统中保持简单的客户视图，而在账单上下文中提供包含联系信息和账单信息的更完整的客户视图版本。在两个不同的类中定义客户的这两个视图，然后将它们放在不同的应用程序中。Eric Evans 建议，通过为每个上下文提供它们自己的团队、代码库、数据库模式和交付管道，让有界上下文保持分离。</p><p>有界上下文的原则在微服务架构中至关重要。可使用这些原则作为指导，正确地确定系统并将其分解为微服务。明确定义有界上下文（意味着业务领域是通过显式边界分离的），有助于推断系统中最终包含的微服务。拥有有界上下文，还有助于正式化不同服务之间的交互，有效且高效地构建它们之间的接口。</p><p>1.通过服务实现组件化<br>传统实现组件的方式是通过库（library），传统组件是和应用一起运行在进程中，组件的局部变化意味着整个应用的重新部署。 通过服务来实现组件，意味着将应用拆散为一系列的服务运行在不同的进程中，那么单一服务的局部变化只需重新部署对应的服务进程。 另外将服务作为组件可以更明确的定义出组件的边界，因为服务之间的调用是跨进程的，清晰的边界和职责定义是设计时必须考虑的。</p><p>即单一服务可以作为一个单独进程存在。</p><p>2.按业务能力来划分服务与组织团队<br><strong>康威定律（Conway’s law）</strong>指出：</p><p>organizations which design systems … are constrained to produce designs which are copies of the communication structures of these organizations.<br>任何设计系统的组织，最终产生的设计等同于组织之内、之间的沟通结构。</p><p>传统开发方式中，我们将工程师按技能专长分层为前端层、中间层、数据层，前端对应的角色为UI、页面构建师等，中间层对应的角色为服务端业务开发工程师，数据层对应着DBA等角色。<strong>事实上传统应用设计架构的分层结构正反应了不同角色的沟通结构</strong>。 而微服务架构的开发模式不同于传统方式，它将应用按业务能力来划分为不同的服务，每个服务都要求在对应业务领域的全栈（从前端到后端）软件实现，从界面到数据存储到外部沟通协作等等。因此团队的组织是跨功能的，包含实现业务所需的全面的技能。 </p><p>近年兴起的全栈工程师正是因为架构和开发模式的转变而出现，当然具备全栈的工程师其实很少，但将不同领域的工程师组织为一个全栈的团队就容易的多。</p><p>3.服务即产品<br>传统的应用开发都是基于项目模式的，开发团队根据一堆功能列表开发出一个软件应用并交付给客户后，该软件应用就进入维护模式，由另一个维护团队负责，开发团队的职责结束。 而微服务架构的倡导者提议避免采用这种项目模式，更倾向于让<strong>开发团队负责整个产品的全部生命周期</strong>。Amazon 对此提出了一个观点：</p><p>You buidl it, you run it.<br>开发团队对软件在生产环境的运行负全部责任，让服务的开发者与服务的使用者（客户）形成每天的交流反馈，来自直接客户端的反馈有助于开发者提升服务的质量。</p><p>4.智能终端与哑管道<br><strong>微服务架构抛弃了 ESB 过度复杂的业务规则编排、消息路由等（即去ESB化）。</strong> 服务作为智能终端，所有的业务智能逻辑在服务内部处理，而服务间的通信尽可能的轻量化，不添加任何额外的业务规则。</p><p>5.去中心统一化<br>传统应用中倾向采用统一的技术平台或产品来解决所有问题。 不是每个问题都是钉子，也不是每个解决方案都是一个锤子。 <strong>问题有其具体性，解决方案也应有其针对性。</strong> 用最适合的技术方案去解决具体的问题，在大一统的传统应用中其实很难做到，而微服务的架构意味着，你可以针对不同的业务服务特征选择不同的技术平台或产品，有针对性的解决具体的业务问题。</p><p>6.基础设施自动化<br><strong>单一进程的传统应用被拆分为一系列的多进程服务后，意味着开发、调试、测试、集成、监控和发布的复杂度都会相应增大。</strong> 必须要有合适的自动化基础设施来支持微服务架构模式，否则开发、运维成本将大大增加（硬件水平跟上软件速度）。</p><p>7.Design for failure<br>正因为将服务独立在不同的进程中后，引入了额外的失败因素。 任何时刻对服务的调用都可能因为服务方不可用导致失败，这就要求服务的消费方需要优雅的处理此类错误。 这其实是相对传统应用开发方式的一个缺点，不过随着一些开源服务化框架的出现，对业务开发人员而言适当的屏蔽了类似的错误处理，不过开发人员依然需要知道对服务的调用是完全不同于进程内的方法或函数调用的。</p><p>8.进化设计<br>一旦采用了微服务架构模式，那么在服务需要变更时我们要特别小心，服务提供者的变更可能引发服务消费者的兼容性破坏，时刻谨记保持服务契约（接口）的兼容性。 对于解耦服务消费方和服务提供方，伯斯塔尔法则（Postel’s law）特别适用：</p><p>Be conservative in what you send, be liberal in what you accept.<br>发送时要保守，接收时要开放。<br>按照<strong>伯斯塔尔法则</strong>的思想来设计实现服务调用时，发送的数据要更保守，意味着最小化的传送必要的信息，接收时更开放意味着要最大限度的容忍信息的兼容性。 多余的信息不认识可以忽略，而不应该拒绝或抛出错误。</p><h3 id="微服务架构应用"><a href="#微服务架构应用" class="headerlink" title="微服务架构应用"></a>微服务架构应用</h3><p>采用微服务架构面临的第一个问题就是如何将一个单一应用拆分为多个服务。 有一个一般的原则是，单一服务提供的功能是可以独立被替换和升级的。 也就是说如果有 A 和 B 两个功能，如果 A 功能发生变化时同时 B 功能也需要变化，那么 A 和 B 这两个功能应该被划在一个服务中。</p><p>微服务架构应用的成功经验近年已越来越多，例如国外的 Amazon，Netflix，国内如阿里都采用微服务架构取得了很多正面的成功案例。 但通过上文所述微服务架构特征看出，其实微服务架构模式有利有弊，需要根据实际的业务、团队、环境进行仔细权衡利弊。 其中的服务拆分带来的额外开发、测试、运维、监控的复杂度，在现有的环境、团队下是否能够很好的支持。</p><p>另外，有人可能会说，我一开始不采用微服务架构方式，而是在单一进程内基于清晰定义的模块化方式，模块之间通过接口调用，到了适当阶段，必要的时候再将模块拆分为服务。 其实这个想法显得过于理想，因为进程内良好定义的接口通常不是很好的服务化接口。 一开始没有考虑服务化的设计方法，那么后期拆分时依然是一个痛苦的过程（改整体架构对一个已成型的产品来说比开发一个新产品还要吃力）。</p><p><strong>难在架构，也赢在架构！</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>正如，Martin Fowler 在其文中所说，微服务架构是否就是企业应用开发的未来，还有待时间的检验。 就目前的情况看，对此我们可以保持谨慎的乐观，这条路依然值得去探索。 实际任何的架构决策都是基于我们不完美的现状做出的，这正是架构取舍的微妙之处，超越任何的方法论。</p><p>在整体式应用程序中，大部分逻辑都部署在一个集中化、单一的运行时环境或服务器中，并在其中运行。整体式应用程序通常很大，由一个大型团队或多个团队构建。采用此方法，各个团队需要花更多精力和统筹安排才能执行更改或部署。</p><p>随着时间的推移，整体式模型中已引入了更好的架构模式，有助于显著提高架构的灵活性。例如，一种著名的模式是模型-视图-控制器 (MVC)，它将应用程序分解为层和合理的组件。这些模式有多种优点，比如更快的初始开发、更简单的应用程序治理，等等。但是，整体式模型也有缺点，尤其是在当今环境中的技术瞬息万变的背景下。（MVC【模型-视图-控制结构的整体式模型】已经不满足当前网络开发的情况了）</p><p>整体式方法可能带来许多挑战，有以下四点：</p><ul><li>庞大的应用程序代码库</li><li><p>庞大的代码库可能给希望熟悉代码的开发人员带来困扰，尤其是团队的新成员。庞大的应用程序代码库可能还会让应用程序开发过程中使用的开发环境工具和运行时容器不堪重负。最终，这会导致开发人员效率降低，可能会阻止对执行更改的尝试。<br>开发人员在进入这个项目业务时，因为是整体式的架构项目，开发人员可能负责的是整个控制层，业务层或者持久层的逻辑，虽然各层的处理逻辑和分类管理做的好的项目容易看得懂，但是各层的代码库随着产品的深入会加上各种功能，导致代码库庞大且凌乱，这就是导致了开发人员的工作重点不是在有效的开发上而是在找代码甚至是理清他们的关系上，开发效率低下也导致无用功过多，也会使开发人员的情绪受到影响。</p></li><li><p>不频繁的更新</p></li><li><p>在典型的整体式应用程序中，大部分（几乎是全部）逻辑组件都部署在单一运行时容器中，并在其中运行。这意味着要更新对某个组件的一处细微更改，必须重新部署整个应用程序。另外，如果需要推广细微但关键的应用程序更改，则需要投入大量精力来对未更改的部分运行回归测试。这些挑战意味着整体式应用程序很难连续交付，这导致部署次数减少，对需要的更改的响应变慢。<br>利用微服务架构后若出现问题则可以单个组件更新部署，不需要整个项目进行维护升级。</p></li><li><p>依赖单一类型的技术</p></li><li><p>对于整体式模型，由于应用更改方面的挑战，以增量方式采用新技术或技术栈开发框架的新版本会变得很困难。最终，整体式架构应用程序通常必须一直使用这一种技术，这最终会阻碍应用程序跟上新的发展趋势。<br>微服务架构利用各项技术优势互补，哪个效率高用哪个。新技术增加的功能可以直接部署在系统上，各组件的技术也可以用不同的语言来实现。<br>甚至是为整个项目整体更换新框架时也会变得容易。</p></li><li><p>可扩展性</p></li></ul><p>可扩展性是整体式架构面临的最大挑战之一。Martin Abbot 和 Michael Fisher 在他们合著图书《可扩展的艺术》中介绍了一种查看系统的可扩展性的有用方式；他们使用了一种三维可扩展性模型或扩展立方体。在此模型中，通过在负载平衡器后运行克隆版本来扩展应用程序称为 X 轴扩展或水平复制。另外两种扩展是 Y 轴扩展（或功能分解）和 Z 轴扩展（或数据分割），Y 轴扩展通过拆分不同实体来实现扩展，Z 轴扩展通过拆分类似实体来实现扩展。由于整体上的凝聚性，典型的整体式应用程序通常只能在扩展立方体的一个维度上扩展。随着生产环境收到更多请求，该应用程序通常采用的垂直扩展方式是添加更多资源供其使用，或者克隆到多个副本来进行响应。这种扩展方式低效且很耗资源。<br>当应用程序达到一定规模时，开发团队必须拆分为更小的团队，每个小团队专注于一个特定的功能区域，各团队彼此独立工作，而且通常位于不同地理位置。但是，由于应用程序的各部分间的自然凝聚性，需要各个团队协力执行更改和重新部署。</p><p><img src="/2018/03/20/分布式01/image001.png" alt="logo"></p><p>使用微服务架构的最重要目的是，解决整体式模型面临的难题。<br>将从应用程序的不同涉众角度，介绍微服务方法如何帮助解决整体式系统的问题。</p><ul><li>对于业务所有者</li></ul><p>作为业务所有者，您希望您的服务适用于新客户和业务需求。但是，在整体式模型中，由于庞大的代码库，为满足业务需求而执行并推广更改的过程会很缓慢。这个过程缓慢的另一个原因是，各个组件和层之间有严格的内部限制和依赖关系。</p><p>依靠传统框架来将各个层和组件整合起来，这样的话各层的关系不仅会受到整体框架的限制，还会让开发周期变得很长。</p><p>微服务架构原则是围绕高灵活性和恢复能力而建立的。这两个特征有助于快速推广更改。这有助于业务所有者更快地收到反馈，调整业务和投资战略，从而让客户满意和提高市场竞争力。</p><p>从资源分配的角度讲，由于团队更小且更专注，所以可以更轻松地测量和可视化效率。然后，业务所有者可以更轻松地制定投资决策，可将资源从低业务影响区域转移到高业务影响区域。</p><ul><li>对于服务管理人员</li></ul><p>作为服务管理团队成员，您希望协调各个团队的管理操作负担更少，以便您可以提高服务的生产力。整体式模型需要做大量的工作。活动之间需要的协调更多，因为整体式应用程序通常拥有庞大的业务范围，以及许多基础架构和操作接触点。因此，对应用程序的每次更改都可能需要不同涉众多次评审和批准。微服务架构推崇利用自助服务，在服务交付管道的每个阶段利用<strong>自动化</strong>。</p><p>这有助于减少服务管理团队的日常管理协调。</p><p>微服务架构中的一个重要原则是高可观察性。高可观察性功能为服务管理团队提供了必要的工具，以便更好地监督系统中或产品中的每个微服务的状态。这有助于提高服务管理效率。</p><ul><li>对于开发人员</li></ul><p>作为加入团队的新开发人员，您希望快速熟悉源代码，以便快速上手并带来成果。<strong>典型整体式应用程序中的代码库很大，可能阻碍您并潜在地延长学习曲线</strong>。对于所有开发人员，庞大的代码库会增加载入开发环境中并运行的负担，从而导致生产力降低。</p><p>庞大的代码库可能让代码评审和其他合作开发活动面临更大压力。此外，在处理更改时，破坏其他功能的风险可能导致开发人员对创新和增强应用程序犹豫不决。然而，微服务更小且更轻量，这可以缩短新开发人员的学习曲线。微服务还可以帮助消除加载和运行的繁重负担，鼓励引入突破性的更改，从而帮助提高生产力和创新水平。</p><p>———————————————更新线—————————————————</p><h3 id="云时代"><a href="#云时代" class="headerlink" title="云时代"></a>云时代</h3><p>为什么现在是采用微服务架构的好时机。</p><ul><li>云环境和产品的激增</li></ul><p>微服务架构体现了使用连续集成和连续部署的许多优势。该架构也引入了新的复杂性，需要一种在构建应用程序的每个步骤中实施自动化的现代方法。例如，从基础架构和治理的角度讲，首先需要一个能动态地快速为服务组建运行时环境的业务连续性基础架构。该环境可能是一个虚拟机、容器等。另外，还需要一种统筹安排和监视服务的高效方式。当今环境中的云平台（比如 IBM Bluemix）可通过其自然的动态性和恢复能力满足此需求。<br>借助可用于各种服务模型的不同云产品，无论是基础架构即服务 (IaaS) 还是平台即服务 (PaaS)，开发人员都可以通过更多选择转变为微服务战略。借助 IaaS 选项，您可以在几分钟内快速组建一台机器，而且可以将基础架构配置打包到一组脚本中，以便根据需要自动化该流程。如果您不想接触基础架构级别的复杂性，也可采用平台级选项，采用不同的语言和服务的形式来快速打包，然后根据意愿包含和启动微服务。<br>IBM Bluemix 是这些平台的一个示例。IBM Bluemix 有许多适合使用云技术构建微服务的服务，比如 IBM 容器、消息中心、日志记录、监视和其他技术。Bluemix 使开发人员能够快速创建、部署和管理他们的云应用程序，为简化操作、确定安全策略和管理系统中微服务的健康提供关键基础。</p><ul><li>工具的可用性和成熟性</li></ul><p>除了云基础架构可为微服务战略的采用所提供的动态性和恢复能力，拥有全面的工具也是采用微服务战略的关键需求。微服务工具在不断演变和进步。在当今环境中，开发人员有许多选择，他们可以使用一组合适的工具来实施其微服务战略，比如日志工具组合、监视工具组合、服务注册表或容器化技术。这些先进工具可帮助解决微服务架构所引入的挑战，以便更有效地交付、管理和统筹安排服务。<br>图展示了基于微服务架构而构建的 IBM Watson™ 云服务的完整组合示例。这种革命性架构有云技术、一组全面的工具及敏捷流程提供支持。</p><p><img src="/2018/03/20/分布式01/image002.png" alt="logo"></p><p>该架构包含多个主要的技术组合：<br>DevOps<br>每个 Watson 云服务在开发后，都会在一个不可变的虚拟机中容器化，然后通过明显的 DevOps 流程自动部署到 IBM SoftLayer 云基础架构上。微服务架构的典型模式（比如服务发现、API 网关等）是通过 IBM 独有的和开源的技术来使用的。然后，可以在 IBM Bluemix 平台上公开这些服务。<br>Elasticsearch、Logstash、Kibana (ELK) 组合或 Elastic 组合<br>Elk 组合是该系统的日志工具组合，包含一组工具来捕获日志，并将其存储在一个强大的、集中化的、可搜索的日志数据库中。有关更多信息，请查阅 elastic 网站。<br>监视工具组合<br>展示了一组工具，它们可从一个中央仪表板监视整个系统，包含一种通知机制，以便基于特定事件来发送提醒。</p><h2 id="从整体式应用程序向微服务的转变"><a href="#从整体式应用程序向微服务的转变" class="headerlink" title="从整体式应用程序向微服务的转变"></a>从整体式应用程序向微服务的转变</h2><ul><li>虚构公司 A 的业务问题</li><li>虚构公司 A 是一家电子商务公司，它使用了一个名为 Customer Order Service 的基于 Java EE 的传统 Web 应用程序来提供在线购买服务和运营业务。尽管该应用程序能很好地处理业务，但公司 A 已开始努力响应新的业务需求。这些需求包括：</li></ul><p>接触使用移动设备的客户<br>基于对客户在互联网上的个人行为的洞察，改善客户体验<br>扩展基础架构，以便处理来自新客户和现有客户的更多请求保持较低的 IT 成本<br>以及其他需求<br>目前的客户订购服务应用程序的设计不支持在业务领域中执行更改，而且无法应用新技术来加速创新。图中介绍了当前的整体式应用程序的逻辑架构概述。</p><p><img src="/2018/03/20/分布式01/image003.png" alt="logo"></p><p>公司 A 希望改变客户订单服务应用程序，以便从业务和技术角度促进和更好地处理更改，它拥有一些主要的业务需求：</p><p>新系统必须是经过进化的，意味着它必须能灵活地处理更改。<br>在将流量从当前系统转移到新构建的系统的过程中，不允许宕机。<br>新应用程序必须能基于发送给系统的有效负载来按需或自动扩展，以便应对动态的购物行为模式。<br>新系统必须支持利用新兴技术来促进创新。</p><p>采用微服务来实现一种革命性架构：</p><p>采用微服务架构的主要动机是，解决很难更改的传统整体式架构的问题。微服务方法支持对架构的每个组成部分执行更改。对于业务需求，公司 A 非常适合在构建新系统时采用微服务架构。</p><p>公司 A 应用最佳实践和模式将现有的整体式应用程序转变为更加革命性的架构，以期最终将应用程序迁移到微服务架构上。<br>执行以下主要步骤和活动：</p><ul><li>演化战略<br>要拥有一种转型案例分析中的整体式应用程序的合适战略，必须发现和考虑不同的模式和建议实践。</li></ul><p>识别要转变为微服务的候选功能<br>在这一步中，选择应用程序的相对较小的组件或功能片段。从这些功能片段，可配置新微服务来让这些片段更有利于经常或渐进式的更改。</p><ul><li><p>数据访问模式<br>因为数据是 IT 系统中最重要的资产，所以一个关键步骤是在转变为微服务架构的过程中采取正确的数据访问方法。</p></li><li><p>安全和治理<br>“安全和治理”将介绍如何在更加分布式的新模型中管理应用程序的组件，以及如何处理安全挑战。</p></li><li><p>性能和可扩展性<br>解决整体式应用程序的可扩展性问题时，微服务架构（拥有更多分布式特征）带来了性能挑战。</p></li><li><p>DevOps 和自动化<br>自动化是让微服务方法成为可能的推动因素。</p></li></ul><p>重点介绍了微服务的重要概念、特征以及它为何对现代软件应用程序的开发如此有吸引力的原因。最后，通过一个示例简单的描述了从整体应用程序向微服务的转变。目前为止，相信您已经对微服务有一个初步的了解。下一部分将更深入的介绍如何在 Java 中创建微服务。</p><p>内容转自 Evolve the Monolith to Microservices with Java and Node （IBM产品devoloper开发红皮书）</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;微服务是什么？&quot;&gt;&lt;a href=&quot;#微服务是什么？&quot; class=&quot;headerlink&quot; title=&quot;微服务是什么？&quot;&gt;&lt;/a&gt;微服务是什么？&lt;/h1&gt;&lt;p&gt;谈及微服务架构，2016年应该是软件业微服务爆发的元年，微服务到底是什么？&lt;br&gt;观察现有的软件业，使用单独一款开发语言区开发一款较为全面的产品很少，大多数都是各种语言编写的功能模块进行组装成完整的业务模型，&lt;br&gt;各语言效率优势互补。&lt;br&gt;微服务架构所强调的特点就是业务系统需要彻底的组件化与模块分割，原有的单个业务系统分割成多个小应用，每个小应用可以进行独立开发，管理，运行和测试，甚至连每个产品的前端（UI加结构），服务端（控制层，逻辑层和持久化层），数据库都是完全独立的产品，通过微服务架构将每个小应用进行整合，交互与集成，每个小应用不仅能够自己完全独立的功能，还可以运行其他小应用的服务，同时也将自己作为可供利用的服务对象。&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="Dubbo" scheme="http://yoursite.com/tags/Dubbo/"/>
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>创业之路--关于风险投资</title>
    <link href="http://yoursite.com/2018/03/19/fengtou/"/>
    <id>http://yoursite.com/2018/03/19/fengtou/</id>
    <published>2018-03-19T04:39:15.000Z</published>
    <updated>2018-03-19T04:54:02.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于风投泄密及其保密协议"><a href="#关于风投泄密及其保密协议" class="headerlink" title="关于风投泄密及其保密协议"></a>关于风投泄密及其保密协议</h1><p>保密协议就属于防君子不防小人,特别是在商业模式、概念以及技术在早期还很不具象的时候(这恰恰都是初创公司所面临的情况),保密协议起到的作用就更小,因为连保护的标的都不清楚,总不能说保护一个头脑中的idea吧?即使起到作用,通过法律手段花上无数的时间和精力去索赔并成功,损失的时间和精力放在自己的梦想和创业上,是不是会更加划算?天使投资人最大的价值就是,给钱不捣乱,同时需要的时候提供不太计较的支持.</p><a id="more"></a><p>所以题主关心的方向不对,应该更关注如何找到靠谱的天使投资人,而不是在这种ROI极低的地方选择如何去保护自己的利益。如同找老公过日子,越是天使投资越容易走得远成为长期的婚姻关系,关注点更多在于如何选对人,而不是如何利用拉链守住门户.</p><p>而且还有一个基本原则,如果在天使阶段,一个潜在投资人对于你的技术绌节和实现方式如此关注,而对于创始人的人品以及公司的远景却不那么在乎。是不是有点熟悉的感觉,上来就问你的银行存折、小区档次等等?</p><p>保密协议的注意事项1、保密信息的范围从披露方来看，只要是自己提供给对方的非公知信息，都可以纳入保密信息的范围，包括关于自身的保密信息，也包括自己获准披露的第三方保密信息。另一方面，也不能范围过宽延伸到接受信息方已有或者自行开发的信息以及无关第三方披露等原因造成公开的信息，尤其是保密期限比较长的时候，接受信息方也可能因为各种现实原因无法承受过重的保密限制。</p><p>2、商业秘密上文提过，并非所有的保密信息都能构成商业秘密，商业秘密的保护须权利人采取保密措施，例如：技术措施以及要求接触到商业秘密的员工签署保密协议的法律措施等。商业秘密和普通的保密信息需要区分开来。针对保密信息双方可以商定一个有限的持续时间（很多信息因为技术发展几年后就根本没有保密的意义了），期间届满后则不再负有保密义务；但商业秘密则不能轻易地披露给对方，披露给对方也要注意保密措施，并且不受保密期限的限制。</p><p>3、知识产权专利等知识产权与商业秘密的保护方式各有利弊，此处不再展开。有些创意、方法和流程可能无法获得知识产权的保护，所以只能作为商业秘密并通过保密协议等方式防止保密信息进入公知领域。即便是能够申请专利的技术或方案，也需要在申请专利前注意保密，并与接触者签署保密协议，防止被公众所知破坏其新颖性，导致无法申请专利。</p><p>4、保密信息的使用限制保密协议不仅仅限制信息接受方不得对外披露保密信息，而且需要限制信息接受方对保密信息的使用范围和目的。一方面，信息接受方应当仅限于向项目合作过程中确需了解保密信息的人群披露，还要限制信息接受方使用于讨论、评估或依据各方协议约定实施项目合作之外的目的，<br>例如：不得因项目之外的目的擅自使用保密信息。此外，如果披露具有知识产权的内容则需要明确，依据保密协议进行的披露与知识产权的许可使用不同，为签约各方项目合作之目的披露给对方，并不意味着给予了对方知识产权的使用许可。结语保密协议仅仅是保护公司保密信息的一种常见手段，创业公司还需要提高保密意识，并结合技术手段以及知识产权等各种方式，更全面地保护自己来之不易的创造性成果。<br>如果运用得当，即便是创业公司也能有效对抗巨头“友商”窃取自己的劳动果实。</p><p>在《要求投资人签署保密协议 能否保护你的商业秘密》这篇文章中，我曾经表示，通过要求投资人签署保密协议的方式，不能从根本上保护自己的商业秘密。<br>那创业者在融资时，还需要与投资人签署保密协议吗？<br>答案是肯定的。也就是说，保密协议还是要签的。<br>既然它不能从根本上解决问题，那在这里为什么还要建议创业者与投资人签署保密协议呢？<br>因为尽管它不能从根本上解决问题，但毕竟能起一定的作用。而对有些投资人，这点作用就已经足够。<br>不同的投资人，愿意承担的违约风险不同。如果对方可以承受的违约风险幅度很大，那单靠一纸保密协议，不能引起他们足够重视，自然也约束不住他们。这时候，就要附加其他手段。但如果对方可以承受的违约风险幅度很小，那这一纸保密协议就能很好的约束对方。<br>同一份协议，在不同的投资人眼里分量不同，自然对其影响和制约能力也不同。<br>在《周永信说融资泄密17：Term Sheet前投资人不愿签署保密协议的原因及例外》这篇文章中，我也曾提到，投资人是不愿意签署保密协议的，但那指的是在Term Sheet之前。<br>真正到了谈判Term Sheet阶段，甚至尽职调查阶段，投资人是不会拒绝签署保密协议的。因为这是一种合理且常规的要求。到了这一阶段，如果创业者还不要求签署保密协议，投资人甚至会认为创业者不够成熟。因为保密意识是企业成功的必要要素之一，没有投资人愿意投资一个保密意识淡薄的创业者。<br>所以不管是为了保护自己，还是为了取信于投资人，创业者都要要求投资人签署保密协议。只是，要掌握好时间点。</p><p>那么，投资人看重的是什么？<br>第一，商业案思路清晰，市场回报设计方案路径清楚，言之成理，<br>第二，最最重要的：执行团队。换句话说，绝大多数投资人看重的，不是案子，而是能把案子做成买卖的创业团队！所以，千万别想着拿几张天马行空的A4纸去打动别人把几千万给你，他们看都不会看，即便里面写了九阴真经。但如果这纸上的方案，你已经建立起了自己稳定的核心团队，而且靠这个团队已经在小规模范围内取得了一定的商业成功，现在是需要资金扩大规模，那么，加上你的好点子，投资人对你是有兴趣的。</p><p>是否需要签订保密协议,主要还是要具体评估下题主展示或向对方提供的内容是什么。<br>如果是机变的数据资料或者一些数据模型等,付出大量的人力、物力的智力成果,可以达到商业秘密了<br>众所知悉、能芾来经济利益,具有实用性并采取保密措施的技术信息和经营信息)<br>还是非常有必要签署保密协议的。虽然有人说保密协议是防君子不防小人,但有保密协议在,毕竟会对一部分投资人产生威慑,而且后续如果有纠纷,诉诸司法,保密协议毕竟要求对方承担的一个法律文件和基础<br>如果只是一些创意或电子,毕竟法律不保护创意,签与不签,并无实质性区别。</p><h1 id="家装风投"><a href="#家装风投" class="headerlink" title="家装风投"></a>家装风投</h1><p>经纬中国，合力投资，红杉资本，IDG资本，沸点资本，创湃资本，稳国基金，创吧投资，58集团，梧桐树资本，红星美凯龙，北辰星，<br>天使湾，印尼力保集团，华耀资本，氪空间，中骏基金等等</p><p>基本涵盖种子轮，天使轮，Pre-A轮，A轮，B轮，C轮，C+轮以后，。。。，F轮，上市前。</p><p>天使投资人需要做进一步的网络爬虫</p><p>不局限于拿国内资本投资，可考虑境外投资或者联合投资形式</p><p>A+轮后可考虑资本市场，多家融资</p><p> VC风险投资(venture capital)</p><h1 id="轮次融资"><a href="#轮次融资" class="headerlink" title="轮次融资"></a>轮次融资</h1><p>同时也是解读资本与企业发展之间关系的学问。</p><h1 id="种子轮"><a href="#种子轮" class="headerlink" title="种子轮"></a>种子轮</h1><p>种子投资极具风险，大多数种子投资者明白70%的初创企业投资最终都会失败。但是，他们也明白，只需一个成功的初创企业，便可带来大量的财富。因此，种子投资者明白，在寻找成功企业的过程中，他们需要与企业“风险共担”，更重要的是，要避免“FOMO”的陷阱，即“错过”下一个取得巨大成功的初创企业[2]  。<br>由于更多的种子投资者承担更多的风险，因此早期的种子融资变得更加普遍、丰富，也更容易获得。尤其在许多初创企业明白快速进入市场的重要性之后，种子融资的易得性和不断增长的资金池对初创企业来说无疑是好消息。具有讽刺意味的是，这种发展也给初创企业带来了严重的问题。<br>种子融资后，会对初创企业创始人进行早期的估值、收入和客户标准检查，并规定达成业绩的严格时限。如果初创企业过早进入种子融资，在接下来的轮次融资阶段，如A轮融资时，则会遇到严重的挑战。轮次融资通常更加重要和复杂，因此如不能满足标准，会给接下来的投资人带来强烈的负面信息。</p><p>在融资中，这一般被称之为“种子轮”投资，它是指公司发展的一个阶段。在这个阶段，公司只有创意却没有具体的产品或服务，创业者只拥有一项技术上的新发明、新设想以及对未来企业的一个蓝图，缺乏初始资金投入。创业者在这一阶段寻找投资的时候，最需要的讲清楚的是“我要做什么”，重要的是要给投资人画好你想象中的“大饼”。<br>一般来讲，因为前期资金需求相对较小，也或许是创业者大都抱有“先做出一点成绩或者先做出个样子”的想法，种子期的所需要的资金都是创业者自筹或者通过亲朋好友来筹集。当然，也有种子期投资人和投资机构。<br>注意，种子期的投资资金一般在10万-100万RMB左右。当然，也有破例。比如，最近VR比较火，森声科技在3月就宣布获得了数百万元的天使投资。森声科技想做的是，基于双耳录音(Binaural recording)技术，为广大 VR 影视团队提供一套简便的全景声录制和播放解决方案。</p><p>种子期的项目，往往只有一个idea和初始团队（有些只有一两个创始人），idea能不能转换为一个make sense的business，具有高度的不确定性，需要通过一段时间的尝试，对idea背后的各种假设进行验证，从而探索到真正可行的方向。在此过程中项目的方向和内容随时有可能面临调整，而且项目一没有历史，二缺乏连续性，唯一稳定的、可供投资者参考的因素就是团队（而且主要是创始人），因此种子期的投资主要看人。人是极其复杂的，要想对一个人作出判断就必须深入了解他、和他打交道。由于这个过程依赖大量的经验和直觉，很难进行理性的分析，因此履行这个任务、做这个决策的，一般都是个人投资者。这也是“天使”这个称号的来历。此外，由于尝试和探索所需的资金量一般不是太多，个人投资者出得起，且项目越早期风险越大，所以天使投资的金额一般也较小，一般都在500万（人民币）以下。</p><p>—————————–<strong>破土期</strong>———————————————————</p><h1 id="天使轮"><a href="#天使轮" class="headerlink" title="天使轮"></a>天使轮</h1><p>天使轮是指公司有了产品初步的模样，商业模式也已初步形成，同时积累了一部分的核心用户。投资来源一般是天使投资人、天使投资机构。相比之后的融资，这个时期想要拿到融资还是相对容易的，投资人主要看的是创业团队和创业方向。<br>对于成熟理性的天使投资机构来说，种子期和天使期项目在阶段上的差别不大，区别最大的就是在融资金额上。因此，也有人会把这种初创公司的融资阶段称为“种子天使”。</p><p>天使轮，即天使投资（Angel Investment），是指个人出资协助具有专门技术或独特概念而缺少自有资金的创业家进行创业，并承担创业中的高风险和享受创业成功后的高收益，或者说是自由投资者或非正式风险投资机构对原创项目构思或小型初创企业进行的一次性的前期投资。天使投资是风险投资的一种特殊形式。</p><p>天使轮的投资资金额度一般在100万RMB到1000万RMB左右。上限为2000万左右。<br>2015年12月，刚刚成立半年多的美国P2P保险公司Lemonade获得红杉资本1300万美元的种子轮投资。Quartz称，这是红杉历史上最大的种子轮投资之一。</p><p>种子、天使轮，顾名思义就是很早期的公司，可能只是一个idea、没有实际的走出去，这个时候VC机构，一般会看创业者的背景、愿景，但最重要的还是个人背景，如果你是一个已经很牛的人，那你的天使轮估值肯定会很高，比如瓜子二手车天使轮就能拿到6000万美元的融资，就是因为杨浩涌以前有过成功创业的经验，即使他做出渣来也会有人投资的。</p><p>天使投资也属于风险投资的范围，只是更为早期，风险更大，同时回报也可能更高。天使投资的来源更广泛，早年最常见的三类天使投资人，3F，family，friend，fool。</p><p>随着越来越多的互联网公司上市，大量掌握大笔资金，熟悉上市流程，和投资机构关系密切，了解行业动向，具有大量人脉的前互联网公司高管们开始成为专业的天使投资人，他们是最合适的天使投资人选，也会有相当多的好项目被他们挖掘获得成长。</p><p>同时，天使机构化的趋势也开始明显，一些新的天使投资开始就以正规军的方式作战，一些以往A轮起投的风险投资机构也开始向天使扩展，所以天使投资和风险投资的界限也开始模糊，天使和VC主要用在界定投资金额的多少，比如通常天使是100-200万人民币，A轮是100-200万美金，B轮是500-1000万美金，等等，但是也并不确定，有人天使就上千万美金了。</p><p>除了资金多少的区别，我通常会按照项目的状态来界定项目的阶段以及投资款的用途。天使阶段，商业模式还没有建立，钱是不够烧的，天使投资的钱更主要用来搭建团队，大量试错，为A轮较大资金进入，具有可复制的商业模式的基础做准备，要能证明后续资金可以高效的使用才值得引进新的投资，也才容易拿到后续的风险投资。（当然，这个市场上充满了反例和个案）</p><p>成长期则似乎没有公认的定义，我个人的理解是当一个项目经历过种子期的摸索，探索到一条有较大可行性的道路时，便进入到成长期。可以说种子期是纸上谈兵，成长期则经过了实践，从市场的反应中看到了希望。企业进入成长期以后，战略基本成型，准备着手投入资源（其中资金是关键资源）去实现这个战略。这个时候投进去的，就可以算作是VC了。所以VC是企业战略初步成型以后用以支撑企业去实施战略的投资。此时企业刚刚在市场上取得一些成绩，或者看到了一些成功的苗头，但企业自身的资源不足以支撑它，需要引进外部的资源。对投资者而言，企业战略所隐含的关键性的假设通过市场已经有所验证，此时可以对项目进行理性的分析，并能够对面临的风险进行相对准确的评估。这就有了机构化投资的基础，也即实际的出资人可以委托专业的投资人士进行操作并对投资人士实施监督，从而在投资领域产生了委托－代理关系；另一方面，这个阶段企业需要的资金量相对比较大，如果由个人投资者投资将很难分散风险，因此投资的机构化也成为必然。因此，VC一般都是以基金的方式实行机构化运作的，投资额一般在千万量级。</p><p>天使的话，我喜欢你，看得起你， 相信你，就可以了。看中的可能只是被投资人的某个闪光点而已。</p><p>天使投资无疑是“单个项目的回报”最高的。早期项目估值低，一旦项目成为了独角兽，百倍千倍的回报完全可以实现。一版情况下项目如果没有5倍、10倍的回报，都不好意思拿出来和同行说。但是对应风险也是非常高的。比如，天使投资人一年投10个项目，其中有9个血本无归，只靠成功的那个项目赚了百倍收益来弥补9个的亏损，这种情况也是时有发生。VC和PE投资随着公司估值不断上升，单个项目的回报倍数越低，相对投资成功的概率会比天使投资高不少。</p><p>所以天使轮也被称为独角兽投资。</p><h1 id="Pre-A轮"><a href="#Pre-A轮" class="headerlink" title="Pre-A轮"></a>Pre-A轮</h1><p>按照正常的融资进程，下一轮的融资应该是是A轮融资。但是，有的公司会增加一轮融资：Pre-A轮。</p><p>Pre的意思是前期，Pre-A就是A轮之前的融资。增加这轮融资的原因是多方面的，创业公司在估值不理想;资金困难，但又没有达到A轮阶段的规模，以上这些情况都有可能。Pre-A可以看作一个缓冲阶段，可以让创业者资金压力缓解，也可以让新的投资人进来。</p><p>———————————<strong>天堑期</strong>—————————————————————–</p><h1 id="A轮"><a href="#A轮" class="headerlink" title="A轮"></a>A轮</h1><p>A轮，其实A轮也是初创公司，很多有资历、有人脉的，通过自己或创始团队搞定了天使轮，真正向VC拿钱的时候是A轮，A轮公司特征是已经有了产品原型，可以拿到市场上面对用户了，但基本还没有收入或者收入很小，类似的公司有小米、平安好医生等，都是有产品了拿到了A轮，但公司还是不盈利；这个时候投资人还是更看重创业者资历背景，但这时候也会看些市场前景，以及公司的愿景了。</p><p>在A轮融资阶段，创业公司的产品已经基本成熟，产品上线或者服务已经正常运作一段时间，并有完整详细的商业及盈利模式。另外，创业公司在行业内拥有一定地位和口碑，但是还处于亏损的状态，有诱人的前景。A轮的投资资金额度一般在1000万RMB到1亿RMB左右。</p><p>2015年12月，58到家宣布与阿里巴巴，平安，KKR完成了A轮融资协议的签署，58到家将以超过10亿美金的估值融资3亿美金。据说，这是互联网史上最巨额的A轮融资。<br>当然，从天使到A轮是很多创业公司很难踏出的一步。在这个时期，是考验创业公司的产品、商业模式、盈利模式和创业团队等各个方面的阶段。如果一个环节出现问题就可能导致一个项目的失败或者说创业失败。</p><h1 id="B轮"><a href="#B轮" class="headerlink" title="B轮"></a>B轮</h1><p>创业公司经过一轮烧钱后，获得了较大发展。甚至一些公司开始盈利，盈利模式趋于完善，可能需要推出新业务、拓展新领域。资金来源一般是大多是上一轮的风险投资机构跟投、新的风投机构加入、私募股权投资机构加入。投资资金额度一般在2亿RMB以上。</p><p>———————————<strong>换血期</strong>————————————————————————</p><h1 id="C轮"><a href="#C轮" class="headerlink" title="C轮"></a>C轮</h1><p>到达C轮融资的时候，创业公司又会遇到一个瓶颈。<br>这时公司已经非常成熟了，离上市不远了。这轮除了拓展新业务，讲讲“生态”，就要开始准备上市了。资金来源主要是私募股权投资，有些之前的VC也会选择跟投，投资资金一般在10亿RMB左右。<br>大部分公司一般C轮后就会上市，但也有公司选择融D轮，甚至更多轮的融资。<br>这些需要更多轮融资的公司大部分是其本身的业务所决定的，有的项目需要大量的烧钱，过早上市就不符合这类公司的发展战略，最为形象的例子就是滴滴了，滴滴由于烧钱补贴，现在已经G轮了，还在融资。</p><h1 id="C-轮–至死亡轮"><a href="#C-轮–至死亡轮" class="headerlink" title="C+轮–至死亡轮"></a>C+轮–至死亡轮</h1><p>简单来说就是无数的资本融入。</p><h1 id="IPO期"><a href="#IPO期" class="headerlink" title="IPO期"></a>IPO期</h1><p>完成以上这些融资阶段后，公司就可以上市了。<br>上市之前第一件事就是IPO。<br>IPO(Initial Public Offerings)即为首次公开募股，是指一家企业或公司 (股份有限公司)第一次将它的股份向公众出售(首次公开发行，指股份公司首次向社会公众公开招股的发行方式)。只有首次公开上市完成后，公司才可以申请到证券交易所或报价系统挂牌交易。IPO需要经过多个环节的严格审核。<br>以上，就是一家公司从创立初到上市的全过程。</p><h1 id="天使投资、VC-以及-PE-的区别是什么？"><a href="#天使投资、VC-以及-PE-的区别是什么？" class="headerlink" title="天使投资、VC 以及 PE 的区别是什么？"></a>天使投资、VC 以及 PE 的区别是什么？</h1><p>VC即风险投资，PE即私募股权</p><p>回答这个问题,需要看一下私募股权基金的发展历史,以及在PE这个大概念里产生的V和 Angel</p><p>私募股权基金,是伴随着上世纪七八十年代的并购潮起来的概念,可以看做一个替代资本市场,为<br>需要资本或者想岀手资产的企业提供类似股票市场和银行信贷功能的一种金融产品</p><p>私募股权基金,最早从事的就是兼并收购,随看市场的变化,老牌的PE基金,比如黑石,KKR<br>在随时调整并改变其投资策略,但是,这些老的PE基金在折腾纳贝斯克,折腾UCAR,折腾轮轴制<br>造公司的时候,他们亻脑子里想的是现金流状况,是持续盈利能力和稳定的偿债能力</p><p>于是,这些老PE和他们所实际控制的传统企业的光芒,被来自硅谷的人和他们背后的资本力量所遮<br>挡了,而VC和天使们的故事,要从1995年4月 Netscape的IPO开始谈起。</p><p>对于黑石和KKR来说,像网景这样 Pre ipo收入只有1600万美元,净亏损430万美元的公司能上市<br>简直就是荒唐的事情,但来自硅谷的另类PE——VC们告诉黑石,新世纪,投资者会对那些用新技<br>术实现高成长的公司充满信心。于是,传统金融领域闻所未闻的IPO大批出现,包括:雅虎<br>Amazon甚至包括 Google。</p><p>买股票,不用看盈利水平,不用看财务报表,来自西海岸的投资者们一次又一次抽打华尔街那些穿<br>看笔挺西装的人们的脸。一个又一个天价的IPO,让华尔街的PE们开始反思传统并购和私募股权融<br>资创造的资本价值是否还有没有意义。</p><p>时,美国的PE团伙集中在曼哈顿,而∨C和天使们则聚集在苹果的老家帕拉奥图。PE们每天打看<br>爱马仕领带,而VC们则穿看和乔布斯一样的衣服到处瞎比溜达,找他们心中无需看财务报表,只看<br>技术和团队的下一个网景或者亚马逊。</p><p>如果说PE们考的是财务模型和数学分析,那V们靠的就是对技术领先性和市场占有率的赌局。事实<br>证明,西海岸的∨C们比曼哈顿的那帮老头更讨人喜欢。黑石,KKR们动辄几百亿的并购,也敌不过<br>西海岸一个又一个高科技上市公司的造富神话。</p><p>那么,说完了历史问题,针对题主的可题,讲点更直接的东西</p><p>1.PE更关注的是财务数据,现金流状况,以及各种极限环境下的损失测算,因此PE失败的概率较<br>小,但暴富的概率也不大<br>2.VC需要关注的则是产品本身,市场潜力和社会价值,要准确的洞察历史的演进和应用的趋势,并<br>成为下一个风囗里的猪<br>3.天使更需要准确的洞察趋势,以及赌对一个产品或团队<br>上世纪末,因为互联网和高科技行业的譟动,伴随看大批高科技企业的IPO,一大批VC和天使基<br>金就此崛起。</p><p>但,VC和天使们所面对的行业趋势不可预知性和极大地投资风险,是他们相对PE最大的区别所在<br>要了解vc和天使的区别,就必须要了解他们的起源和PE的发展历史,以及几个重要的历史变革<br>vc和天使的投资理念,孬资风格都是从我讲的这些历史里演化而来的。</p><p>VC和PE的发展时间较长，资金来源比较丰富，高净值个人、专业风险基金、杠杆并购基金、战略投资者、养老基金、保险公司。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于风投泄密及其保密协议&quot;&gt;&lt;a href=&quot;#关于风投泄密及其保密协议&quot; class=&quot;headerlink&quot; title=&quot;关于风投泄密及其保密协议&quot;&gt;&lt;/a&gt;关于风投泄密及其保密协议&lt;/h1&gt;&lt;p&gt;保密协议就属于防君子不防小人,特别是在商业模式、概念以及技术在早期还很不具象的时候(这恰恰都是初创公司所面临的情况),保密协议起到的作用就更小,因为连保护的标的都不清楚,总不能说保护一个头脑中的idea吧?即使起到作用,通过法律手段花上无数的时间和精力去索赔并成功,损失的时间和精力放在自己的梦想和创业上,是不是会更加划算?天使投资人最大的价值就是,给钱不捣乱,同时需要的时候提供不太计较的支持.&lt;/p&gt;
    
    </summary>
    
      <category term="创业之路" scheme="http://yoursite.com/categories/%E5%88%9B%E4%B8%9A%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="风险投资" scheme="http://yoursite.com/tags/%E9%A3%8E%E9%99%A9%E6%8A%95%E8%B5%84/"/>
    
      <category term="VC" scheme="http://yoursite.com/tags/VC/"/>
    
      <category term="融资" scheme="http://yoursite.com/tags/%E8%9E%8D%E8%B5%84/"/>
    
  </entry>
  
  <entry>
    <title>google-Google Protocol Buffer</title>
    <link href="http://yoursite.com/2018/03/15/google-tech00/"/>
    <id>http://yoursite.com/2018/03/15/google-tech00/</id>
    <published>2018-03-15T12:46:01.000Z</published>
    <updated>2018-03-16T13:56:51.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Google-Protocol-Buffer"><a href="#Google-Protocol-Buffer" class="headerlink" title="Google Protocol Buffer"></a>Google Protocol Buffer</h1><p>什么是 Google Protocol Buffer？ 假如您在网上搜索，应该会得到类似这样的文字介绍：<br>Google Protocol Buffer( 简称 Protobuf) 是 Google 公司内部的混合语言数据标准，目前已经正在使用的有超过 48,162 种报文格式定义和超过 12,183 个 .proto 文件。他们用于 RPC 系统和持续数据存储系统。<br>Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API。<br>或许您和我一样，在第一次看完这些介绍后还是不明白 Protobuf 究竟是什么，那么我想一个简单的例子应该比较有助于理解它。</p><p><img src="/2018/03/15/google-tech00/p1.png" alt="logo"></p><a id="more"></a><p>移动应用客户端与服务器之间的通信协议,目前比较主流的有Facebook的Thrift,腾讯的JCE,以及Google的ProtocolBuffer(以下简称protobuf),本文主要介绍protobuf基本概念,协议解析,以及在Android中的应用实践。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>一种 结构化数据 的数据存储格式（类似于 <code>XML、Json</code> ）,用于网络世界的数据交换</p><p>Google 出品 （开源）<br>Protocol Buffer 目前有两个版本：proto2 和 proto3<br>因为proto3 还是beta 版，所以本次讲解是 proto2</p><p>Protobuf是一种灵活高效的,用于序列化结构化数据的机制,类似于XML,但比XML更小,更快,更简单。Protobuf序列化为二进制数据,不依赖于平台和语言,同时具备很好的兼容性。</p><p>通过将 结构化的数据 进行 串行化（序列化），从而实现 数据存储 / RPC(Remote Procedure Call Protocol远程过程调用协议) 数据交换的功能：</p><p>序列化： 将 数据结构或对象 转换成 二进制串 的过程<br>反序列化：将在序列化过程中所生成的二进制串 转换成 数据结构或者对象 的过程</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>传输数据量大 &amp; 网络环境不稳定 的数据存储、RPC 数据交换 的需求场景</p><p>如 即时IM （QQ、微信）的需求场景</p><p>在 传输数据量较大的需求场景下，Protocol Buffer比XML、Json 更小、更快、使用 &amp; 维护更简单！</p><h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><h3 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h3><h3 id="OSI-RM协议模型"><a href="#OSI-RM协议模型" class="headerlink" title="OSI/RM协议模型"></a>OSI/RM协议模型</h3><p>说到GPB（Google protocol Buffer）通过序列化与反序列化来进行数据传输，那么我们来聊聊序列化的问题。</p><p>序列化 &amp; 反序列化 属于通讯协议的一部分<br>通讯协议采用分层模型：TCP/IP模型（四层） &amp; OSI 模型 （七层）</p><p>ISO/OSI的参考模型共有7层，由低层至高层分别为：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><p>各层功能分别为：</p><p>（1）物理层</p><p>提供建立、维护和拆除物理链路所需的机械、电气、功能和规程的特性；提供有关在传输介质上传输非结构的位流</p><p>及物理链路故障检测指示。在这一层，数据还没有被组织，仅作为原始的位流或电气电压处理，单位是比特。</p><p>（2）数据链路层</p><p>负责在两个相邻结点间的线路上，无差错地传送以帧为单位的数据，并进行流量控制。每一帧包括一定数量的数据</p><p>和一些必要的控制信息。与物理层相似，数据链路层要负责建立、维持和释放数据链路的连接。在传送数据时，如</p><p>果接收点检测到所传数据中有差错，就要通知发方重发这一帧。</p><p>（3）网络层</p><p>为传输层实体提供端到端的交换网络数据传送功能，使得传输层摆脱路由选择、交换方式、拥挤控制等网络传输</p><p>细节；可以为传输层实体建立、维持和拆除一条或多条通信路径；对网络传输中发生的不可恢复的差错予以报告。</p><p>网络层将数据链路层提供的帧组成数据包，包中封装有网络层包头，其中含有逻辑地址信息——源站点和目的站点</p><p>地址的网络地址。</p><p>（4）传输层</p><p>为会话层实体提供透明、可靠的数据传输服务，保证端到端的数据完整性；选择网络层的最适宜的服务；提供建</p><p>立、维护和拆除传输连接功能。传输层根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间提</p><p>供建立、维护和取消传输连接的功能，并以可靠和经济的方式传输数据。在这一层，信息的传送单位是报文。</p><p>（5）会话层</p><p>为彼此合作的表示层实体提供建立、维护和结束会话连接的功能；完成通信进程的逻辑名字与物理名字间的对应；</p><p>提供会话管理服务。</p><p>（6）表示层</p><p>为应用层进程提供能解释所交换信息含义的一组服务，即将欲交换的数据从适合于某一用户的抽象语法，转换为</p><p>适合于OSI系统内部使用的传送语法，提供格式化的表示和转换数据服务。数据的压缩，解压缩，加密和解密等</p><p>工作都由表示层负责。</p><p>（7）应用层</p><p>提供OSI用户服务，即确定进程之间通信的性质，以满足用户需要以及提供网络与用户应用软件之间的接口服务。</p><p>简言之，各层的作用：</p><p>物理层：在物理媒体上传输原始的数据比特流。</p><p>数据链路层：将数据分成一个个数据帧，以数据帧为单位传输。有应有答，遇错重发。</p><p>网络层：将数据分成一定长度的分组，将分组穿过通信子网，从信源选择路径后传到信宿。</p><p>传输层：提供不具体网络的高效、经济、透明的端到端数据传输服务。</p><p>会话层：进程间的对话也称为会话，会话层管理不同主机上各进程间的对话。</p><p>表示层： 为应用层进程提供格式化的表示和转换数据服务。</p><p>应用层：提供应用程序访问OSI环境的手段。</p><p>OSI网络体系结构各层协议：</p><p>（1）应用层：TELNET、FTP、TFTP、SMTP、SNMP、HTTP、BOOTP、DHCP、DNS<br>（2）表示层：<br> 　　文本：ASCII，EBCDIC<br> 　　图形：TIFF，JPEG，GIF，PICT<br> 　　声音：MIDI，MPEG，QUICKTIME<br>（3）会话层：NFS、SQL、RPC 、X-WINDOWS、ASP（APPTALK会话协议）、SCP<br>（4）传输层：TCP、UDP、SPX<br>（5）网络层：IP、IPX、ICMP、RIP、OSPF(Open Shortest Path First开放式最短路径优先)<br>（6）数据链路层：SDLC、HDLC、PPP、STP（Spanning Tree Protocol）、帧中继<br>（7）物理层：EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45</p><p>常用端口（每个协议都有一个缺省端口）</p><p><img src="/2018/03/15/google-tech00/p5.png" alt="logo"></p><h3 id="TCP-IP协议模型"><a href="#TCP-IP协议模型" class="headerlink" title="TCP/IP协议模型"></a>TCP/IP协议模型</h3><p>TCP/IP概念层次中与OSI模型相互对应</p><p><img src="/2018/03/15/google-tech00/p2.png" alt="logo"></p><p><img src="/2018/03/15/google-tech00/p4.jpg" alt="logo"></p><h3 id="两者关系"><a href="#两者关系" class="headerlink" title="两者关系"></a>两者关系</h3><p>OSI引入了服务、接口、协议、分层的概念，TCP/IP借鉴了OSI的这些概念建立TCP/IP模型。</p><p>OSI先有模型，后有协议，先有标准，后进行实践；而TCP/IP则相反，先有协议和应用再提出了模型，且是参照的OSI模型。</p><p>OSI是一种理论下的模型，而TCP/IP已被广泛使用，成为网络互联事实上的标准。</p><ul><li>TCP：transmission control protocol 传输控制协议</li><li>UDP：user data protocol 用户数据报协议</li></ul><p><img src="/2018/03/15/google-tech00/p3.png" alt="logo"></p><p>OSI七层协议模型算是一个理想的规范模型而不应用在实践中，而TCP/IP模型则是现在国际所通用的网络传输协议模型</p><p>序列化 / 反序列化 属于 TCP/IP模型 应用层 和 OSI`模型 展示层的主要功能：</p><ul><li>（序列化）把 应用层的对象 转换成 二进制串</li><li>（反序列化）把 二进制串 转换成 应用层的对象<br>所以， Protocol Buffer属于 TCP/IP模型的应用层 &amp; OSI模型的展示层</li></ul><h2 id="对于数据结构和对象"><a href="#对于数据结构和对象" class="headerlink" title="对于数据结构和对象"></a>对于数据结构和对象</h2><h3 id="数据结构、对象与二进制串"><a href="#数据结构、对象与二进制串" class="headerlink" title="数据结构、对象与二进制串"></a>数据结构、对象与二进制串</h3><p>不同的计算机语言中，数据结构，对象以及二进制串的表示方式并不相同。</p><p>对于面向对象的语言（如Java）：对象 = Object = 类的实例化；在Java中最接近数据结构 即 POJO（Plain Old Java Object），或Javabean（只有 setter/getter 方法的类）</p><p>对于半面向对象的语言（如C++），对象 = class，数据结构 = struct</p><p>对于C++，因为具有内存操作符，所以 二进制串 容易理解：C++的字符串可以直接被传输层使用，因为其本质上就是以 ‘\0’ 结尾的存储在内存中的二进制串</p><p>对于 Java，二进制串 = 字节数组 =byte[]<br>byte 属于 Java 的八种基本数据类型<br>二进制串 容易和 String混淆：String 一种特殊对象（Object）。对于跨语言间的通讯，序列化后的数据当然不能是某种语言的特殊数据类型。</p><h3 id="T-L-V-的数据存储方式"><a href="#T-L-V-的数据存储方式" class="headerlink" title="T - L - V 的数据存储方式"></a>T - L - V 的数据存储方式</h3><ul><li>定义 </li></ul><p>即 Tag - Length - Value，标识 - 长度 - 字段值 存储方式</p><p>作用<br>以 标识 - 长度 - 字段值 表示单个数据，最终将所有数据拼接成一个 字节流，从而 实现 数据存储 的功能</p><p>其中 Length可选存储，如 储存Varint编码数据就不需要存储Length</p><ul><li>示意图</li></ul><p><img src="/2018/03/15/google-tech00/p6.png" alt="logo"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Google-Protocol-Buffer&quot;&gt;&lt;a href=&quot;#Google-Protocol-Buffer&quot; class=&quot;headerlink&quot; title=&quot;Google Protocol Buffer&quot;&gt;&lt;/a&gt;Google Protocol Buffer&lt;/h1&gt;&lt;p&gt;什么是 Google Protocol Buffer？ 假如您在网上搜索，应该会得到类似这样的文字介绍：&lt;br&gt;Google Protocol Buffer( 简称 Protobuf) 是 Google 公司内部的混合语言数据标准，目前已经正在使用的有超过 48,162 种报文格式定义和超过 12,183 个 .proto 文件。他们用于 RPC 系统和持续数据存储系统。&lt;br&gt;Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API。&lt;br&gt;或许您和我一样，在第一次看完这些介绍后还是不明白 Protobuf 究竟是什么，那么我想一个简单的例子应该比较有助于理解它。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/03/15/google-tech00/p1.png&quot; alt=&quot;logo&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Google" scheme="http://yoursite.com/categories/Google/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="java类库" scheme="http://yoursite.com/tags/java%E7%B1%BB%E5%BA%93/"/>
    
      <category term="google" scheme="http://yoursite.com/tags/google/"/>
    
      <category term="protocol Buffer" scheme="http://yoursite.com/tags/protocol-Buffer/"/>
    
      <category term="数据交换" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>JAVA开发常用类库--JDBC故障诊断</title>
    <link href="http://yoursite.com/2018/03/15/java-api13/"/>
    <id>http://yoursite.com/2018/03/15/java-api13/</id>
    <published>2018-03-15T09:32:29.000Z</published>
    <updated>2018-03-15T11:18:57.060Z</updated>
    
    <content type="html"><![CDATA[<p>有不错的JDBC扩展库的存在使得调试变得很容易，例如P6spy，这是一个针对数据库访问操作的动态监测框架，它使得数据库数据可无缝截取和操纵，而不必对现有应用程序的代码作任何修改。P6Spy 分发包包括P6Log，它是一个可记录任何 Java 应用程序的所有JDBC事务的应用程序。其配置完成使用时，可以进行数据访问性能的监测。</p><p>在我们 Java 开发应用程序的过程中，难免会碰到系统的性能问题，特别在企业应用的开发过程中，都会与数据库进行打交道。当我们碰到数据库性能时，最有效的就是直接跟踪每一个 SQL 语句的执行情况，SQL 语句的优化、索引的优化往往也是最容易取得最直接的效果的。</p><p>在应用程序开发过程中，为了方便调试，通常都需要知道在DAO层程序执行的SQL是什么，而P6spy这个组件正是提供了该功能。</p><p>已在Github上开源：<a href="https://github.com/p6spy/p6spy" target="_blank" rel="noopener">https://github.com/p6spy/p6spy</a></p><a id="more"></a><p>依赖添加</p><pre><code>&lt;dependency&gt;  &lt;groupId&gt;p6spy&lt;/groupId&gt;  &lt;artifactId&gt;p6spy&lt;/artifactId&gt;  &lt;version&gt;3.6.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>然后将p6spy的配置文件spy.properties放置项目的src/main/resources目录下,该文件只需要修改logfile，logMessageFormat，dateformat属性即可，如下图所示:</p><pre><code>logfile=mybatis-practices-core.log   //具体文件位置logMessageFormat= net.ittimeline.mybatis.practices.core.p6spy.CustomizeLineFormat   //具体文件信息格式dateformat=yyyy-MM-dd HH:mm:ss   //数据格式databaseDialectDateFormat=yyyy-MM-dd HH:mm:ss   //数据库方言数据格式</code></pre><p>配置参数文档说明在 <a href="https://github.com/p6spy/p6spy/blob/master/docs/configandusage.md" target="_blank" rel="noopener">https://github.com/p6spy/p6spy/blob/master/docs/configandusage.md</a> 中写的很清楚</p><p>然后实现自定义的SQL输出格式</p><p>为了输出的内容足够的简洁，这里只保留了当前时间，执行SQL的耗时以及执行的SQL语句,具体实现如下所示<br>这里用了alibaba.druid的数据库连接池技术，具体大同小异。</p><pre><code>package net.ittimeline.mybatis.practices.core.p6spy;import com.alibaba.druid.sql.SQLUtils;import com.p6spy.engine.spy.appender.MessageFormattingStrategy;/** * @author tony ittimeline@163.com * @date 2018-01-30-下午10:45 * @website wwww.ittimeline.net * @see * @since JDK8u162 */public class CustomizeLineFormat implements MessageFormattingStrategy {    public String buildMessage(String now, long elapsed, String sql) {        StringBuffer content = new StringBuffer();        if (org.apache.commons.lang3.StringUtils.isNotEmpty(now) &amp;&amp; org.apache.commons.lang3.StringUtils.isNotEmpty(Long.valueOf(elapsed).toString())                &amp;&amp; org.apache.commons.lang3.StringUtils.isNotEmpty(sql)) {            content.append(&quot;当前时间:&quot; + now);            content.append(&quot; SQL执行耗时(毫秒)为&quot; + elapsed);            content.append(&quot; SQL执行的语句是\n&quot; + SQLUtils.formatMySql(sql)+&quot;\n\n&quot;);        }        return content.toString();    }    @Override    public String formatMessage(int connectionId, String now, long elapsed, String category, String prepared, String sql) {        return buildMessage(now, elapsed, sql);    }}</code></pre><p>然后增加一个database.properties文件，配置内容如下</p><p>和传统的jdbc配置相比，不同之处在于驱动类和连接地址的配置。</p><pre><code>jdbc.driver=com.p6spy.engine.spy.P6SpyDriverjdbc.url=jdbc:p6spy:mysql://127.0.0.1:3306/mybatis?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=falsejdbc.username=korontojdbc.password=xxxxxxxx</code></pre><p>而mybatis-config.xml文件中只需要增加一行配置<properties resource="database.properties">，然后就可以采用${属性名}的方式获取数据库配置了，配置如下所示</properties></p><pre><code>&lt;properties resource=&quot;database.properties&quot;/&gt;</code></pre> <!--配置数据库连接信息 --><pre><code>&lt;environments default=&quot;development&quot;&gt;    &lt;environment id=&quot;development&quot;&gt;        &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;        &lt;dataSource type=&quot;POOLED&quot;&gt;            &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;            &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;            &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;            &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;        &lt;/dataSource&gt;    &lt;/environment&gt;&lt;/environments&gt;</code></pre><p>然后运行CountryMapperTest.selectAll()方法，会发现在mybatis-practices-core模块的根路径下存在一个mybatis-practices-core.log的文件，内容如下</p><pre><code>当前时间:2018-01-30 23:03:07 SQL执行耗时(毫秒)为0 SQL执行的语句是SELECT country_id AS countryId, country_name AS countryName, country_code AS countryCodeFROM t_country</code></pre><p>把具体的SQL语句信息给打印出来了。</p><p>在 P6Spy 发布包中，它包含 P6Log 和 P6Outage 两个模块：</p><ul><li><p>P6Log<br>P6Log 是用来拦截和记录任务应用程序的 JDBC 语句的。这个功能对于开发者监控 EJB 服务器上的 SQL 语句执行情况尤其有用，可以让开发者完成尽可能高效的代码。同时 P6Spy 的部署是极其简单的，而且根本不需要更改任何一行代码，即对现有的应用是无侵入性的。</p></li><li><p>P6Outage<br>P6Outage 专门用来检测和记录执行时间比较长的 SQL 语句，P6Outage 只记录超过配置条件里时间的那些信息，并对可能影响到数据库的运行效率减小到最低。</p></li></ul><h1 id="架构原理"><a href="#架构原理" class="headerlink" title="架构原理"></a>架构原理</h1><p>简单地讲，我们可以认为 P6Spy 就是一个代理（Proxy），它只做了一层对 JDBC 驱动的拦截，然后转发出去，这样的设计与实际的应用程序没有任何的耦合性，除了在配置中将驱动程序改成 P6Spy 的拦截驱动外，程序其他地方并不需要做任何的改变。这层拦截器除了可能会给系统带来略微的性能下降外，对程序其他方面没有任何的影响。而相对于这一点点的性能下降，在开发环境中对于开发人员来说是无法感觉到，相比它所带来的好处，完全可以忽略不计。</p><p>P6Spy 对数据库进行拦截监控的处理过程如下：</p><p><img src="/2018/03/15/java-api13/p1.png" alt="logo"></p><h1 id="问题与解决"><a href="#问题与解决" class="headerlink" title="问题与解决"></a>问题与解决</h1><p>如果在你的应用程序启动后，却在 spy.log 文件中发现了如下的提示信息，那就是驱动程序加载先后的问题了。</p><pre><code>&lt;你的程序的数据库驱动名称&gt; is a real driver in spy.properties, but it has been loaded before p6spy.  p6spy will not wrap these connections.  Either prevent the driver from loading, or try setting&apos;deregisterdrivers&apos; to true in spy.properties</code></pre><p>解决办法：</p><p>请把 spy.properties 配置文件里的 deregisterdrivers=false 改为 deregisterdrivers=true，重新运行即可。<br>这是因为有些应用系统中会先于 P6Spy 加载了真正的数据库的驱动程序，导致 P6Spy 无法监控到，设置 deregisterdrivers 为 true，是显式地把真正的数据库的驱动程序进行反注册掉，而采用 P6Spy 的驱动程序。</p><h1 id="配置参数及相关意义"><a href="#配置参数及相关意义" class="headerlink" title="配置参数及相关意义"></a>配置参数及相关意义</h1><p>下表列出了 spy.properties 配置文件中的各配置项的名称、默认值及其意义和相关注意事项：</p><pre><code>配置项名称                                                 默认值module.log                                                 com.p6spy.engine.logging. P6LogFactorymodule.outage                                             com.p6spy.engine.outage. P6OutageFactoryrealdriver     realdriver2     realdriver3     deregisterdrivers                                         falseexecutionthreshold     outagedetection    falseoutagedetectioninterval     filter                                                     falseinclude     exclude     sqlexpression     autoflush                                                 truedateformat     includecategories     excludecategories     stringmatcher     stacktrace                                                 falsestacktraceclass     reloadproperties                                         falsereloadpropertiesinterval                                 60useprefix                                                 falseappender                                                 com.p6spy.engine.logging. appender.FileLoggerlogfile                                                     spy.logappend    truelog4j.appender.STDOUT                                     org.apache.log4j.ConsoleAppenderlog4j.appender.STDOUT.layout                            org.apache.log4j.PatternLayoutlog4j.appender.STDOUT. layout.ConversionPattern            p6spy - %m%nlog4j.logger.p6spy                                        INFO,STDOUTrealdatasource     realdatasourceclass     realdatasourceproperties     jndicontextfactory     jndicontextproviderurl     jndicontextcustom</code></pre><h1 id="SQL-Profiler"><a href="#SQL-Profiler" class="headerlink" title="SQL Profiler"></a>SQL Profiler</h1><p>SQL Profiler 是一个由 Jahia.org 提供的基于 P6Spy 引擎的快速剖析工具，用来统计 SQL 查询语句以便了解哪里是性能瓶颈，在哪里创建索引或者采取相应的办法才能提高效率，并且能根据 SQL 查询语句的情况帮你生成合适的索引脚本。</p><p>这个小工具可以实时地显示数据库查询的情况，通过集成的 SQL 解析器，在访问大多数表与列上面建立统计分析，并生成索引脚本。当然，其它的信息也会进行收集和显示，比如：单个数据库请求的时间、一类请求的时间以及所有请求的时间。因此，可以有效地通过视图的排序来检测数据的性能问题所在。这个工具对于大量的需要进行分析的请求是非常有用的，而不是人工一个个地去做分析。当你需要知道比如对相同的表和列进行访问但是采用不同的查询值时，这种分组的查询可以用建立在 ANTLR 上的 SQL 解析器进行分析。</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><p>首先，你的应用系统同样也应当是基于数据库的，然后你需要去获取 SQL Profiler 相关的文件（在 参考资源 中可以找到下载链接，您可以直接下载软件包）。下面介绍 SQL Profiler 的安装与使用的详细操作过程：<br>下载 SQL Profiler 的文件包进行安装；<br>把 p6spy.jar 及 sqlprofiler.jar 放到 CLASSPATH 中，如果是 Web 应用程序则放在 YourWebApp/WEB-INF/lib/ 目录下；<br>把 spy.properties 放到 CLASSPATH 目录下，如果是 Web 应用程序就放在 YourWebApp/WEB-INF/classess/ 目录下，注意不是 lib/ 目录；<br>修改你应用系统中的数据库驱动名称为 P6Spy 的驱动程序名称 com.p6spy.engine.spy.P6SpyDriver 其它的全部使用默认值，暂时不用修改；<br>打开 spy.properties 文件，把 realdriver 的值改为你的程序的数据库驱动名称；<br>注意要先运行 java -jar sqlprofiler.jar 来启动 SQL Profiler，并成功看到启动界面；<br>然后再启动你的应用程序或服务器，并开始进行正常的系统请求处理操作；<br>这样就可以在 SQL Profiler 图形化的界面上看到结果并进行分析了。</p><p>参考资料：<a href="http://blog.csdn.net/heyeqingquan/article/details/71743814" target="_blank" rel="noopener">http://blog.csdn.net/heyeqingquan/article/details/71743814</a></p><h2 id="分析结果"><a href="#分析结果" class="headerlink" title="分析结果"></a>分析结果</h2><p>经过一段时间的系统运行后，点击 Pause 按钮停止拦截，可以得到分析结果如下图：</p><p>SQL Profiler 的分析结果 Profiler 视图</p><p><img src="/2018/03/15/java-api13/p2.png" alt="logo"></p><p>接着，可以切换到 Loggers 视图，这是 Lgger 视图的信息：</p><p>SQL Profiler 的分析结果 Logger 视图</p><p><img src="/2018/03/15/java-api13/p3.png" alt="logo"></p><p>当然，也可以切换到 Analysis 视图，这是 Analysis 视图的分析结果信息：</p><p>SQL Profiler 的分析结果 Analysis 视图</p><p><img src="/2018/03/15/java-api13/p4.png" alt="logo"></p><p>在经过分析后，我们可以直接通过 SQLProfiler 提交的保存按钮，直接导出应当进行数据库优化的建议的索引脚本，通过查看索引脚本，我们可以看到创建索引的详细 SQL 脚本，这样，我们就可以非常方便地进行数据库调优了。</p><h2 id="问题与解决-1"><a href="#问题与解决-1" class="headerlink" title="问题与解决"></a>问题与解决</h2><p>最后一个需要注意的问题就是需要先启动 SQLProfiler，然后再启动应用程序或者 Tomcat 等应用服务器。这是因为 SQLProfiler 默认使用的是 Log4j 的 SocketAppender，所以要先启动。否则，会因你的应用程序或应用服务器中的 Web 应用之类的因连接不到 Socket 的服务器（SQLProfiler 相当于 Socket 的服务器）而发生错误，可以通过 SQL Profiler 控制界面最下面的连接状态就可以知道是否有程序连接上来。</p><p><img src="/2018/03/15/java-api13/p5.png" alt="logo"></p><h1 id="IronTrack-SQL"><a href="#IronTrack-SQL" class="headerlink" title="IronTrack SQL"></a>IronTrack SQL</h1><p>IronEye，一个专注于 JDBC 性能的监控和测试的开源项目，它包含有三个工具：IronEye SQL，IronEye Cache，IronTrack SQL。其中，IronEye SQL 用于监测 Java 应用和数据库服务器之间查询开销的时间，诊断在性能方面是否存在着相关问题，让开发人员在测试之前就能发现问题。IronEye 于 2003 年 10 月 1 日开始基于 Apache Software License 发布。<br>IronEye SQL 这个轻量级的 Java 工具提供所有流动在数据库与应用程序之间的 SQL 统计信息并用多张图表展现，可以快速优化程序的性能。<br>IronGrid 相对于 Continuous Integration 提出了 Continuous Performance 的概念，即在项目开发过程中随时关注性能问题，而不是传统的出了问题再解决的方案。<br>IronGrid 在应用程序对数据库的操作上的 Continuous Performance 是通过 IronTrack SQL 进行体现的。IronTrack SQL 能通过对 JDBC 的包装来拦截应用程序对数据库的请求，完成性能监控。IronTrack SQL 的好处在于不需要修改任何代码或者在数据库端安装任何程序，只需要在测试时把依赖的 JDBC 替换就可以了。</p><h2 id="使用步骤-1"><a href="#使用步骤-1" class="headerlink" title="使用步骤"></a>使用步骤</h2><p>首先，你的应用系统同样也应当是基于数据库的，然后你需要去获取 IronTrack SQL 相关的文件（在 参考资源 中可以找到下载链接，您可以直接下载软件包）。下面介绍 IronTrack SQL 的安装与使用的详细操作过程：<br>下载 IronTrack SQL 的文件包进行安装；<br>把 irontracksql.jar, p6spy.jar 和 log4j-1.2.8.jar 放到 CLASSPATH 中，如果是 Web 应用程序则放在 YourWebApp/WEB-INF/lib/ 目录下；<br>把 spy.properties 放到 CLASSPATH 目录下，如果是 Web 应用程序就放在 YourWebApp/WEB-INF/classess/ 目录下，注意不是 lib/ 目录；<br>修改你程序的数据库驱动名称为 P6Spy 的驱动程序名称 com.p6spy.engine.spy.P6SpyDriver 其它的都不用更改；<br>打开配置文件 spy.properties 文件，找到 realdriver，把它的值改为你的应用系统的真正的数据库驱动名称；<br>设置监听端口号 monitorport=2000；<br>先运行 java -jar irontracksql.jar 来启动 IronTrack SQL；<br>再启动你的应用程序或服务器；<br>可以在 IronTrack SQL 图形化的界面上看到结果并进行分析了。</p><p>连接设置<br>点击“Config”按钮就可以设置主机名、端口与刷新的时间（毫秒为单位）。根据你的服务器与端口的不同而进行相应地改变，下面以本地和 2000 端口，刷新时间为 500 毫秒为示例。设置完成后，确定，点击“Connect”就可以连接应用系统并进行监测与分析了，当要停止分析时，只要点击“Disconnect”按扭即可立刻停止分析了。<br>在分析的过程中，我们可以根据需要点击“Purge”按钮，它可以清除目前所监测到的内容，然后重新进行记录监测信息，很方便地进行重新开始。</p><p>IronTrack SQL 连接示例</p><p><img src="/2018/03/15/java-api13/p6.png" alt="logo"></p><h2 id="分析结果-1"><a href="#分析结果-1" class="headerlink" title="分析结果"></a>分析结果</h2><p>经过一段时间的系统运行后，我们可以直接得到分析的结果与相应的图形分析示例。相关的信息显示如下：</p><p>IronTrack SQL 分析结果</p><p><img src="/2018/03/15/java-api13/p7.png" alt="logo"></p><p>Count 列显示 SQL 语句的调用次数；<br>Avg Time 列显示 SQL 语句的执行平均时间；<br>Max Time 列显示 SQL 语句花费的最高时间；<br>SQL 列显示真正执行的 SQL 语句内容。<br>同时也可以通过设置过滤条件来显示指定条件的结果，比如：只关注平均调用次数大于 100 次 的结果。点击“Filtering”左边的小三角图标，可以显示如下的过滤条件设置栏目：</p><p>IronTrack SQL 设置相关的过滤条件</p><p><img src="/2018/03/15/java-api13/p8.png" alt="logo"></p><p>设置完成后，点击“Apply Filter”按钮即可以获取所需要的相关结果了。这样可以更加方便地集中精力进行所需要的内容分析，可以更加方便快速地定位到问题的所在之处，然后进行解决。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过使用 P6Spy、SQL Profiler、IronTrack SQL 工具，我们可以无侵入已有的应用系统而有效地进行数据库操作的监控与剖析，为发现系统的性能瓶颈，寻找系统的性能调优提供了相当便利的方法。</p><p>p6spy专区：<a href="http://www.p6spy.com/" target="_blank" rel="noopener">http://www.p6spy.com/</a><br>sqlprofiler专区：<a href="https://sourceforge.net/projects/sqlprofiler/" target="_blank" rel="noopener">https://sourceforge.net/projects/sqlprofiler/</a><br><a href="https://www.ibm.com/developerworks/cn/java/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有不错的JDBC扩展库的存在使得调试变得很容易，例如P6spy，这是一个针对数据库访问操作的动态监测框架，它使得数据库数据可无缝截取和操纵，而不必对现有应用程序的代码作任何修改。P6Spy 分发包包括P6Log，它是一个可记录任何 Java 应用程序的所有JDBC事务的应用程序。其配置完成使用时，可以进行数据访问性能的监测。&lt;/p&gt;
&lt;p&gt;在我们 Java 开发应用程序的过程中，难免会碰到系统的性能问题，特别在企业应用的开发过程中，都会与数据库进行打交道。当我们碰到数据库性能时，最有效的就是直接跟踪每一个 SQL 语句的执行情况，SQL 语句的优化、索引的优化往往也是最容易取得最直接的效果的。&lt;/p&gt;
&lt;p&gt;在应用程序开发过程中，为了方便调试，通常都需要知道在DAO层程序执行的SQL是什么，而P6spy这个组件正是提供了该功能。&lt;/p&gt;
&lt;p&gt;已在Github上开源：&lt;a href=&quot;https://github.com/p6spy/p6spy&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/p6spy/p6spy&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="java类库" scheme="http://yoursite.com/tags/java%E7%B1%BB%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JAVA开发常用类库--嵌入式SQL</title>
    <link href="http://yoursite.com/2018/03/15/java-api12/"/>
    <id>http://yoursite.com/2018/03/15/java-api12/</id>
    <published>2018-03-15T09:23:52.000Z</published>
    <updated>2018-03-15T12:22:40.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="嵌入式SQL"><a href="#嵌入式SQL" class="headerlink" title="嵌入式SQL"></a>嵌入式SQL</h1><p>嵌入式SQL(英文 Embedded SQL)是一种将SQL语句直接写入C语言，COBOL，FORTRAN, Ada等编程语言的源代码中的方法。<br>借此方法，可使得应用程序拥有了访问数据以及处理数据的能力。在这一方法中，将SQL文嵌入的目标源码的语言称为宿主语言。</p><p>在SQL标准的SQL86(1986年发布)中定义了对于COBOL, FORTRAN（福传语言，即数学公式语言）, PI/L等语言的嵌入式SQL的规范。在SQL89(1989年发布)规范中，定义了对于C语言的嵌入式SQL的规范。一些大型的数据库厂商发布的数据库产品中，都提供了对于嵌入式SQL的支持。比如Oracle, DB2等。</p><a id="more"></a><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>提供对于嵌入式SQL的支持，需要数据库厂商除了提供DBMS之外，还必须提供一些工具。为了实现对于嵌入式SQL的支持，技术上必须解决以下4个问题:</p><p>1.宿主语言的编译器不可能识别和接受SQL文，需要解决如何将SQL的宿主语言源代码编译成可执行码;<br>2.宿主语言的应用程序如何与DBMS之间传递数据和消息;<br>3.如何把对数据的查询结果逐次赋值给宿主语言程序中的变量以供其处理;<br>4.数据库的数据类型与宿主语言的数据类型有时不完全对应或等价，如何解决必要的数据类型转换问题。</p><p>嵌入式SQL源码的处理流程 为了解决上述这些问题，数据库厂商需要提供一个嵌入式SQL的预编译器，把包含有嵌入式SQL文的宿主语言源码转换成纯宿主语言的代码。这样一来，源码即可使用宿主语言对应的编译器进行编译。通常情况下，经过嵌入式SQL的预编译之后，原有的嵌入式SQL会被转换成一系列函数调用。因此，数据库厂商还需要提供一系列函数库，以确保链接器能够把代码中的函数调用与对应的实现链接起来。</p><h2 id="扩展语法"><a href="#扩展语法" class="headerlink" title="扩展语法"></a>扩展语法</h2><p>嵌入式SQL中除了可以执行标准SQL文之外，为了对应嵌入的需要，还增加了一些额外的语法成分。主要包含以下内容：</p><ul><li>宿主变量使用声明的语法</li><li>数据库访问的语法</li><li>事务控制的语法</li><li>游标操作的语法</li></ul><h2 id="嵌入形式"><a href="#嵌入形式" class="headerlink" title="嵌入形式"></a>嵌入形式</h2><p>对宿主型数据库语言SQL，DBMS可以采用两种方法处理，一种是预编译，另一种是修改和扩充主语言使之能处理SQL语句。目前采用较多的是预编译的方法。即有DBMS的预处理程序对源程序进行扫描，识别出SQL语句，把它们转换成主语言调用语句，以使主语言编译程序能识别它，最后由主语言的编译程序将整个源程序编译成目标码。<br>在嵌入式SQL中，为了能够区分SQL语句与主语言语句，所以SQL语句都必须加前缀EXEC SQL。SQL语句的结束标准则随主语言的不同而不同。<br>例如：在PL/1和C中以分号（;）结束：<br>EXEC SQL<sql 语句="">;<br>在COBOL中以END-EXEC结束：<br>EXEC SQL&lt;SQL语句&gt; END-EXEC<br>例如一条交互形式的SQL语句：<br>DROP TABLE Student;<br>嵌入到C程序中应写作：EXEC SQL DROP TABLE Student;</sql></p><p>可参考文章</p><p><a href="http://blog.csdn.net/shaoshuo/article/details/2463632" target="_blank" rel="noopener">http://blog.csdn.net/shaoshuo/article/details/2463632</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;嵌入式SQL&quot;&gt;&lt;a href=&quot;#嵌入式SQL&quot; class=&quot;headerlink&quot; title=&quot;嵌入式SQL&quot;&gt;&lt;/a&gt;嵌入式SQL&lt;/h1&gt;&lt;p&gt;嵌入式SQL(英文 Embedded SQL)是一种将SQL语句直接写入C语言，COBOL，FORTRAN, Ada等编程语言的源代码中的方法。&lt;br&gt;借此方法，可使得应用程序拥有了访问数据以及处理数据的能力。在这一方法中，将SQL文嵌入的目标源码的语言称为宿主语言。&lt;/p&gt;
&lt;p&gt;在SQL标准的SQL86(1986年发布)中定义了对于COBOL, FORTRAN（福传语言，即数学公式语言）, PI/L等语言的嵌入式SQL的规范。在SQL89(1989年发布)规范中，定义了对于C语言的嵌入式SQL的规范。一些大型的数据库厂商发布的数据库产品中，都提供了对于嵌入式SQL的支持。比如Oracle, DB2等。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="java类库" scheme="http://yoursite.com/tags/java%E7%B1%BB%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JAVA开发常用类库--HTML解析库</title>
    <link href="http://yoursite.com/2018/03/15/java-api11/"/>
    <id>http://yoursite.com/2018/03/15/java-api11/</id>
    <published>2018-03-15T05:13:05.000Z</published>
    <updated>2018-03-15T09:22:44.155Z</updated>
    
    <content type="html"><![CDATA[<p>dom解析是常用dom4j。android中我们常用的是sax、pull。因为它们更省内存。而html解析,则也有很多框架</p><p>java的HTML解析通常用在利用java做网页的垂直爬虫</p><p>HTML是WEB的核心，互联网中你看到的所有页面都是HTML，不管它们是由JavaScript，JSP，PHP,ASP或者是别的什么WEB技术动态生成的。你的浏览器会去解析HTML并替你去渲染它们。不过如果你需要自己在Java程序中解析HTML文档并查找某些元素，标签，属性或者检查某个特定的元素是否存在的话，那又该如何呢？如果你已经使用Java编程多年了，我相信你肯定试过去解析XML，也使用过类似DOM或者SAX这样的解析器，不过很有可能你从未进行过任何的HTML解析的工作。更讽刺的是，在Java应用中，很少会有需要你去解析HTML文档的时候，这里并不包括Servlet或者其它的Java WEB技术。更糟糕的是，JDK核心里也没有包括HTTP或者HTML的库，至少我并不知道有这个。这就是为什么一碰上解析HTML文件时，许多Java程序员就得先Google一下 ，看看如何在Java中取出一个HTML的标签。当我有这个需要的时候，我相信肯定会有一些开源库能实现这个，不过我没有想到竟然有JSoup这么酷的并且功能齐全的库。它不仅能支持读取并解析HTML文档，而且还能让你从HTML文件抽取出任何的元素，以及它们的属性，它们的CSS属性，你还能进它们进行修改。有了JSoup你简直可以对HTML文档做任何事情。我们将会看到如何在Java中从google主页或者任何URL中下载并解析HTML文件的示例。</p><a id="more"></a><p>一般来说，一个爬虫包括几个部分：</p><ul><li>页面下载</li></ul><p>页面下载是一个爬虫的基础。下载页面之后才能进行其他后续操作。</p><ul><li>链接提取</li></ul><p>一般爬虫都会有一些初始的种子URL，但是这些URL对于爬虫是远远不够的。爬虫在爬页面的时候，需要不断发现新的链接。</p><ul><li>URL管理</li></ul><p>最基础的URL管理，就是对已经爬过的URL和没有爬的URL做区分，防止重复爬取。</p><ul><li>内容分析和持久化</li></ul><p>一般来说，我们最终需要的都不是原始的HTML页面。我们需要对爬到的页面进行分析，转化成结构化的数据，并存储下来。</p><p><strong>不同的爬虫，对这几部分的要求是不一样的。</strong></p><p>HTML分析是一个比较复杂的工作，Java世界主要有几款比较方便的分析工具：</p><ul><li>Jsoup</li></ul><p>Jsoup是一个集强大和便利于一体的HTML解析工具。它方便的地方是，可以用于支持用jquery中css selector的方式选取元素，这对于熟悉js的开发者来说基本没有学习成本。</p><p>Jsoup是一个开源的Java库，它可以用于处理实际应用中的HTML。它提供了非常便利的API来进行数据的提取及修改，充分利用了DOM，CSS以及jquery风格方法的长处。Jsoup实现了WAHTWG HTML5的规范，它从HTML解析出来的DOM和Chrome以及Firefox这样的现代浏览器解析出来的完全一致。下面是Jsoup库的一些有用的特性：</p><p>1.Jsoup可以从URL，文件，或者字符串中获取并解析HTML。<br>2.Jsoup可以查找并提取数据，可以使用DOM遍历或者CSS选择器。<br>3.你可以使用Jsoup来修改HTML元素，属性以及文本。<br>4.Jsoup通过一个安全的白名单确保了用户提交的内容是干净的，以防止XSS攻击。<br>5.Jsoup还能输出整洁的HTML。</p><p>在Java中使用Jsoup进行HTML解析</p><p>在这篇Java HTML解析的教程中，我们会看到在Java中使用Jsoup解析及遍历HTML的三个不同的示例。第一个例子中，我们会解析一个HTML字符串，它的内容就是Java中的字符串字面量组成的标签。第二个例子中，我们会从WEB中下载HTML文档，而第三个例子中，我们会加载一个HTML示例文件login.html来进行解析。这个文件是一个HTML文档的示例，它包含title标签,body里面有一个div标签，里面包含一个表单。它拥有input标签来用于获取用户名及密码，同时还有提交及重置的按钮用来进行下一步操作。它是一个正确有效的HTML，也就是说，所有的标签和属性都是正确地闭合的。下面是我们这个HTML的示例文件：</p><p>复制代码代码如下:</p><pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;   &lt;html&gt;   &lt;head&gt;   &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=ISO-8859-1&quot;&gt;   &lt;title&gt;Login Page&lt;/title&gt;   &lt;/head&gt;   &lt;body&gt;   &lt;div id=&quot;login&quot; class=&quot;simple&quot; &gt;   &lt;form action=&quot;login.do&quot;&gt;   Username : &lt;input id=&quot;username&quot; type=&quot;text&quot; /&gt;&lt;br&gt;   Password : &lt;input id=&quot;password&quot; type=&quot;password&quot; /&gt;&lt;br&gt;   &lt;input id=&quot;submit&quot; type=&quot;submit&quot; /&gt;   &lt;input id=&quot;reset&quot; type=&quot;reset&quot; /&gt;   &lt;/form&gt;   &lt;/div&gt;   &lt;/body&gt;   &lt;/html&gt;  </code></pre><p>使用Jsoup来解析HTML非常简单，你只需调用它的静态方法Jsoup.parse()并传入你的HTML字符串给它就可以了。Jsoup提供了多个重载的parse()方法，它可以从字符串，文件，URI，URL，甚至InputStream中读取HTML文件。如果不是UTF-8编码的话，你还可以指定字符编码，这样可以正确地读取HTML文件。下面是Jsoup库中HTML解析方法的一个完整的列表。parse(String html)方法将输入的HTML解析成一个新的Document。在Jsoup里，Document继承了Element，而它又继承自Node。同样的TextNode也继承自Node。只要你传入的是一个不为null的字符串，你就肯定能获取到一个成功的有意义的解析，得到一个包含head和body元素的Document。一旦你拿到这个Document，你就可以调用Document以及它的父类Element和Node上面的适当的方法来获取到你想要的数据了。</p><p>解析HTML文档的Java程序</p><p>下面是一个解析HTML字符串，网络上下载的HTML文件，以及本地文件系统中的HTML文件的完整的Java程序。你可以使用Eclipse IDE或者别的IDE甚至命令来运行这个程序。在Eclipse里面则很简单，拷贝这份代码，新建一个Java工程，在src包上右键并粘贴进去就可以了。Eclipse会去创建正确的包及同名的Java源文件的，因此工作量最小。如果你已经有一个Java示例工程了，那么仅需一步就可以了。下面的这个Java程序展示了解析及遍历HTML文件的三个不同例子。第一个例子中，我们直接解析了一个内容为HTML的字符串，第二个例子中我们解析了一个从URL中下载的HTML文件，第三个中我们从本地文件系统中加载了一个HTML文档并进行解析。第一和第三个例子中都用到了parse方法来获取一个Document对象，你可以查询它来提取出任何的标签值或者属性值。第二个例子中，我们用到了Jsoup.connect方法，它会去创建URL的连接，下载HTML并进行解析。这个方法也会返回Document，它可以用于后续的查询及获取标签或者属性的值。</p><p>复制代码代码如下:</p><pre><code>import java.io.IOException;  import org.jsoup.Jsoup;  import org.jsoup.nodes.Document;  import org.jsoup.nodes.Element;  /**  [*] Java Program to parse/read HTML documents from File using Jsoup library.  [*] Jsoup is an open source library which allows Java developer to parse HTML  [*] files and extract elements, manipulate data, change style using DOM, CSS and  [*] JQuery like method.  [*]  [*] @author Javin Paul  [*]/  public class HTMLParser{      public static void main(String args[]) {          // Parse HTML String using JSoup library          String HTMLSTring = &quot;&lt;!DOCTYPE html&gt;&quot;                  + &quot;&lt;html&gt;&quot;                  + &quot;&lt;head&gt;&quot;                  + &quot;&lt;title&gt;JSoup Example&lt;/title&gt;&quot;                  + &quot;&lt;/head&gt;&quot;                  + &quot;&lt;body&gt;&quot;                  + &quot;|[b]HelloWorld[/b]&quot;                  + &quot;&quot;                  + &quot;&lt;/body&gt;&quot;                  + &quot;&lt;/html&gt;&quot;;          Document html = Jsoup.parse(HTMLSTring);          String title = html.title();          String h1 = html.body().getElementsByTag(&quot;h1&quot;).text();          System.out.println(&quot;Input HTML String to JSoup :&quot; + HTMLSTring);          System.out.println(&quot;After parsing, Title : &quot; + title);          System.out.println(&quot;Afte parsing, Heading : &quot; + h1);          // JSoup Example 2 - Reading HTML page from URL          Document doc;          try {              doc = Jsoup.connect(&quot;http://google.com/&quot;).get();              title = doc.title();          } catch (IOException e) {              e.printStackTrace();          }          System.out.println(&quot;Jsoup Can read HTML page from URL, title : &quot; + title);          // JSoup Example 3 - Parsing an HTML file in Java          //Document htmlFile = Jsoup.parse(&quot;login.html&quot;, &quot;ISO-8859-1&quot;); // wrong          Document htmlFile = null;          try {              htmlFile = Jsoup.parse(new File(&quot;login.html&quot;), &quot;ISO-8859-1&quot;);          } catch (IOException e) {              // TODO Auto-generated catch block              e.printStackTrace();          } // right          title = htmlFile.title();          Element div = htmlFile.getElementById(&quot;login&quot;);          String cssClass = div.className(); // getting class form HTML element          System.out.println(&quot;Jsoup can also parse HTML file directly&quot;);          System.out.println(&quot;title : &quot; + title);          System.out.println(&quot;class of div tag : &quot; + cssClass);      }  }  </code></pre><p>输出：</p><p>复制代码代码如下:</p><pre><code>Input HTML String to JSoup :&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;JSoup Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;h1&gt;HelloWorld&lt;/h1&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;  After parsing, Title : JSoup Example  Afte parsing, Heading : HelloWorld  Jsoup Can read HTML page from URL, title : Google  Jsoup can also parse HTML file directly title : Login Page  class of div tag : simple  </code></pre><p>Jsoup的好处就是它的健壮性很强。Jsoup HTML解析器会对你提供的HTML进行尽量干净的解析，而不去考虑这个HTML是否是格式良好的。它可以处理如下这些错误：未闭合的标签（比如，Java </p><p>Scala to </p><p>JavaScala)，隐式标签（比如，一个裸的|Java is Great被封装到了|里面），它总能创建出一个文档结构（包含head及body的HTML，并且head里只会包含正确的元素）。这就是在Java中如何进行HTML的解析。Jsoup是一个优秀的健壮的开源库，它使得读取HTML文档，body片段，HTML字符串，以及直接从WEB中解析HTML内容都变得相当简单。在这篇文章中，我们学习了如何在Java中获取一个特定的HTML标签，正如第一个例子中我们将title及H1标签的值提取成了文本，而第三个例子中我们学习到了如何通过提取CSS属性来从HTML标签中获取属性值。除了强大的jQuery风格的html.body().getElementsByTag(“h1”).text()方法，你还可以提取任意的HTML标签，它还提供了像Document.title()和Element.className()这样便捷的方法，你可以快速获取到标题及CSS类。希望JSoup能让你玩得愉快，很快我们将会看到关于这个API的更多的一些例子。</p><p>Jsoup的设计初衷是用于处理现实生活中出现的各种不同的HTML，包括正确有效的HTML以及不完整的无效的标签集合。Jsoup的一个核心竞争力就是它的健壮性。</p><p>转载自 <a href="http://www.jb51.net/article/55620.html" target="_blank" rel="noopener">http://www.jb51.net/article/55620.html</a></p><p>在线文档:<a href="http://www.osctools.net/apidocs/apidoc?api=jsoup-1.6.3;http://jsoup.org/" target="_blank" rel="noopener">http://www.osctools.net/apidocs/apidoc?api=jsoup-1.6.3;http://jsoup.org/</a> </p><pre><code>&lt;!-- lang: java --&gt;String content = &quot;blabla&quot;;Document doc = JSoup.parse(content);Elements links = doc.select(&quot;a[href]&quot;);</code></pre><p>Jsoup还支持白名单过滤机制，对于网站防止XSS攻击也是很好的。</p><ul><li>HtmlParser</li></ul><p>HtmlParser的功能比较完备，也挺灵活，但谈不上方便。这个项目很久没有维护了，最新版本是2.1。HtmlParser的核心元素是Node，对应一个HTML标签，支持getChildren()等树状遍历方式。HtmlParser另外一个核心元素是NodeFilter，通过实现NodeFilter接口，可以对页面元素进行筛选。</p><p>htmlparser是一个纯的java写的html解析的库,它不依赖于其它的java库文件,主要用于改造或提取html。它能超高速解析html,而且不会出错。现在htmlparser最新版本为2.0。 据说htmlparser就是目前最好的html解析和分析的工具。 无论你是想抓取网页数据还是改造html的内容,用了htmlparser绝对会忍不住称赞。</p><p>在线文档:<a href="http://www.osctools.net/apidocs/apidoc?api=HTMLParser[/url];http://htmlparser.sourceforge.net/project-info.html" target="_blank" rel="noopener">http://www.osctools.net/apidocs/apidoc?api=HTMLParser[/url];http://htmlparser.sourceforge.net/project-info.html</a> </p><p>示例代码:<br>    Parser parser = new Parser (“<a href="http://www.dangdang.com&quot;)" target="_blank" rel="noopener">http://www.dangdang.com&quot;)</a>;<br>    NodeList list = parser.parse (null);<br>    Node node = list.elementAt (0);<br>    NodeList sublist = node.getChildren ();<br>    System.out.println (sublist.size ());</p><ul><li>Apache tika</li></ul><p>tika是专为抽取而生的工具，还支持PDF、Zip甚至是Java Class。使用tika分析HTML，需要自己定义一个抽取内容的Handler并继承org.xml.sax.helpers.DefaultHandler，解析方式就是xml标准的方式。crawler4j中就使用了tika作为解析工具。SAX这种流式的解析方式对于分析大文件很有用，我个人倒是认为对于解析html意义不是很大。</p><pre><code>InputStream inputStream = null;HtmlParser htmlParser = new HtmlParser();htmlParser.parse(new ByteArrayInputStream(page.getContentData()), contentHandler, metadata, new ParseContext()); </code></pre><ul><li>HtmlCleaner与XPath</li></ul><p>HtmlCleaner最大的优点是：支持XPath的方式选取元素。XPath是一门在XML中查找信息的语言，也可以用于抽取HTML元素。XPath与CSS Selector大部分功能都是重合的，但是CSS Selector专门针对HTML，写法更简洁，而XPath则是通用的标准，可以精确到属性值。XPath有一定的学习成本，但是对经常需要编写爬虫的人来说，这点投入绝对是值得的。</p><p>学习XPath可以参考w3school的XPath 教程。<br><a href="http://www.w3school.com.cn/xpath/" target="_blank" rel="noopener">http://www.w3school.com.cn/xpath/</a><br>下面是使用HtmlCleaner和xpath进行抽取的一段代码：</p><pre><code>&lt;!-- lang: java --&gt;HtmlCleaner htmlCleaner = new HtmlCleaner();TagNode tagNode = htmlCleaner.clean(text);Object[] objects = tagNode.evaluateXPath(&quot;xpathStr&quot;);</code></pre><ul><li>几个工具的对比</li></ul><p>在这里评价这些工具的主要标准是“方便”。就拿抽取页面所有链接这一基本任务来说，几种代码分别如下：</p><ul><li><p>XPath:</p><pre><code>&lt;!-- lang: java --&gt;tagNode.evaluateXPath(&quot;//a/@href&quot;)</code></pre></li><li><p>CSS Selector:</p><pre><code>&lt;!-- lang: java --&gt;//使用类似js的实现$(&quot;a[href]&quot;).attr(&quot;href&quot;)</code></pre></li><li><p>HtmlParser：</p><pre><code>&lt;!-- lang: java --&gt;Parser p = new Parser(value);NodeFilter aFilter = new TagNameFilter(&quot;a&quot;);NodeList nodes = p.extractAllNodesThatMatch(aFilter);for (int i = 0; i &lt; nodes.size(); i++) {    Node eachNode = nodes.elementAt(i);    if (eachNode instanceof LinkTag) {        LinkTag linkTag = (LinkTag) eachNode;        System.out.println(linkTag.extractLink());    }}</code></pre></li></ul><p>XPath是最简单的，可以精确选取到href属性值；而CSS Selector则次之，可以选取到HTML标签，属性值需要调用函数去获取；而HtmlParser和SAX则需要手动写程序去处理标签了，比较麻烦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;dom解析是常用dom4j。android中我们常用的是sax、pull。因为它们更省内存。而html解析,则也有很多框架&lt;/p&gt;
&lt;p&gt;java的HTML解析通常用在利用java做网页的垂直爬虫&lt;/p&gt;
&lt;p&gt;HTML是WEB的核心，互联网中你看到的所有页面都是HTML，不管它们是由JavaScript，JSP，PHP,ASP或者是别的什么WEB技术动态生成的。你的浏览器会去解析HTML并替你去渲染它们。不过如果你需要自己在Java程序中解析HTML文档并查找某些元素，标签，属性或者检查某个特定的元素是否存在的话，那又该如何呢？如果你已经使用Java编程多年了，我相信你肯定试过去解析XML，也使用过类似DOM或者SAX这样的解析器，不过很有可能你从未进行过任何的HTML解析的工作。更讽刺的是，在Java应用中，很少会有需要你去解析HTML文档的时候，这里并不包括Servlet或者其它的Java WEB技术。更糟糕的是，JDK核心里也没有包括HTTP或者HTML的库，至少我并不知道有这个。这就是为什么一碰上解析HTML文件时，许多Java程序员就得先Google一下 ，看看如何在Java中取出一个HTML的标签。当我有这个需要的时候，我相信肯定会有一些开源库能实现这个，不过我没有想到竟然有JSoup这么酷的并且功能齐全的库。它不仅能支持读取并解析HTML文档，而且还能让你从HTML文件抽取出任何的元素，以及它们的属性，它们的CSS属性，你还能进它们进行修改。有了JSoup你简直可以对HTML文档做任何事情。我们将会看到如何在Java中从google主页或者任何URL中下载并解析HTML文件的示例。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="java类库" scheme="http://yoursite.com/tags/java%E7%B1%BB%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JAVA开发常用类库--邮件</title>
    <link href="http://yoursite.com/2018/03/15/java-api10/"/>
    <id>http://yoursite.com/2018/03/15/java-api10/</id>
    <published>2018-03-15T05:03:15.000Z</published>
    <updated>2018-03-15T05:10:23.032Z</updated>
    
    <content type="html"><![CDATA[<p>所想要看的java邮件相关知识在这里都有，因为作者的权限问题，不好转载。</p><p><a href="http://blog.csdn.net/acmman/article/category/6843840" target="_blank" rel="noopener">http://blog.csdn.net/acmman/article/category/6843840</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;所想要看的java邮件相关知识在这里都有，因为作者的权限问题，不好转载。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/acmman/article/category/6843840&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="java类库" scheme="http://yoursite.com/tags/java%E7%B1%BB%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JAVA开发常用类库--HTTP库</title>
    <link href="http://yoursite.com/2018/03/15/java-api09/"/>
    <id>http://yoursite.com/2018/03/15/java-api09/</id>
    <published>2018-03-15T04:19:21.000Z</published>
    <updated>2018-03-15T04:59:52.073Z</updated>
    
    <content type="html"><![CDATA[<p>我不是很喜欢JDK的一个重要原因就包括他们缺乏对HTTP的支持。虽然可以使用java.net包类，但是这和直接使用像 Apache HttpClient 和 HttpCore 等开源类库比起来麻烦太多了。</p><p>尽管JDK 9将开始HTTP 2.0，也对HTTP的支持做了优化，但是我还是强烈建议所有的Java开发人员熟悉流行的HTTP处理类库，例如HttpClient和HttpCore HTTP等库。</p><a id="more"></a><h1 id="传统的java-net包类"><a href="#传统的java-net包类" class="headerlink" title="传统的java.net包类"></a>传统的java.net包类</h1><p>InetAddress类:表示互联网协议 (IP) 地址</p><p>URL类:代表一个统一资源定位符，它是指向互联网“资源”的指针。</p><p>   资源可以是简单的文件或目录，也可以是对更为复杂的对象的引用，例如对数据库或搜索引擎的查询。</p><p>URLConnection类:用于读取和写入此 URL 引用的资源。</p><p>使用步骤:<br>通过在 URL 上调用 openConnection 方法创建连接对象。<br>处理设置参数和一般请求属性。<br>使用 connect 方法建立到远程对象的实际连接。<br>远程对象变为可用。远程对象的头字段和内容变为可访问。</p><p>DatagramPacket类:此类表示数据报包。</p><p>  数据报包用来实现无连接包投递服务。每条报文仅根据该包中包含的信息从一台机器路由到另一台机器。</p><p>DatagramSocket类:此类表示用来发送和接收数据报包的套接字。</p><p>数据报套接字是包投递服务的发送或接收点。每个在数据报套接字上发送或接收的包都是单独编址和路由的。从一台机<br>器发送到另一台机器的多个包可能选择不同的路由，也可能按不同的顺序到达。</p><ul><li>ServerSocket类:此类实现服务器套接字。</li></ul><p>ServerSocket类主要用在服务器端程序的开发上，用于接收客户端的连接请求</p><p><img src="/2018/03/15/java-api09/p1.png" alt="logo"></p><p>服务器套接字等待请求通过网络传入。它基于该请求执行某些操作，然后可能向请求者返回结果。</p><ul><li>Socket类:此类实现客户端套接字（也可以就叫“套接字”）。</li></ul><p>则是在客户端上运行的，在服务器每次运行时都要使用accept()方法来获取客户端连接，此方法执行之后服务器端将进入阻塞状态，<br>直到客户端连接之后才可以继续向下执行，此方法的返回值类型是Socket，每一个Socket都表示一个客户端对象</p><p>本包中的主线应该是Socket和ServalSocket两个类。将围绕socket和serverSocket的通信而展开。</p><p>首先，如何建立一个客户端和服务器端的通信？</p><p>一、客户端</p><p>1.首先new一个socket（有连接的socket和未连接的socket两种：指定服务器端的ip地址（或主机名）与port号的为连接的，没指定或使用socket（Proxy proxy）的为未连接的）。</p><p>2.设置socket的各项参数：时间？（连接之后还能设置么？)</p><p>3.通过getInputputStream()和getOutputStream()方法得到InputStream和OutputStream流。</p><p>4.操作InputStream和OutputStream流读取或写入数据。</p><p>5.close</p><p>二、服务器端</p><p>1.首先new一个serverSocket（有绑定的serverSocket和未绑定的serverSocket两种：指定服务器端的Port号为绑定的，未指定的为未绑定的）。</p><p>2.设置serverSocket的各项参数：buffersize？</p><p>3.调用accept()方法获得一个和客户端连接的Socket。</p><p>4.通过getInputputStream()和getOutputStream()方法得到InputStream和OutputStream流。</p><p>5.close</p><p>通过以上步骤我们基本上就建立起了客户端和服务器端的通信链路。然后我们讲讲关于Socket和ServerSocket参数设置的问题。</p><p>本文的第二个主线是DatagramSocket和DatagramPacket两个类。</p><p>首先，如何通过UDP协议建立一个客户端和服务器端的通信？</p><p>一、客户端</p><p>1.首先new 一个DatagramSocket（有绑定的DatagramSocket和未绑定的DatagramSocket两种：需指定本地的ip地址和port号，DatagramSocket(SocketAddress localAddr)如果localAddr未null，则为未绑定）。</p><p>2,new一个DatagramPacket实例（需指定主机地址和端口号），填充数据，将其传递给DatagramSocket的send方法。</p><p>3.接收数据时将DatagramPacket实例传递给DatagramSocket的receive方法。</p><p>3,close</p><p>二、服务器端</p><p>其实本质和客户端一样的。</p><p>示例：</p><pre><code>import java.io.BufferedReader;  import java.io.IOException;  import java.io.InputStreamReader;  import java.io.PrintWriter;  import java.net.URL;  import java.net.URLConnection;  import java.util.List;  import java.util.Map;  /**  * @Title   SendRequestUtils.java  * @Package com.pro.huanbao.common.utils  * @author  wanpu_ly  * @dade    2017年10月13日 上午8:43:42  * @version V1.0  * 类说明:   */  public class SendRequestUtils {      /**      * 向指定URL发送GET方法的请求      *       * @param url      *            发送请求的URL      * @param param      *            请求参数，请求参数应该是 name1=value1&amp;name2=value2 的形式。      * @return URL 所代表远程资源的响应结果      */      public static String sendGet(String url, String param) {          String result = &quot;&quot;;          BufferedReader in = null;          try {              String urlNameString = url + &quot;?&quot; + param;              if (param == null) {                  urlNameString = url;              }              URL realUrl = new URL(urlNameString);              // 打开和URL之间的连接              URLConnection connection = realUrl.openConnection();              // 设置通用的请求属性              connection.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;);              connection.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;);              connection.setRequestProperty(&quot;user-agent&quot;,                      &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)&quot;);              // 建立实际的连接              connection.connect();              // 获取所有响应头字段              Map&lt;String, List&lt;String&gt;&gt; map = connection.getHeaderFields();              // 遍历所有的响应头字段              for (String key : map.keySet()) {                  System.out.println(key + &quot;---&gt;&quot; + map.get(key));              }              // 定义 BufferedReader输入流来读取URL的响应              in = new BufferedReader(new InputStreamReader(                      connection.getInputStream()));              String line;              while ((line = in.readLine()) != null) {                  result += line;              }          } catch (Exception e) {              System.out.println(&quot;发送GET请求出现异常！&quot; + e);              e.printStackTrace();          }          // 使用finally块来关闭输入流          finally {              try {                  if (in != null) {                      in.close();                  }              } catch (Exception e2) {                  e2.printStackTrace();              }          }          return result;      }      /**       * 向指定 URL 发送POST方法的请求       *        * @param url       *            发送请求的 URL       * @param param       *            请求参数，请求参数应该是 name1=value1&amp;name2=value2 的形式。       * @return 所代表远程资源的响应结果       */      public static String sendPost(String url, String param) {          PrintWriter out = null;          BufferedReader in = null;          String result = &quot;&quot;;          try {              URL realUrl = new URL(url);              // 打开和URL之间的连接              URLConnection conn = realUrl.openConnection();              // 设置通用的请求属性              conn.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;);              conn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;);              conn.setRequestProperty(&quot;user-agent&quot;,                      &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)&quot;);              // 发送POST请求必须设置如下两行              conn.setDoOutput(true);              conn.setDoInput(true);              // 获取URLConnection对象对应的输出流              out = new PrintWriter(conn.getOutputStream());              // 发送请求参数              out.print(param);              // flush输出流的缓冲              out.flush();              // 定义BufferedReader输入流来读取URL的响应              in = new BufferedReader(                      new InputStreamReader(conn.getInputStream()));              String line;              while ((line = in.readLine()) != null) {                  result += line;              }          } catch (Exception e) {              System.out.println(&quot;发送 POST 请求出现异常！&quot;+e);              e.printStackTrace();          }          //使用finally块来关闭输出流、输入流          finally{              try{                  if(out!=null){                      out.close();                  }                  if(in!=null){                      in.close();                  }              }              catch(IOException ex){                  ex.printStackTrace();              }          }          return result;      }    }  </code></pre><p>不过由于java.net的局限性和性能上的不足，基本上开发互联网产品的时候不会用到</p><p>接下来介绍一些第三方流行的Http库</p><h1 id="apache的httpclient工具类"><a href="#apache的httpclient工具类" class="headerlink" title="apache的httpclient工具类"></a>apache的httpclient工具类</h1><p>示例：</p><pre><code>package org.egg.utils;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.entity.StringEntity;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.nio.charset.Charset;/** * @author dataochen * @Description * @date: 2017/11/7 17:49 */public class HttpRequestUtil {    private static CloseableHttpClient httpClient;    static {        PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();        cm.setMaxTotal(100);        cm.setDefaultMaxPerRoute(20);        cm.setDefaultMaxPerRoute(50);        httpClient = HttpClients.custom().setConnectionManager(cm).build();    }    public static String get(String url) {        CloseableHttpResponse response = null;        BufferedReader in = null;        String result = &quot;&quot;;        try {            HttpGet httpGet = new HttpGet(url);            RequestConfig requestConfig = RequestConfig.custom().setConnectTimeout(30000).setConnectionRequestTimeout(30000).setSocketTimeout(30000).build();            httpGet.setConfig(requestConfig);            httpGet.setConfig(requestConfig);            httpGet.addHeader(&quot;Content-type&quot;, &quot;application/json; charset=utf-8&quot;);            httpGet.setHeader(&quot;Accept&quot;, &quot;application/json&quot;);            response = httpClient.execute(httpGet);            in = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));            StringBuffer sb = new StringBuffer(&quot;&quot;);            String line = &quot;&quot;;            String NL = System.getProperty(&quot;line.separator&quot;);            while ((line = in.readLine()) != null) {                sb.append(line + NL);            }            in.close();            result = sb.toString();        } catch (IOException e) {            e.printStackTrace();        } finally {            try {                if (null != response) {                    response.close();                }            } catch (IOException e) {                e.printStackTrace();            }        }        return result;    }    public static String post(String url, String jsonString) {        CloseableHttpResponse response = null;        BufferedReader in = null;        String result = &quot;&quot;;        try {            HttpPost httpPost = new HttpPost(url);            RequestConfig requestConfig = RequestConfig.custom().setConnectTimeout(30000).setConnectionRequestTimeout(30000).setSocketTimeout(30000).build();            httpPost.setConfig(requestConfig);            httpPost.setConfig(requestConfig);            httpPost.addHeader(&quot;Content-type&quot;, &quot;application/json; charset=utf-8&quot;);            httpPost.setHeader(&quot;Accept&quot;, &quot;application/json&quot;);            httpPost.setEntity(new StringEntity(jsonString, Charset.forName(&quot;UTF-8&quot;)));            response = httpClient.execute(httpPost);            in = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));            StringBuffer sb = new StringBuffer(&quot;&quot;);            String line = &quot;&quot;;            String NL = System.getProperty(&quot;line.separator&quot;);            while ((line = in.readLine()) != null) {                sb.append(line + NL);            }            in.close();            result = sb.toString();        } catch (IOException e) {            e.printStackTrace();        } finally {            try {                if (null != response) {                    response.close();                }            } catch (IOException e) {                e.printStackTrace();            }        }        return result;    }}</code></pre><p>代码所用jar包maven坐标：<br><!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpclient --><br>    <dependency><br>        <groupid>org.apache.httpcomponents</groupid><br>        <artifactid>httpclient</artifactid><br>        <version>4.5.3</version><br>    </dependency><br><!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpcore --><br>    <dependency><br>        <groupid>org.apache.httpcomponents</groupid><br>        <artifactid>httpcore</artifactid><br>        <version>4.4.8</version><br>    </dependency></p><p>Http协议的重要性相信不用我多说了，HttpClient相比传统JDK自带的URLConnection，增加了易用性和灵活性（具体区别，日后我们再讨论），它不仅是客户端发送Http请求变得容易，而且也方便了开发人员测试接口（基于Http协议的），即提高了开发的效率，也方便提高代码的健壮性。因此熟练掌握HttpClient是很重要的必修内容，掌握HttpClient后，相信对于Http协议的了解会更加深入。</p><p>一、简介<br>HttpClient是Apache Jakarta Common下的子项目，用来提供高效的、最新的、功能丰富的支持HTTP协议的客户端编程工具包，并且它支持HTTP协议最新的版本和建议。HttpClient已经应用在很多的项目中，比如Apache Jakarta上很著名的另外两个开源项目Cactus和HTMLUnit都使用了HttpClient。</p><p>二、特性</p><ol><li>基于标准、纯净的java语言。实现了Http1.0和Http1.1</li><li>以可扩展的面向对象的结构实现了Http全部的方法（GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE）。</li><li>支持HTTPS协议。</li><li>通过Http代理建立透明的连接。</li><li>利用CONNECT方法通过Http代理建立隧道的https连接。</li><li>Basic, Digest, NTLMv1, NTLMv2, NTLM2 Session, SNPNEGO/Kerberos认证方案。</li><li>插件式的自定义认证方案。</li><li>便携可靠的套接字工厂使它更容易的使用第三方解决方案。</li><li>连接管理器支持多线程应用。支持设置最大连接数，同时支持设置每个主机的最大连接数，发现并关闭过期的连接。</li><li>自动处理Set-Cookie中的Cookie。</li><li>插件式的自定义Cookie策略。</li><li>Request的输出流可以避免流中内容直接缓冲到socket服务器。</li><li>Response的输入流可以有效的从socket服务器直接读取相应内容。</li><li>在http1.0和http1.1中利用KeepAlive保持持久连接。</li><li>直接获取服务器发送的response code和 headers。</li><li>设置连接超时的能力。</li><li>实验性的支持http1.1 response caching。</li><li>源代码基于Apache License 可免费获取</li></ol><p>三、使用方法<br>   Mavn坐标<br>Java代码  收藏代码<br>    <dependency><br>        <groupid>org.apache.httpcomponents</groupid><br>        <artifactid>httpclient</artifactid><br>        <version>4.3.4</version><br>    </dependency>  </p><p>使用HttpClient发送请求、接收响应很简单，一般需要如下几步即可。</p><ol><li>创建HttpClient对象。</li><li>创建请求方法的实例，并指定请求URL。如果需要发送GET请求，创建HttpGet对象；如果需要发送POST请求，创建HttpPost对象。</li><li>如果需要发送请求参数，可调用HttpGet、HttpPost共同的setParams(HetpParams params)方法来添加请求参数；对于HttpPost对象而言，也可调用setEntity(HttpEntity entity)方法来设置请求参数。</li><li>调用HttpClient对象的execute(HttpUriRequest request)发送请求，该方法返回一个HttpResponse。</li><li>调用HttpResponse的getAllHeaders()、getHeaders(String name)等方法可获取服务器的响应头；调用HttpResponse的getEntity()方法可获取HttpEntity对象，该对象包装了服务器的响应内容。程序可通过该对象获取服务器的响应内容。</li><li>释放连接。无论执行方法是否成功，都必须释放连接</li></ol><p>四.post跟get请求示例<br>Java代码  收藏代码<br>    package com.ickes;  </p><pre><code>import java.util.ArrayList;  import java.util.List;  import org.apache.http.HttpEntity;  import org.apache.http.NameValuePair;  import org.apache.http.client.entity.UrlEncodedFormEntity;  import org.apache.http.client.methods.CloseableHttpResponse;  import org.apache.http.client.methods.HttpGet;  import org.apache.http.client.methods.HttpPost;  import org.apache.http.entity.StringEntity;  import org.apache.http.impl.client.CloseableHttpClient;  import org.apache.http.impl.client.HttpClients;  import org.apache.http.message.BasicNameValuePair;  import org.apache.http.protocol.HTTP;  import org.apache.http.util.EntityUtils;  public class HttpClientDemo {      public static void main(String[] args) throws Exception  {           get();      }      /**      * post方式提交json代码      * @throws Exception       */      public static void postJson() throws Exception{          //创建默认的httpClient实例.           CloseableHttpClient httpclient = null;          //接收响应结果          CloseableHttpResponse response = null;          try {              //创建httppost              httpclient = HttpClients.createDefault();                String url =&quot;http://192.168.16.36:8081/goSearch/gosuncn/deleteDocs.htm&quot;;              HttpPost httpPost = new HttpPost(url);              httpPost.addHeader(HTTP.CONTENT_TYPE,&quot;application/x-www-form-urlencoded&quot;);              //参数              String json =&quot;{&apos;ids&apos;:[&apos;html1&apos;,&apos;html2&apos;]}&quot;;              StringEntity se = new StringEntity(json);              se.setContentEncoding(&quot;UTF-8&quot;);              se.setContentType(&quot;application/json&quot;);//发送json需要设置contentType              httpPost.setEntity(se);              response = httpclient.execute(httpPost);              //解析返结果              HttpEntity entity = response.getEntity();               if(entity != null){                  String resStr = EntityUtils.toString(entity, &quot;UTF-8&quot;);                      System.out.println(resStr);              }          } catch (Exception e) {              throw e;          }finally{              httpclient.close();              response.close();          }      }       /**       * post方式提交表单（模拟用户登录请求）       * @throws Exception       */        public static void postForm() throws Exception  {            // 创建默认的httpClient实例.              CloseableHttpClient httpclient = null;          //发送请求          CloseableHttpResponse response = null;          try {              httpclient = HttpClients.createDefault();                // 创建httppost                  String url= &quot;http://localhost:8080/search/ajx/user.htm&quot;;              HttpPost httppost = new HttpPost(url);                // 创建参数队列                  List&lt;NameValuePair&gt; formparams = new ArrayList&lt;NameValuePair&gt;();                formparams.add(new BasicNameValuePair(&quot;username&quot;, &quot;admin&quot;));                formparams.add(new BasicNameValuePair(&quot;password&quot;, &quot;123456&quot;));              //参数转码              UrlEncodedFormEntity uefEntity = new UrlEncodedFormEntity(formparams, &quot;UTF-8&quot;);                httppost.setEntity(uefEntity);               response = httpclient.execute(httppost);                HttpEntity entity = response.getEntity();                if (entity != null) {                      System.out.println(EntityUtils.toString(entity, &quot;UTF-8&quot;));                }                //释放连接          } catch (Exception e) {              throw e;          }finally{               httpclient.close();               response.close();          }      }        /**       * 发送 get请求       * @throws Exception       */        public static void get() throws Exception {            CloseableHttpClient httpclient = null;          CloseableHttpResponse response = null;          try {              httpclient = HttpClients.createDefault();                // 创建httpget.                  HttpGet httpget = new HttpGet(&quot;http://www.baidu.com/&quot;);                // 执行get请求.                  response = httpclient.execute(httpget);                // 获取响应实体                  HttpEntity entity = response.getEntity();                // 打印响应状态                  System.out.println(response.getStatusLine().getStatusCode());                if (entity != null) {                    // 打印响应内容                      System.out.println(&quot;Response content: &quot; + EntityUtils.toString(entity));                }          } catch (Exception e) {              throw e;          }finally{              httpclient.close();              response.close();          }      }  }  </code></pre><p>五、SSL跟上传文件实例</p><p>Java代码  收藏代码<br>    package com.test;  </p><pre><code>import java.io.File;  import java.io.FileInputStream;  import java.io.IOException;  import java.io.UnsupportedEncodingException;  import java.security.KeyManagementException;  import java.security.KeyStore;  import java.security.KeyStoreException;  import java.security.NoSuchAlgorithmException;  import java.security.cert.CertificateException;  import java.util.ArrayList;  import java.util.List;  import javax.net.ssl.SSLContext;  import org.apache.http.HttpEntity;  import org.apache.http.NameValuePair;  import org.apache.http.ParseException;  import org.apache.http.client.ClientProtocolException;  import org.apache.http.client.entity.UrlEncodedFormEntity;  import org.apache.http.client.methods.CloseableHttpResponse;  import org.apache.http.client.methods.HttpGet;  import org.apache.http.client.methods.HttpPost;  import org.apache.http.conn.ssl.SSLConnectionSocketFactory;  import org.apache.http.conn.ssl.SSLContexts;  import org.apache.http.conn.ssl.TrustSelfSignedStrategy;  import org.apache.http.entity.ContentType;  import org.apache.http.entity.mime.MultipartEntityBuilder;  import org.apache.http.entity.mime.content.FileBody;  import org.apache.http.entity.mime.content.StringBody;  import org.apache.http.impl.client.CloseableHttpClient;  import org.apache.http.impl.client.HttpClients;  import org.apache.http.message.BasicNameValuePair;  import org.apache.http.util.EntityUtils;  import org.junit.Test;  public class HttpClientTest {      @Test      public void jUnitTest() {          ssl();      }      /**      * HttpClient连接SSL      */      public void ssl() {          CloseableHttpClient httpclient = null;          try {              KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());              FileInputStream instream = new FileInputStream(new File(&quot;d:\\tomcat.keystore&quot;));              try {                  // 加载keyStore d:\\tomcat.keystore                    trustStore.load(instream, &quot;123456&quot;.toCharArray());              } catch (CertificateException e) {                  e.printStackTrace();              } finally {                  try {                      instream.close();                  } catch (Exception ignore) {                  }              }              // 相信自己的CA和所有自签名的证书              SSLContext sslcontext = SSLContexts.custom().loadTrustMaterial(trustStore, new TrustSelfSignedStrategy()).build();              // 只允许使用TLSv1协议              SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslcontext, new String[] { &quot;TLSv1&quot; }, null,                      SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);              httpclient = HttpClients.custom().setSSLSocketFactory(sslsf).build();              // 创建http请求(get方式)              HttpGet httpget = new HttpGet(&quot;https://localhost:8443/myDemo/Ajax/serivceJ.action&quot;);              System.out.println(&quot;executing request&quot; + httpget.getRequestLine());              CloseableHttpResponse response = httpclient.execute(httpget);              try {                  HttpEntity entity = response.getEntity();                  System.out.println(&quot;----------------------------------------&quot;);                  System.out.println(response.getStatusLine());                  if (entity != null) {                      System.out.println(&quot;Response content length: &quot; + entity.getContentLength());                      System.out.println(EntityUtils.toString(entity));                      EntityUtils.consume(entity);                  }              } finally {                  response.close();              }          } catch (ParseException e) {              e.printStackTrace();          } catch (IOException e) {              e.printStackTrace();          } catch (KeyManagementException e) {              e.printStackTrace();          } catch (NoSuchAlgorithmException e) {              e.printStackTrace();          } catch (KeyStoreException e) {              e.printStackTrace();          } finally {              if (httpclient != null) {                  try {                      httpclient.close();                  } catch (IOException e) {                      e.printStackTrace();                  }              }          }      }      /**      * 上传文件      */      public void upload() {          CloseableHttpClient httpclient = HttpClients.createDefault();          try {              HttpPost httppost = new HttpPost(&quot;http://localhost:8080/myDemo/Ajax/serivceFile.action&quot;);              FileBody bin = new FileBody(new File(&quot;F:\\image\\sendpix0.jpg&quot;));              StringBody comment = new StringBody(&quot;A binary file of some kind&quot;, ContentType.TEXT_PLAIN);              HttpEntity reqEntity = MultipartEntityBuilder.create().addPart(&quot;bin&quot;, bin).addPart(&quot;comment&quot;, comment).build();              httppost.setEntity(reqEntity);              System.out.println(&quot;executing request &quot; + httppost.getRequestLine());              CloseableHttpResponse response = httpclient.execute(httppost);              try {                  System.out.println(&quot;----------------------------------------&quot;);                  System.out.println(response.getStatusLine());                  HttpEntity resEntity = response.getEntity();                  if (resEntity != null) {                      System.out.println(&quot;Response content length: &quot; + resEntity.getContentLength());                  }                  EntityUtils.consume(resEntity);              } finally {                  response.close();              }          } catch (ClientProtocolException e) {              e.printStackTrace();          } catch (IOException e) {              e.printStackTrace();          } finally {              try {                  httpclient.close();              } catch (IOException e) {                  e.printStackTrace();              }          }      }  }  </code></pre><p>   本实例是采用HttpClient4.3最新版本。该版本与之前的代码写法风格相差较大，大家多留意下。</p><p>参考：<a href="http://blog.csdn.net/wangpeng047/article/details/19624529" target="_blank" rel="noopener">http://blog.csdn.net/wangpeng047/article/details/19624529</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我不是很喜欢JDK的一个重要原因就包括他们缺乏对HTTP的支持。虽然可以使用java.net包类，但是这和直接使用像 Apache HttpClient 和 HttpCore 等开源类库比起来麻烦太多了。&lt;/p&gt;
&lt;p&gt;尽管JDK 9将开始HTTP 2.0，也对HTTP的支持做了优化，但是我还是强烈建议所有的Java开发人员熟悉流行的HTTP处理类库，例如HttpClient和HttpCore HTTP等库。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="java类库" scheme="http://yoursite.com/tags/java%E7%B1%BB%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JAVA开发常用类库--消息传递库</title>
    <link href="http://yoursite.com/2018/03/14/java-api08/"/>
    <id>http://yoursite.com/2018/03/14/java-api08/</id>
    <published>2018-03-14T08:23:02.000Z</published>
    <updated>2018-03-15T04:21:22.759Z</updated>
    
    <content type="html"><![CDATA[<p>像日志和数据库连接池一样，消息传递也是很多实际的Java项目中必备的。Java提供了JMS Java消息服务，但这不是JDK的一部分,你需要单独的引入jms.jar。类似地，如果您准备使用第三方消息传递协议， Tibco RV 是个不错的选择。</p><p>1、问： 什么是 Java 消息服务？<br>答: Java 消息服务(Java Message Service，JMS) API 是一个用于访问企业消息传递系统的 API。是 Java 2 Platform, Enterprise（J2EE）的一部分。</p><a id="more"></a><p>2、目前流行的消息传送产品有哪些？<br>答：目前流行的有ActiveMQ、IBM WebSphere MQ、SonicMQ等</p><p>3、什么时候可以用到java消息机制？<br>答 （1）异构系统集成，整合现有资源，提高资源的利用率<br>   （2）异步请求处理，减轻或消除系统瓶颈，提高用户生产率和系统的整体可伸缩性<br>   （3）组件解偶，增加系统的灵活性</p><p>4、消息传送的两种模型<br>发布/订阅模型<br>客户端发送消息到一个名为主题（topic）的虚拟通道中，每个订阅该主题的消费者都会接收到每条消息的一个副本。<br>点对点模型<br>客户端通过队列（queue）这个虚拟通道来同步和异步发送、接收消息，发送到队列的消息只能被一个接收者所接收，即使有多个消费者时也只能有一个消费者处理消息</p><p>5、JMS包含哪些接口？<br>JMS API可以分为3个主要部分：公共API、点对点API和发布/订阅API。在JMS1.1中，公共API可被用于向一个队列或一个主题发送消息，或从其中接收消息。点对点API专门用于使用队列的消息传送，而发布/订阅API则专门用于使用主题的消息传送。<br>在JMS公共API内部，和发送和接收JMS消息有关的JMS API接口主要有7个：</p><ul><li>ConnectionFactory</li><li>Destination</li><li>Connection</li><li>Session</li><li>Message</li><li>MessageProducer</li><li>MessageConsumer</li></ul><p>在这些公共接口中，ConnectionFactory和Destination必须使用JNDI（遵照JMS规范要求）从提供者处获得。其他接口则可以通过工厂方法在不同的API接口中创建。举例来说，一旦有了一个ConnectionFactory，就可以创建一个 Connection。一旦有了一个Connection，就可以创建一个Session。而一旦有了一个Session，就可以创建一个 Message、MessageProducer和MessageConsumer。这7个主要的JMS公共API接口之间的关系如图1-5所示。<br>在JMS中，是Session对象保存着用于消息传送的事务性工作单元（transactional unit），而不是Connection对象。这和JDBC不同，JDBC中是Connection对象保存事务性工作单元。这就意味着在使用JMS时，一个应用程序通常只会有一个Connection对象，但是它可以有一个Session对象池。<br>另外，还有和异常处理、消息优先级及消息持久性有关的其他接口</p><p>6、java消息分为哪些部分？<br>消息头、消息属性、消息自身</p><p>7、消息过滤<br>消息订阅者需要对消息进行过滤，否则订阅者就会接受到主题或队列的每一条消息，浪费了不必要的资源（CPU、内存等），而使用消息过滤技术，能让订阅者只接受它需要的消息。（消息过滤对于队列消费尤其重要，因为一个队列消费者消费消息后其他消费者就不再可用，此时如果不对消息进行过滤处理，这条消息就很可能被浪费掉）。<br>消息选择器使用消息属性和消息头作为条件表达式的传送载体（消息体不能作为消息选择器的参考对象）。<br>消息选择器由标识符、常量和比较运算符组成：<br>例：<br> 创建一个消息如下：<br>TextMessage textMessage = Session.createTextMessage();<br> textMessage.setText(“mytestMsg”);<br> textMessage.setStringProperty(“city”,”hangzhou”);<br> textMessage.setStringProperty(“company”,”mycompany”);<br> 这条消息中设置的消息属性名“city”和“company”代表消息选择器的标识符，”hangzhou”和”mycompany”代表常量</p><p>  在消费端创建一个选择器：<br>  String selector = “city = ‘hangzhou’ AND company=’mycompany’”;<br>  QueueReceiver qReceiver = qSession.createReceiver(testQ,selector);<br>  其中“=”和“AND”为比较运算符，其他常用比较运算符还有：<br>  算数比较运算符（=、&gt;、&lt;、&lt;=、&lt;&gt;等）<br>  like运算符、BETWEEN运算符、IN运算符、IS NULL运算符等</p><p>8 、消息过滤</p><p>消息订阅者需要对消息进行过滤，否则订阅者就会接受到主题或队列的每一条消息，浪费了不必要的资源（ CPU、内存等），而使用消息过滤技术，能让订阅者只接受它需要的消息。（消息过滤对于队列消费尤其重要，因为一个队列消费者消费消息后其他消费者就不再可用，此时如果不对消息进行过滤处理，这条消息就很可能被浪费掉）。</p><p>消息选择器使用消息属性和消息头作为条件表达式的传送载体（消息体不能作为消息选择器的参考对象）。</p><p>消息选择器由标识符、常量和比较运算符组成：</p><p>例：</p><p>创建一个消息如下：</p><p>TextMessage textMessage = Session.createTextMessage();</p><p> textMessage.setText(“mytestMsg”);</p><p>  textMessage.setStringProperty(“city”,”hangzhou”);</p><p> textMessage.setStringProperty(“company”,”alibaba”);</p><p> 这条消息中设置的消息属性名 “city” 和 “company” 代表消息选择器的标识符， ”hangzhou” 和 ”alibaba”代表常量</p><p>  在消费端创建一个选择器：</p><p>  String selector = “city = ‘hangzhou’ AND company=’alibaba’ ”;</p><p>  QueueReceiver qReceiver = qSession.createReceiver(testQ,selector);</p><p>  其中 “=” 和 “AND” 为比较运算符，其他常用比较运算符还有：</p><p>  算数比较运算符（ = 、 &gt; 、 &lt; 、 &lt;= 、 &lt;&gt; 等）</p><p>  like 运算符、 BETWEEN 运算符、 IN 运算符、 IS NULL 运算符等</p><p>9 、消息传送的可靠性</p><p>在消息的传送过程中由于网络、软硬件故障等都会导致消息的发送失败， jms 为保证消息的传送定义了 3 条法则：</p><p>（ 1 ）消息自主性，消息是自包含的自主性实体，当发送端发出这条消息后这条消息就不再受发送端的限制，它可以在多个进程间被多次发送。</p><p>（ 2 ）存储转发，当消息被标记位持久性消息时，就由 jms 提供者利用 “ 保存并转发 ” 机制，将消息保存在可信的介质上，防止发生故障时仍然可以正常恢复</p><p>（ 3 ）消息确认机制，服务器确认已经从发送端收到了消息，消费者则从确认从服务器接收了消息，对消息传送过程的监控，保证了消息的可靠传送。 消息确认的 3 种模式：</p><p>1 、 AUTO_ACKNOWLEDGE<br>从消息生产者角度：发送消息后就开始阻塞，直到从消息服务器收到回复，期间如发生异常则认为消息未被传送   </p><p>从消息服务器角度：非持久消息在接受到消息后通知生产者，并将消息存入内存，持久性消息在接受道消息后先存入磁盘，然后通知生产者   </p><p>从消费者角度：接受到消息后就向服务器发送确认信息，如果服务器没有收到确认，会重新发送   </p><p>2 、 CLIENT_ACKNOWLEDGE<br>消费者可在处理完业务逻辑后在代码重显示调用 message.acknowledge() 通知 jms 提供者已成功接收道消息<br>3 、 DUPS_ACKNOWLEDGE<br>可将一条消息向同一目的地发送两次以上  </p><p>这里介绍两个概念：</p><p>（ 1 ）持久化消息：消息持久化就是在发送者将消息发送出去后，消息中心首先将消息存储到本地数据文件、内存数据库或者远程数据库等，然后试图将消息发送给接收 者，发送成功则将消息从存储中删除，失败则继续尝试。消息中心启动以后首先要检查制定的存储位置，如果有未发送成功的消息，则需要把消息发送出去。通过在消息头设置来实现：如</p><pre><code>MessageProducer producer = session.createProducer(destination);producer.setDeliveryMode(DeliveryMode.PERSISTENT);</code></pre><p>(2) 持久订阅者和非持久订阅者：非持久订阅者是指某个订阅者由于某种原因停止运行，那么在停止运行期间发布到该订阅者所订阅主题的消息就会无法获得，持久订阅者则刚好相反，持久订阅者会接收发送到订阅主题的所有消息，无论订阅者是否正常运行，电子邮件就是类似的一个例子。</p><p>持久化消息和持久订阅者在服务器和消费者端之间的消息传送保证机制比较类似，但在有一种情况下他们还是存在区别的，对持久订阅者来说，当消息服务器向发送者发送确认消息之后，并为当前未运行的持久订阅者将消息保存到介质之间如果发送故障，该消息就会丢失，而持久化消息则是先保存消息道介质，然后才向发送者发送确认消息，所以不存在这个问题，因此严格来说持久化消息的可靠性会更高。</p><p>10 、事务性消息</p><p>jms 事务性保证了一组发送的消息或接收的消息要么全部成功要么全部失败，概念上和我们在java 中使用的jta 相似，但jms 事务是由jms 提供者来管理的，而不是jta 。</p><p>使用方法如下：</p><p>   // 此处用true ，表示使用事务性消息</p><pre><code>Session session =connection.createSession(true, Session.AUTO_ACKNOWLEDGE);</code></pre><p>// 用来发送的3 个消息</p><pre><code>MessageProducer sender = session.createProducer(“queue/testQueue”);try{    TextMessage message1 = session.createTextMessage(“ 要发送的消息1”);　　    sender.send(message);    TextMessage message2 = session.createTextMessage(“ 要发送的消息2”);　　    sender.send(message);    TextMessage message3 = session.createTextMessage(“ 要发送的消息3”);　　    sender.send(message);        session.commit();    }catch(Exception e){        try{          session.rollback();       }catch(JMSException e){       }    }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;像日志和数据库连接池一样，消息传递也是很多实际的Java项目中必备的。Java提供了JMS Java消息服务，但这不是JDK的一部分,你需要单独的引入jms.jar。类似地，如果您准备使用第三方消息传递协议， Tibco RV 是个不错的选择。&lt;/p&gt;
&lt;p&gt;1、问： 什么是 Java 消息服务？&lt;br&gt;答: Java 消息服务(Java Message Service，JMS) API 是一个用于访问企业消息传递系统的 API。是 Java 2 Platform, Enterprise（J2EE）的一部分。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="java类库" scheme="http://yoursite.com/tags/java%E7%B1%BB%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JAVA开发常用类库--字节码库</title>
    <link href="http://yoursite.com/2018/03/14/java-api07/"/>
    <id>http://yoursite.com/2018/03/14/java-api07/</id>
    <published>2018-03-14T04:18:19.000Z</published>
    <updated>2018-03-14T09:39:45.962Z</updated>
    
    <content type="html"><![CDATA[<p>也许你写了无数行的代码，也许你能非常溜的使用高级语言，但是你未必了解那些高级语言的执行过程。例如大行其道的Java。</p><p>Java号称是一门“一次编译到处运行”的语言，但是我们对这句话的理解深度又有多少呢？从我们写的java文件到通过编译器编译成java字节码文件（也就是.class文件），这个过程是java编译过程；而我们的java虚拟机执行的就是字节码文件。不论该字节码文件来自何方，由哪种编译器编译，甚至是手写字节码文件，只要符合java虚拟机的规范，那么它就能够执行该字节码文件。那么本文主要讲讲java字节码文件相关知识。接下来我们通过具体的Demo来深入理解：</p><a id="more"></a><h1 id="首先我们来写一个java源文件"><a href="#首先我们来写一个java源文件" class="headerlink" title="首先我们来写一个java源文件"></a>首先我们来写一个java源文件</h1><p><img src="/2018/03/14/java-api07/p1.png" alt="logo"></p><p>上面是我们写的一个java程序，很简单，只有一个成员变量a以及一个方法testMethod() 。</p><p>接下来我们用javac命令或者ide工具将该java源文件编译成java字节码文件。</p><p><img src="/2018/03/14/java-api07/p2.png" alt="logo"></p><p>上图是编译好的字节码文件，我们可以看到一堆16进制的字节。如果你使用IDE去打开，也许看到的是已经被反编译的我们所熟悉的java代码，而这才是纯正的字节码，这也是我们今天需要讲的内容重点。</p><p>也许你会对这样一堆字节码感到头疼，不过没关系，我们慢慢试着你看懂它，或许有不一样的收获。在开始之前我们先来看一张图</p><p><img src="/2018/03/14/java-api07/p3.png" alt="logo"></p><p>这张图是一张java字节码的总览图，我们也就是按照上面的顺序来对字节码进行解读的。一共含有10部分，包含魔数，版本号，常量池等等，接下来我们按照顺序一步一步解读。</p><h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><p>从上面的总览图中我们知道前4个字节表示的是魔数，对应我们Demo的是 0XCAFE BABE。什么是魔数？魔数是用来区分文件类型的一种标志，一般都是用文件的前几个字节来表示。比如0XCAFE BABE表示的是class文件，那么有人会问，文件类型可以通过文件名后缀来判断啊？是的，但是文件名是可以修改的（包括后缀），那么为了保证文件的安全性，讲文件类型写在文件内部来保证不被篡改。<br>从java的字节码文件类型我们看到，CAFE BABE翻译过来是咖啡宝贝之意，然后再看看java图标。</p><p>CAFE BABE = 咖啡。</p><p><img src="/2018/03/14/java-api07/p4.png" alt="logo"></p><h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><p>我们识别了文件类型之后，接下来要知道版本号。版本号含主版本号和次版本号，都是各占2个字节。在此Demo种为0X0000 0033。其中前面的0000是次版本号，后面的0033是主版本号。通过进制转换得到的是次版本号为0，主版本号为51。<br>从oracle官方网站我们能够知道，51对应的正式jdk1.7，而其次版本为0，所以该文件的版本为1.7.0。如果需要验证，可以在用java –version命令输出版本号，或者修改编译目标版本–target重新编译，查看编译后的字节码文件版本号是否做了相应的修改。</p><p>至此，我们共了解了前8字节的含义，下面讲讲常量池相关内容。</p><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>紧接着主版本号之后的就是常量池入口。常量池是Class文件中的资源仓库，在接下来的内容中我们会发现很多地方会涉及，如Class Name，Interfaces等。常量池中主要存储2大类常量：字面量和符号引用。字面量如文本字符串，java中声明为final的常量值等等，而符号引用如类和接口的全局限定名，字段的名称和描述符，方法的名称和描述符。</p><p>为什么需要类和接口的全局限定名呢？系统引用类或者接口的时候不是通过内存地址进行操作吗？这里大家仔细想想，java虚拟机在没有将类加载到内存的时候根本都没有分配内存地址，也就不存在对内存的操作，所以java虚拟机首先需要将类加载到虚拟机中，那么这个过程设计对类的定位（需要加载A包下的B类，不能加载到别的包下面的别的类中），所以需要通过全局限定名来判别唯一性。这就是为什么叫做全局，限定的意思，也就是唯一性。</p><p>在进行具体常量池分析之前，我们先来了解一下常量池的项目类型表：</p><p><img src="/2018/03/14/java-api07/p5.png" alt="logo"></p><p>上面的表中描述了11中数据类型的结构，其实在jdk1.7之后又增加了3种（CONSTANT_MethodHandle_info,CONSTANT_MethodType_info以及CONSTANT_InvokeDynamic_info)。这样算起来一共是14种。接下来我们按照Demo的字节码进行逐一翻译。</p><p>0x0015：由于常量池的数量不固定（n+2），所以需要在常量池的入口处放置一项u2类型的数据代表常量池数量。因此该16进制是21，表示有20项常量，索引范围为1~20。明明是21，为何是20呢？因为Class文件格式规定，设计者就讲第0项保留出来了，以备后患。从这里我们知道接下来我们需要翻译出20项常量。<br>Constant #1 （一共有20个常量，这是第一个，以此类推…）<br>0x0a-：从常量类型表中我们发现，第一个数据均是u1类型的tag，16进制的0a是十进制的10，对应表中的MethodRef_info。<br>0x-00 04-：Class_info索引项#4<br>0x-00 11-：NameAndType索引项#17<br>Constant #2<br>0x-09: FieldRef_info<br>0x0003 :Class_info索引项#3<br>0x0012：NameAndType索引项#18<br>Constant #3<br>0x07-: Class_info<br>0x-00 13-: 全局限定名常量索引为#19<br>Constant #4<br>0x-07 :Class_info<br>0x0014:全局限定名常量索引为#20<br>Constant #5<br>0x01:Utf-8_info<br>0x-00 01-:字符串长度为1（选择接下来的一个字节长度转义）<br>0x-61:”a”(十六进制转ASCII字符)<br>Constant #6<br>0x01:Utf-8_info<br>0x-00 01：字符串长度为1<br>0x-49:”I”<br>Constant #7<br>0x01:Utf-8_info<br>0x-00 06:字符串长度为6<br>0x-3c 696e 6974 3e-:”<init>“<br>Constant #8<br>0x01 :UTF-8_info<br>0x0003:字符串长度为3<br>0x2829 56:”()V”<br>Constant #9<br>0x-01:Utf-8_info<br>0x0004：字符串长度为4<br>0x436f 6465:”Code”<br>Constant #10<br>0x01:Utf-8_info<br>0x00 0f:字符串长度为15<br>0x4c 696e 654e 756d 6265 7254 6162 6c65:”LineNumberTable”<br>Constant #11<br>ox01: Utf-8_info<br>0x00 12字符串长度为18<br>0x-4c 6f63 616c 5661 7269 6162 6c65 5461 626c 65:”LocalVariableTable”<br>Constant #12<br>0x01:Utf-8_info<br>0x0004 字符串长度为4<br>0x7468 6973 :”this”<br>Constant #13<br>0x01:Utf-8_info<br>0x0f:字符串长度为15<br>0x4c 636f 6d2f 6465 6d6f 2f44 656d 6f3b:”Lcom/demo/Demo;”<br>Constant #14<br>0x01:Utf-8_info<br>0x00 0a:字符串长度为10<br>ox74 6573 744d 6574 686f 64:”testMethod”<br>Constant #15<br>0x01:Utf-8_info<br>0x000a:字符串长度为10<br>0x536f 7572 6365 4669 6c65 :”SourceFile”<br>Constant #16<br>0x01:Utf-8_info<br>0x0009:字符串长度为9<br>0x-44 656d 6f2e 6a61 7661 :”Demo.java”<br>Constant #17<br>0x0c :NameAndType_info<br>0x0007:字段或者名字名称常量项索引#7<br>0x0008:字段或者方法描述符常量索引#8<br>Constant #18<br>0x0c:NameAndType_info<br>0x0005:字段或者名字名称常量项索引#5<br>0x0006:字段或者方法描述符常量索引#6<br>Constant #19<br>0x01:Utf-8_info<br>0x00 0d:字符串长度为13<br>0x63 6f6d 2f64 656d 6f2f 4465 6d6f:”com/demo/Demo”<br>Constant #20<br>0x01:Utf-8_info<br>0x00 10 :字符串长度为16<br>0x6a 6176 612f 6c61 6e67 2f4f 626a 6563 74 :”java/lang/Object”<br>到这里为止我们解析了所有的常量。接下来是解析访问标志位。</init></p><h2 id="Access-Flag-访问标志"><a href="#Access-Flag-访问标志" class="headerlink" title="Access_Flag 访问标志"></a>Access_Flag 访问标志</h2><p>访问标志信息包括该Class文件是类还是接口，是否被定义成public，是否是abstract，如果是类，是否被声明成final。通过上面的源代码，我们知道该文件是类并且是public。</p><p><img src="/2018/03/14/java-api07/p6.png" alt="logo"></p><p>0x 00 21：是0x0020和0x0001的并集。其中0x0020这个标志值涉及到了字节码指令，后期会有专题对字节码指令进行讲解。</p><p>类索引</p><p>类索引用于确定类的全限定名<br>0x00 03 表示引用第3个常量，同时第3个常量引用第19个常量，查找得”com/demo/Demo”。#3.#19</p><h2 id="父类索引"><a href="#父类索引" class="headerlink" title="父类索引"></a>父类索引</h2><p>0x00 04 同理：#4.#20(java/lang/Object)</p><h2 id="接口索引"><a href="#接口索引" class="headerlink" title="接口索引"></a>接口索引</h2><p>通过java_byte.jpeg图我们知道，这个接口有2+n个字节，前两个字节表示的是接口数量，后面跟着就是接口的表。我们这个类没有任何接口，所以应该是0000。果不其然，查找字节码文件得到的就是0000。</p><h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><p>字段表用于描述类和接口中声明的变量。这里的字段包含了类级别变量以及实例变量，但是不包括方法内部声明的局部变量。<br>同样，接下来就是2+n个字段属性。我们只有一个属性a，按道理应该是0001。查找文件果不其然是0001。<br>那么接下来我们要针对这样的字段进行解析。附上字段表结构图</p><p><img src="/2018/03/14/java-api07/p7.png" alt="logo"></p><p>0x00 02 ：访问标志为private（自行搜索字段访问标志）<br>0x00 05 : 字段名称索引为#5，对应的是”a”<br>0x 00 06 :描述符索引为#6，对应的是”I”<br>0x 00 00 :属性表数量为0，因此没有属性表。<br>tips:一些不太重要的表（字段，方法访问标志表）可以自行搜索，这里就不贴出来了，防止篇幅过大。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>我们只有一个方法testMethod，按照道理应该前2个字节是0001。通过查找发现是0x00 02。这是什么原因，这代表着有2个方法呢？且继续看……</p><p><img src="/2018/03/14/java-api07/p8.png" alt="logo"></p><p>上图是一张方法表结构图，按照这个图我们分析下面的字节码：</p><p>第1个方法：</p><p>0x00 01：访问标志 ACC_PUBLIC，表明该方法是public。（可自行搜索方法访问标志表）<br>0x00 07：方法名索引为#7，对应的是”<init>“<br>0x00 08：方法描述符索引为#8，对应的是”()V”<br>0x00 01：属性表数量为1(一个属性表)<br>那么这里涉及到了属性表。什么是属性表呢？可以这么理解，它是为了描述一些专有信息的，上面的方法带有一张属性表。所有属性表的结构如下图：<br>一个u2的属性名称索引，一个u2的属性长度加上属性长度的info。<br>虚拟机规范预定义的属性有很多，比如Code，LineNumberTable，LocalVariableTable，SourceFile等等，这个网上可以搜索到。</init></p><p><img src="/2018/03/14/java-api07/p9.png" alt="logo"></p><p>按照上面的表结构解析得到下面信息：<br>0x0009:名称索引为#9(“Code”)。<br>0x000 00038：属性长度为56字节。<br>那么接下来解析一个Code属性表，按照下图解析</p><p><img src="/2018/03/14/java-api07/p9.png" alt="logo"></p><p>前面6个字节（名称索引2字节+属性长度4字节）已经解析过了，所以接下来就是解析剩下的56-6=50字节即可。<br>0x00 02 ：max_stack=2<br>0x00 01 : max_locals=1<br>0x00 0000 0a : code_length=10<br>0x2a b700 012a 04b5 0002 b1 : 这是code代码，可以通过虚拟机字节码指令进行查找。<br>2a=aload_0(将第一个引用变量推送到栈顶)<br>b7=invokespecial(调用父类构造方法)<br>00=什么都不做<br>01 =将null推送到栈顶<br>2a=同上<br>04=iconst_1 将int型1推送到栈顶<br>b5=putfield 为指定的类的实例变量赋值<br>00= 同上<br>02=iconst_m1 将int型-1推送栈顶<br>b1=return 从当前方法返回void<br>整理，去除无动作指令得到下面<br>0 : aload_0<br>1 : invokespecial<br>4 : aload_0<br>5 : iconst_1<br>6 : putfield<br>9 : return<br>关于虚拟机字节码指令这块内容，后期会继续深入下去…… 目前只需要了解即可。接下来顺着Code属性表继续解析下去:<br>0x00 00 : exception_table_length=0<br>0x00 02 : attributes_count=2(Code属性表内部还含有2个属性表)<br>0x00 0a: 第一个属性表是”LineNumberTable”</p><p><img src="/2018/03/14/java-api07/p10.png" alt="logo"></p><p>0x00 0000 0a : “属性长度为10”<br>0x00 02 ：line_number_table_length=2<br>line_number_table是一个数量为line_number_table_length，类型为line_number_info的集合，line_number_info表包括了start_pc和line_number两个u2类型的数据项，前者是字节码行号，后者是Java源码行号<br>0x00 00 : start_pc =0<br>0x00 03 : end_pc =3<br>0x00 04 : start_pc=4<br>0x00 04 : end_pc=4</p><p>0x00 0b 第二个属性表是：”LocalVariableTable”</p><p><img src="/2018/03/14/java-api07/p11.png" alt="logo"></p><p><img src="/2018/03/14/java-api07/p12.png" alt="logo"></p><p>local_variable_table.png<br>local_variable_info.png<br>0x00 0000 0c：属性长度为12<br>0x00 01 : local_variable_table_length=1<br>然后按照local_variable_info表结构进行解析：<br>0x00 00 : start_pc=0<br>0x00 0a：length=10<br>0x000c : name_index=”this”<br>0x000d : descriptor_index #13 (“Lcom/demo/Demo”)<br>0000 index=0<br>//——-到这里第一个方法就解析完成了——-//<br>Method（<init>)–1个属性Code表-2个属性表（LineNumberTable ，LocalVariableTable）接下来解析第二个方法</init></p><p>第2个方法：</p><p>0x00 04：”protected”<br>0x00 0e: #14（”testMethod”）<br>0x00 08 : “()V”<br>0x0001 ： 属性数量=1<br>0x0009 ：”Code”<br>0x0000 002b 属性长度为43<br>解析一个Code表<br>0000 :max_stack =0<br>0001 : max_local =1<br>0000 0001 : code_length =1<br>0xb1 : return(该方法返回void)<br>0x0000 异常表长度=0<br>0x0002 属性表长度为2<br>//第一个属性表<br>0x000a : #10，LineNumberTable<br>0x0000 0006 : 属性长度为6<br>0x0001 : line_number_length = 1<br>0x0000 : start_pc =0<br>0x0008 : end_pc =8<br>//第二个属性表<br>0x000b : #11 ，LocalVariableTable<br>0x0000 000c : 属性长度为12<br>0x0001 : local_variable_table_length =1<br>0x0000 :start_pc = 0<br>0x0001: length = 1<br>0x000c : name_index =#12 “this”<br>0x000d : 描述索引#13 “Lcom/demo/Demo;”<br>0000 index=0</p><p>//到这里为止，方法解析都完成了，回过头看看顶部解析顺序图，我们接下来就要解析Attributes了。</p><h2 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h2><p>0x0001 ：同样的，表示有1个Attributes了。<br>0x000f : #15(“SourceFile”)<br>0x0000 0002 attribute_length=2<br>0x0010 : sourcefile_index = #16(“Demo.java”)<br>SourceFile属性用来记录生成该Class文件的源码文件名称。</p><p><img src="/2018/03/14/java-api07/p13.png" alt="logo"></p><h1 id="另话"><a href="#另话" class="headerlink" title="另话"></a>另话</h1><p>其实，我们写了这么多确实很麻烦，不过这种过程自己体验一遍的所获所得还是不同的。现在，使用java自带的反编译器来解析字节码文件。<br>javap -verbose Demo //不用带后缀.class</p><p><img src="/2018/03/14/java-api07/p14.png" alt="logo"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到此为止，讲解完成了class文件的解析，这样以后我们也能看懂字节码文件了。了解class文件的结构对后面进一步了解虚拟机执行引擎非常重要，所以这是基础并重要的一步。</p><p>作者：小腊月<br>链接：<a href="https://www.jianshu.com/p/252f381a6bc4" target="_blank" rel="noopener">https://www.jianshu.com/p/252f381a6bc4</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><hr><p>以上是java字节码的介绍<br>属于JVM底层的知识</p><p>接下来介绍的是java操作字节库的类库有哪些及相关操作</p><h1 id="字节码操作"><a href="#字节码操作" class="headerlink" title="字节码操作"></a>字节码操作</h1><p>1.Java动态性的两种常见实现方式：</p><p>字节码操作<br>反射</p><p>2.运行时操作字节码可以实现如下功能：</p><p>动态生成新的类<br>动态改变某个类的结构(添加/删除/修改 新的属性/方法)</p><p>3.优势：</p><p>比反射开销小，性能高<br>Javaasist性能高于反射，低于ASM</p><h2 id="常见的字节码操作类库"><a href="#常见的字节码操作类库" class="headerlink" title="常见的字节码操作类库"></a>常见的字节码操作类库</h2><p>1.BCEL</p><p>Byte Code Engineering Library(BCEL)，这是Apache Software Foundation的Jakarta项目的一部分。BCEL是Java classworking 广泛使用的一种框架，它可以让您深入jvm汇编语言进行类库操作的细节。BCEL与javassist有不同的处理字节码方法，BCEL在实际的jvm指令层次上进行操作(BCEL拥有丰富的jvm指令集支持) 而javassist所强调的是源代码级别的工作。</p><p>2.ASM</p><p>是一个轻量级Java字节码操作框架，直接涉及到JVM底层的操作和指令<br>高性能，高质量</p><p>3.CGLB(code generation library)</p><p>生成类库，基于ASM实现</p><p>4.javassist</p><p>是一个开源的分析，编辑和创建Java字节码的类库。性能较ASM差，跟cglib差不多，但是使用简单。很多开源框架都在使用它。<br>主页： <a href="http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/javassist/" target="_blank" rel="noopener">http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/javassist/</a></p><h2 id="javassist库的API详解"><a href="#javassist库的API详解" class="headerlink" title="javassist库的API详解"></a>javassist库的API详解</h2><p>javassist的最外层的API和java的反射包中的API及其类似</p><p>它主要有CtClass, CtMethod,CtField几个类组成，用于执行和JDK反射API中java.lang.Class, java.lang,reflect.Method,java.lang.reflect.Method.Field相同的操作</p><p>创建一个类</p><pre><code>public class JavassistTest {      public static void main(String[] args) throws Exception {          ClassPool pool = ClassPool.getDefault();          CtClass cc = pool.makeClass(&quot;bean.User&quot;);          //创建属性          CtField field01 = CtField.make(&quot;private int id;&quot;,cc);          CtField field02 = CtField.make(&quot;private String name;&quot;, cc);          cc.addField(field01);          cc.addField(field02);          //创建方法          CtMethod method01 = CtMethod.make(&quot;public String getName(){return name;}&quot;, cc);          CtMethod method02 = CtMethod.make(&quot;public void setName(String name){this.name = name;}&quot;, cc);          cc.addMethod(method01);          cc.addMethod(method02);          //添加有参构造器          CtConstructor constructor = new CtConstructor(new CtClass[]{CtClass.intType,pool.get(&quot;java.lang.String&quot;)},cc);          constructor.setBody(&quot;{this.id=id;this.name=name;}&quot;);          cc.addConstructor(constructor);          //无参构造器          CtConstructor cons = new CtConstructor(null,cc);          cons.setBody(&quot;{}&quot;);          cc.addConstructor(cons);          cc.writeFile(&quot;E:/workspace/TestCompiler/src&quot;);      }  } </code></pre><p>方法操作</p><p>修改已有的方法体（插入代码到已有方法体）<br>新增方法<br>删除方法</p><p>$0 $1 $2          $0代表是this, $1代表方法参数的第一个参数，$2代表方法参数的第二个参数，以此类推，$N代表方法参数的第N个<br>$args             The type of $args is OBject[]. $args(0)对应的是$1，不是$0<br>$$                 一个方法调用的深度<br>$r                 方法返回值的类型<br>$_                 方法返回值。(修改方法体时不支持)<br>addCatch()         方法中加入try catch块  $e代表 异常对象<br>$class             this的类型(Class)。也就是$0的类型<br>$sig             方法参数的类型(Class)数组，数组的顺序。</p><p>构造方法操作</p><p>getConstructors()</p><p>注解操作</p><pre><code>public @interface Author{String name();int year();}@Author(name=&quot;over&quot;,year=2012)public class Point{int x,int y;}CtClass cc=ClassPool.getDefault().get(&quot;Point&quot;);Object[] all = cc.getAnnotations();Author a =(Author)all[0];String name = a.name();int year = a.year();System.out.println(name+&quot;:&quot;+year);</code></pre><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p>JDK5.0新语法不支持(包括泛型，枚举)，不支持注解修改，但可以通过底层的javassist类来解决，具体参考：javassist,bytecode.annotation<br>不支持数组的初始化，如String[]{“a”,”b”},除非只有数组的容量为1<br>不支持内部类和匿名类<br>不支持continue和break 表达式<br>对于继承关系，有些不支持 。例如</p><pre><code>class A{}class B extends A{}Class C extends B{}</code></pre><p>查资料： javassist与反射的性能比较</p><pre><code>public class Demo01 {      //获取类的简单信息      public static void test01() throws Exception{          ClassPool pool = ClassPool.getDefault();          CtClass cc = pool.get(&quot;bean.User&quot;);          //得到字节码          byte[] bytes = cc.toBytecode();          System.out.println(Arrays.toString(bytes));          System.out.println(cc.getName());//获取类名          System.out.println(cc.getSimpleName());//获取简要类名          System.out.println(cc.getSuperclass());//获取父类          System.out.println(cc.getInterfaces());//获取接口          System.out.println(cc.getMethods());//获取      }      //新生成一个方法      public static void test02() throws Exception{          ClassPool pool = ClassPool.getDefault();          CtClass cc = pool.get(&quot;bean.User&quot;);          //第一种          //CtMethod cm = CtMethod.make(&quot;public String getName(){return name;}&quot;, cc);          //第二种          //参数：返回值类型，方法名，参数，对象          CtMethod cm = new CtMethod(CtClass.intType,&quot;add&quot;,new CtClass[]{CtClass.intType,CtClass.intType},cc);          cm.setModifiers(Modifier.PUBLIC);//访问范围          cm.setBody(&quot;{return $1+$2;}&quot;);          //cc.removeMethod(m) 删除一个方法          cc.addMethod(cm);          //通过反射调用方法          Class clazz = cc.toClass();          Object obj = clazz.newInstance();//通过调用无参构造器，生成新的对象          Method m = clazz.getDeclaredMethod(&quot;add&quot;, int.class,int.class);          Object result = m.invoke(obj, 2,3);          System.out.println(result);      }      //修改已有的方法      public static void test03() throws Exception{          ClassPool pool  = ClassPool.getDefault();          CtClass cc = pool.get(&quot;bean.User&quot;);          CtMethod cm = cc.getDeclaredMethod(&quot;hello&quot;,new CtClass[]{pool.get(&quot;java.lang.String&quot;)});          cm.insertBefore(&quot;System.out.println(\&quot;调用前\&quot;);&quot;);//调用前          cm.insertAt(29, &quot;System.out.println(\&quot;29\&quot;);&quot;);//行号          cm.insertAfter(&quot;System.out.println(\&quot;调用后\&quot;);&quot;);//调用后          //通过反射调用方法          Class clazz = cc.toClass();          Object obj = clazz.newInstance();          Method m = clazz.getDeclaredMethod(&quot;hello&quot;, String.class);          Object result = m.invoke(obj, &quot;张三&quot;);          System.out.println(result);           }      //修改已有属性      public static void test04() throws Exception{          ClassPool pool  = ClassPool.getDefault();          CtClass cc = pool.get(&quot;bean.User&quot;);          //属性          CtField cf = new CtField(CtClass.intType,&quot;age&quot;,cc);          cf.setModifiers(Modifier.PRIVATE);          cc.addField(cf);          //增加响应的get set方法          cc.addMethod(CtNewMethod.getter(&quot;getAge&quot;,cf));          cc.addMethod(CtNewMethod.setter(&quot;setAge&quot;,cf));          //访问属性          Class clazz = cc.toClass();          Object obj = clazz.newInstance();                 Field field = clazz.getDeclaredField(&quot;age&quot;);          System.out.println(field);          Method m = clazz.getDeclaredMethod(&quot;setAge&quot;, int.class);          m.invoke(obj, 16);          Method m2 = clazz.getDeclaredMethod(&quot;getAge&quot;, null);          Object resutl = m2.invoke(obj,null);                  System.out.println(resutl);      }      //操作构造方法      public static void test05() throws Exception{          ClassPool pool = ClassPool.getDefault();          CtClass cc = pool.get(&quot;bean.User&quot;);          CtConstructor[] cons = cc.getConstructors();          for(CtConstructor con:cons){              System.out.println(con);          }      }      public static void main(String[] args) throws Exception {          //test01();          //test02();          //test03();          //test04();          test05();      }  }  </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;也许你写了无数行的代码，也许你能非常溜的使用高级语言，但是你未必了解那些高级语言的执行过程。例如大行其道的Java。&lt;/p&gt;
&lt;p&gt;Java号称是一门“一次编译到处运行”的语言，但是我们对这句话的理解深度又有多少呢？从我们写的java文件到通过编译器编译成java字节码文件（也就是.class文件），这个过程是java编译过程；而我们的java虚拟机执行的就是字节码文件。不论该字节码文件来自何方，由哪种编译器编译，甚至是手写字节码文件，只要符合java虚拟机的规范，那么它就能够执行该字节码文件。那么本文主要讲讲java字节码文件相关知识。接下来我们通过具体的Demo来深入理解：&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="java类库" scheme="http://yoursite.com/tags/java%E7%B1%BB%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JAVA开发常用类库--常用类库</title>
    <link href="http://yoursite.com/2018/03/14/java-api06/"/>
    <id>http://yoursite.com/2018/03/14/java-api06/</id>
    <published>2018-03-14T04:09:18.000Z</published>
    <updated>2018-03-14T10:20:06.965Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Java 类库概念：</strong><br>Java 的应用程序接口 (API) 以包的形式来组织，每个包提供了大量的相关类、接口和异常处理类，这些包的集合就是 Java 的类库</p><p>包名以 Java 开始的包是 Java 核心包 (Java Core Package) ；</p><p>包名以 Javax 开始的包是 Java 扩展包 (Java Extension Package) ，例如 javax.swing 包；</p><a id="more"></a><p>常用的 Java 核心包 (Java Core Package)</p><ol><li><p><strong>java.lang</strong>      Java 编程语言的基本类库</p></li><li><p>java.applet     创建 applet 需要的所有类</p></li><li><p>java.awt       创建用户界面以及绘制和管理图形、图像的类</p></li><li><p>java.io        通过数据流、对象序列以及文件系统实现的系统输入、输出</p></li><li><p>java.net       用于实现网络通讯应用的所有类</p></li><li><p><strong>java.util</strong>       集合类、时间处理模式、日期时间工具等各类常用工具包</p></li></ol><p>其它还有</p><ol><li><p>java.sql        访问和处理来自于 Java 标准数据源数据的类</p></li><li><p>java.test       以一种独立于自然语言的方式处理文本、日期、数字和消息的类和接口</p></li><li><p>java.security    设计网络安全方案需要的一些类</p></li><li><p>java.beans     开发 Java Beans 需要的所有类</p></li><li><p>java.math      简明的整数算术以及十进制算术的基本函数</p></li><li><p>java.rmi       与远程方法调用相关的所有类，rmi即Remote Method Invoke远程方法调用</p></li></ol><p>常用的 Java 扩展包 (Java Extension Package)</p><ol><li><p>javax.accessibility  定义了用户界面组件之间相互访问的一种机制</p></li><li><p>javax.naming.*     为命名服务提供了一系列类和接口</p></li><li><p>javax.swing.*       提供了一系列轻量级的用户界面组件，是目前 Java 用户界面常用的包</p></li></ol><p>注 1 ：最重要且常用的是 1 和 6 ，已用黑体标出的为，需重点掌握</p><p>注 2 ：在使用 Java 时，除了 java.lang 外，其他的包都需要 import 语句引入之后才能使用。</p><p>重点讲解内容：java.lang和java.util。具体各方法在开发文档里写的很清楚</p><p>java.lang 包</p><p>这个包称为 java 语言包，是由编译器自动引入的。程序中不必用 import 语句就可以使用。它所包含的类和接口对所有实际的 Java 程序都是必要的。</p><ol><li><p>object 类</p></li><li><p>数学类 (Math)</p></li><li><p>数据类型类</p></li><li><p>线程类</p></li><li><p>字符串类 (String 类和 StringBuffer 类 )</p></li><li><p>系统及运行类 (System 类和 Runtime 类 )</p></li><li><p>错误和异常处理类 (Throwable 、 Exception 、 Error)</p></li><li><p>过程类 (process)</p></li></ol><p>java.util 包</p><ol><li><p>日期类、日历类（ Data 、 Calendar 、 GregorianCalendar ）</p></li><li><p>随机数类（ Random ）</p></li><li><p>位运算类（ BitSet ）</p></li><li><p>矢量类（ Vector ）</p></li><li><p>数据结构类（ Stack ）</p></li><li><p>散列表类（ Hashtable ）</p></li><li><p>StringTokenizer类</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Java 类库概念：&lt;/strong&gt;&lt;br&gt;Java 的应用程序接口 (API) 以包的形式来组织，每个包提供了大量的相关类、接口和异常处理类，这些包的集合就是 Java 的类库&lt;/p&gt;
&lt;p&gt;包名以 Java 开始的包是 Java 核心包 (Java Core Package) ；&lt;/p&gt;
&lt;p&gt;包名以 Javax 开始的包是 Java 扩展包 (Java Extension Package) ，例如 javax.swing 包；&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="java类库" scheme="http://yoursite.com/tags/java%E7%B1%BB%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JAVA开发常用类库--日期和时间库</title>
    <link href="http://yoursite.com/2018/03/13/java-api05/"/>
    <id>http://yoursite.com/2018/03/13/java-api05/</id>
    <published>2018-03-13T11:08:58.000Z</published>
    <updated>2018-03-13T12:28:59.864Z</updated>
    
    <content type="html"><![CDATA[<p>在Java之前，JDK的日期和时间库一直被人们所诟病，比如其非线程安全的、不可变的、容易出错等。很多开发人员会选择更好用的 JodaTime 类库。<br>但是在Java8推出之后，我们就可以彻底放弃JodaTime了，因为Java 8提供了其所有功能。但是，如果你的代码运行在一个低版本的JDK中，那么JodaTime还是值得使用的。</p><a id="more"></a><p>Java 8 新特性：</p><h1 id="Java-类库的新特性之日期时间API-Date-Time-API"><a href="#Java-类库的新特性之日期时间API-Date-Time-API" class="headerlink" title="Java 类库的新特性之日期时间API (Date/Time API )"></a>Java 类库的新特性之日期时间API (Date/Time API )</h1><p>文章来自：<br><a href="http://blog.csdn.net/sun_promise/article/details/51383618" target="_blank" rel="noopener">http://blog.csdn.net/sun_promise/article/details/51383618</a></p><h2 id="Java8之前java-util-Date和Calendar类的弊端"><a href="#Java8之前java-util-Date和Calendar类的弊端" class="headerlink" title="Java8之前java.util.Date和Calendar类的弊端"></a>Java8之前java.util.Date和Calendar类的弊端</h2><p>1）最开始的时候，Date既要承载日期信息，又要做日期之间的转换，还要做不同日期格式的显示，职责较繁杂（不遵守单一职责）。</p><p>后来从JDK 1.1 开始，这三项职责分开了：</p><p>使用Calendar类实现日期和时间字段之间转换；<br>使用DateFormat类来格式化和分析日期字符串；<br>Date只用来承载日期和时间信息。<br>现在原有Date中的相应方法已废弃。无论是Date，还是Calendar，都使用着太不方便，这是API没有设计好的地方。</p><p>2）令人无语的year和month（month是从0开始的）</p><p>eg：</p><pre><code>[java] view plain copyDate date = new Date(2016,1,1);     System.out.println(date);   </code></pre><p>输出结果：Tue Feb 01 00:00:00 CST 3916<br>这样得到的结果year为2012+1900，而month明明给定的参数是1，却输出的是二月。<br>设置日期可以用java.util.Calendar</p><pre><code>[java] view plain copyCalendar calendar = Calendar.getInstance();     calendar.set(2016, 5, 2);  </code></pre><p>虽然Calendar年份的传值不需要减去1900，但Calendar的month也是从0开始的，表达5月份应该用4这个数字。<br>3）java.util.Date与java.util.Calendar中的所有属性都是可变的，且线程不安全。</p><pre><code>eg：[java] view plain copypublic class Test {      public static void main(String[] args) {          Calendar birth = Calendar.getInstance();          birth.set(1975, Calendar.MAY, 26);          Calendar now = Calendar.getInstance();          System.out.println(daysBetween(birth, now)); // 输出结果为14963，值不固定          System.out.println(daysBetween(birth, now)); // 输出结果 显示 0？      }  }      public static long daysBetween(Calendar begin, Calendar end) {              long daysBetween = 0;              while(begin.before(end)) {                  begin.add(Calendar.DAY_OF_MONTH, 1);                  daysBetween++;             }             return daysBetween;         }   }  </code></pre><p>Note:daysBetween有点问题，如果连续计算两个Date实例的话，第二次会取得0，因为Calendar状态是可变的，考虑到重复计算的场合，最好复制一个新的Calendar。修改代码如下<br>    [java] view plain copy<br>    public static long daysBetween(Calendar begin, Calendar end) {<br>        Calendar calendar = (Calendar) begin.clone(); // 复制<br>            long daysBetween = 0;<br>            while(calendar.before(end)) {<br>                calendar.add(Calendar.DAY_OF_MONTH, 1);<br>                daysBetween++;<br>            }<br>            return daysBetween;<br>    } </p><h2 id="新的日期时间API"><a href="#新的日期时间API" class="headerlink" title="新的日期时间API"></a>新的日期时间API</h2><p>Java 的日期与时间 API 问题由来已久，Java 8 之前的版本中关于时间、日期及其他时间日期格式化类由于线程安全、重量级、序列化成本高等问题而饱受批评。Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的 API。新的 java.time 中包含了所有关于时钟（Clock），本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）和持续时间（Duration）的类。历史悠久的 Date 类新增了 toInstant() 方法，用于把 Date 转换成新的表示形式。这些新增的本地化时间日期 API 大大简化了了日期时间和本地化的管理。</p><p>目前Java8新增了java.time包定义的类表示日期-时间概念的规则，很方便使用；最重要的一点是值不可变，且线程安全。</p><p>下图是java.time包下的一些主要的类的日期时间 值的格式，方便理解使用：</p><p><img src="/2018/03/13/java-api05/main.png" alt="logo"> </p><p>Note：不过尽管有了新的API，但仍有一个严重的问题——大量的旧代码和库仍然在使用老的API。现在，Java 8解决了这个问题，它给Date类增加了一个新的方法toInstant()，可以将Date转化成新的实例。这样就可以切换到新的API。</p><p>对于新API：</p><p>非常有用的值类型：<br>Instant —– 与java.util.Date相似<br>ZonedDateTime —– ZoneId -时区很重要的时候使用<br>OffsetDateTime —– OffsetTime, ZoneOffset -对UTC的偏移处理<br>Duration, Period —– 但如果你想找到两个日期之间的时间量，你可能会寻找ChronoUnit代替（详情见下文）<br>其他有用的类型：<br>DateTimeFormatter —– 将日期类型转换成字符串类型<br>ChronoUnit —– 计算出两点之间的时间量，例如ChronoUnit.DAYS.between(t1, t2)<br>TemporalAdjuster —– 例如date.with(TemporalAdjuster.firstDayOfMonth())<br>Note：大多数情况下，新的值类型由JDBC提供支持。有一小部分异常，eg：ZonedDateTime在SQL中没有对应的（类型）。</p><h2 id="Java-新旧日期API的区别"><a href="#Java-新旧日期API的区别" class="headerlink" title="Java 新旧日期API的区别"></a>Java 新旧日期API的区别</h2><p><img src="/2018/03/13/java-api05/pp.png" alt="logo"></p><h2 id="java-time包下的类"><a href="#java-time包下的类" class="headerlink" title="java.time包下的类"></a>java.time包下的类</h2><p>Clock类</p><p>Clock类提供了访问当前日期和时间的方法。Clock使用时区来访问当前的instant, date和time。Clock类可以替换 System.currentTimeMillis() 和 TimeZone.getDefault()。</p><pre><code>eg：[java] view plain copy//Clock 时钟              Clock clock1 = Clock.systemDefaultZone();//获取系统默认时区 (当前瞬时时间 )              System.out.println( &quot;系统时间日期：&quot;+clock1.instant() );              System.out.println( &quot;时间毫秒：&quot;+clock1.millis() );              final Clock clock = Clock.systemUTC();//获取系统时钟，并将其转换成使用UTC时区的日期和时间              System.out.println( &quot;时间日期：&quot;+clock.instant() );              System.out.println( &quot;时间毫秒值：&quot;+clock.millis() );  </code></pre><p>输出结果：<br>系统时间日期：2016-05-12T07:42:37.883Z<br>时间毫秒：1463038957894<br>时间日期：2016-05-12T07:42:37.894Z</p><p>时间毫秒值：1463038957894</p><p>某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。</p><pre><code>eg：[java] view plain copyInstant instant = clock1.instant();              Date javadate = Date.from(instant);               System.out.println( &quot;date：&quot;+javadate);  </code></pre><p>输出结果：</p><p>date：Thu May 12 15:47:00 CST 2016</p><p>ZoneId（时区）</p><p>在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of()来获取到。时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。</p><pre><code>eg:[java] view plain copy// 输出所有可见的时区ID，eg：Asia/Aden, America/Cuiaba, Etc/GMT+9等  System.out.println(ZoneId.getAvailableZoneIds());  ZoneId zone1 = ZoneId.of(&quot;Europe/Berlin&quot;);  ZoneId zone2 = ZoneId.of(&quot;Brazil/East&quot;);  System.out.println(zone1.getRules());  System.out.println(zone2.getRules());  //输出结果： ZoneRules[currentStandardOffset=+01:00]  //输出结果： ZoneRules[currentStandardOffset=-03:00]  </code></pre><p>LocalTime（本地时间）</p><p>LocalTime 定义了一个没有时区信息的时间。</p><p>eg：</p><p>1）获取现在的本地时间</p><pre><code>[java] view plain copy// Get the local date and local time              final LocalTime time = LocalTime.now();              final LocalTime timeFromClock = LocalTime.now( clock );              System.out.println( time );              System.out.println( timeFromClock );  </code></pre><p>输出结果：<br>16:03:23.212<br>08:03:23.212</p><p>2）按时区显示时间</p><pre><code>[java] view plain copyZoneId zone1 = ZoneId.of(&quot;Europe/Berlin&quot;);          ZoneId zone2 = ZoneId.of(&quot;Brazil/East&quot;);          LocalTime now1 = LocalTime.now(zone1);          LocalTime now2 = LocalTime.now(zone2);          System.out.println(&quot;时区：Europe/Berlin---&quot;+now1);           System.out.println(&quot;时区：Brazil/East---&quot;+now2);   </code></pre><p>输出结果：</p><p>时区：Europe/Berlin—10:03:23.217<br>时区：Brazil/East—05:03:23.217</p><p>LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串。</p><pre><code>eg：[java] view plain copyLocalTime late = LocalTime.of(22, 12, 18);//时分秒          System.out.println(late); // 输出结果：22:12:18          DateTimeFormatter germanFormatter = DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT)                  .withLocale(Locale.GERMAN);          LocalTime leetTime = LocalTime.parse(&quot;15:39&quot;, germanFormatter);          System.out.println(leetTime); // 输出结果： 15:39  </code></pre><p>LocalDate(本地日期)</p><p>LocalDate 表示了一个确切的日期（eg： 2014-03-11）。该对象值是不可变的，使用方式和LocalTime基本一致。</p><pre><code>eg:[java] view plain copyClock clock = Clock.systemDefaultZone();// 获取系统默认时区 (当前瞬时时间 )          // Get the local date and local time          final LocalDate date = LocalDate.now();          final LocalDate dateFromClock = LocalDate.now(clock);          System.out.println(date);          System.out.println(dateFromClock);  </code></pre><p>输出结果:<br>2016-05-12<br>2016-05-12</p><p>从字符串解析一个LocalDate类型和解析LocalTime一样简单.</p><pre><code>eg：[java] view plain copyDateTimeFormatter germanFormatter = DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM)          .withLocale(Locale.GERMAN);  LocalDate xmas = LocalDate.parse(&quot;25.10.2016&quot;, germanFormatter);  System.out.println(xmas);  </code></pre><p>输出结果：<br>2016-10-25</p><p>LocalDateTime（本地日期时间）</p><p>表示了具体时间和日期。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。</p><pre><code>eg：1）[java] view plain copyClock clock = Clock.systemDefaultZone();// 获取系统默认时区 (当前瞬时时间 )          // Get the local date/time          final LocalDateTime datetime = LocalDateTime.now();          final LocalDateTime datetimeFromClock = LocalDateTime.now(clock);          System.out.println(datetime);          System.out.println(datetimeFromClock);  </code></pre><p>输出结果：<br>2016-05-12T16:33:17.546<br>2016-05-12T16:33:17.546</p><pre><code>2）[java] view plain copyLocalDateTime sylvester = LocalDateTime.of(2016, Month.DECEMBER, 31, 23, 59, 59);      DayOfWeek dayOfWeek = sylvester.getDayOfWeek();      System.out.println(dayOfWeek);            Month month = sylvester.getMonth();      System.out.println(month);              long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);      System.out.println(minuteOfDay);    </code></pre><p>输出结果：</p><p>SATURDAY<br>DECEMBER<br>1439</p><p>只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date。<br>    eg：</p><pre><code>[java] view plain copyLocalDateTime sylvester = LocalDateTime.of(2016, Month.DECEMBER, 31, 23, 59, 59);          Instant instant = sylvester                  .atZone(ZoneId.systemDefault())                  .toInstant();          Date legacyDate = Date.from(instant);          System.out.println(legacyDate);  </code></pre><p>输出结果：</p><p>Sat Dec 31 23:59:59 CST 2016</p><p>格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我也可以自定义格式。</p><pre><code>eg:[java] view plain copyDateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;MM dd, yyyy - HH:mm&quot;);      LocalDateTime parsed = LocalDateTime.parse(&quot;05 03, 2016 - 07:13&quot;, formatter);      String string = formatter.format(parsed);      System.out.println(string);  </code></pre><p>输出结果：<br>05 03, 2016 - 07:13</p><p>Note:和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。</p><p>ZonedDateTime（日期时间和时区信息）</p><p>使用ZonedDateTime，它保存有ISO-8601日期系统的日期和时间，而且有时区信息。</p><pre><code>eg：[java] view plain copyClock clock = Clock.systemDefaultZone();// 获取系统默认时区 (当前瞬时时间 )  // Get the zoned date/time  final ZonedDateTime zonedDatetime = ZonedDateTime.now();  final ZonedDateTime zonedDatetimeFromClock = ZonedDateTime.now(clock);  final ZonedDateTime zonedDatetimeFromZone = ZonedDateTime.now(ZoneId.of(&quot;America/Los_Angeles&quot;));  System.out.println(zonedDatetime);  System.out.println(zonedDatetimeFromClock);  System.out.println(zonedDatetimeFromZone);  </code></pre><p>输出结果：</p><p>2016-05-12T16:59:55.779+08:00[Asia/Shanghai]<br>2016-05-12T16:59:55.779+08:00[Asia/Shanghai]<br>2016-05-12T01:59:55.781-07:00[America/Los_Angeles]</p><p>Duration类</p><p>Duration持有的时间精确到纳秒。很容易计算两个日期中间的差异。</p><pre><code>eg：求时间差[java] view plain copy              // Get duration between two dates  final LocalDateTime from = LocalDateTime.of(2014, Month.APRIL, 16, 0, 0, 0);//年月日时分秒  final LocalDateTime to = LocalDateTime.of(2015, Month.APRIL, 16, 23, 59, 59);  final Duration duration = Duration.between(from, to);  System.out.println(&quot;Duration in days: &quot; + duration.toDays());  System.out.println(&quot;Duration in hours: &quot; + duration.toHours());</code></pre><h2 id="新日期时间API示例"><a href="#新日期时间API示例" class="headerlink" title="新日期时间API示例"></a>新日期时间API示例</h2><pre><code>import java.time.Clock;  import java.time.Duration;  import java.time.Instant;  import java.time.LocalDateTime;  import java.time.ZoneId;  import java.time.ZonedDateTime;  import java.time.chrono.ChronoLocalDateTime;  import java.time.chrono.Chronology;  import java.time.chrono.HijrahChronology;  import java.time.format.DateTimeFormatter;  import java.time.temporal.IsoFields;  import java.util.Date;  public class TimeTest {      public static void main(String[] args) throws InterruptedException {          testClock();  //      testInstant();  //      testLocalDateTime();  //      testZonedDateTime();  //      testDuration();  //      testChronology();  //      testNewOldDateConversion();      }      public static void testClock() throws InterruptedException {          // 时钟提供给我们用于访问某个特定 时区的 瞬时时间、日期 和 时间的。             Clock c1 = Clock.systemUTC(); // 系统默认UTC时钟（当前瞬时时间           System.out.println(c1.millis()); // 每次调用将返回当前瞬时时间（UTC）          //相当于System.currentTimeMillis()）          Clock c2 = Clock.systemDefaultZone(); // 系统默认时区时钟（当前瞬时时间）          Clock c31 = Clock.system(ZoneId.of(&quot;Europe/Paris&quot;)); // 巴黎时区          System.out.println(c31.instant()); // 每次调用将返回当前瞬时时间（UTC）          Clock c32 = Clock.system(ZoneId.of(&quot;Asia/Shanghai&quot;));// 上海时区          System.out.println(c32.instant());// 每次调用将返回当前瞬时时间（UTC）          Clock c4 = Clock.fixed(Instant.now(), ZoneId.of(&quot;Asia/Shanghai&quot;));// 固定上海时区时钟          System.out.println(c4.millis());          Thread.sleep(1000);          System.out.println(c4.millis()); // 不变 即时钟时钟在那一个点不动          Clock c5 = Clock.offset(c1, Duration.ofSeconds(2)); // 相对于系统默认时钟两秒的时钟          System.out.println(c1.millis());          System.out.println(c5.millis());      }      public static void testInstant() {          // 瞬时时间 相当于以前的System.currentTimeMillis()          Instant instant1 = Instant.now();          System.out.println(instant1.getEpochSecond());// 精确到秒 得到相对于1970-01-01                                                          // 00:00:00 UTC的一个时间          System.out.println(instant1.toEpochMilli()); // 精确到毫秒          Clock clock1 = Clock.systemUTC(); // 获取系统UTC默认时钟          Instant instant2 = Instant.now(clock1);// 得到时钟的瞬时时间          System.out.println(instant2.toEpochMilli());          Clock clock2 = Clock.fixed(instant1, ZoneId.systemDefault()); // 固定瞬时时间时钟          Instant instant3 = Instant.now(clock2);// 得到时钟的瞬时时间          System.out.println(instant3.toEpochMilli());// equals instant1      }      public static void testLocalDateTime() {          // 使用默认时区时钟瞬时时间创建 Clock.systemDefaultZone() --&gt;即相对于          // ZoneId.systemDefault()默认时区          LocalDateTime now = LocalDateTime.now();          System.out.println(now);          // 自定义时区          LocalDateTime now2 = LocalDateTime.now(ZoneId.of(&quot;Europe/Paris&quot;));          System.out.println(now2);// 会以相应的时区显示日期          // 自定义时钟          Clock clock = Clock.system(ZoneId.of(&quot;Asia/Dhaka&quot;));          LocalDateTime now3 = LocalDateTime.now(clock);          System.out.println(now3);// 会以相应的时区显示日期          // 不需要写什么相对时间 如java.util.Date 年是相对于1900 月是从0开始          // 2013-12-31 23:59          LocalDateTime d1 = LocalDateTime.of(2013, 12, 31, 23, 59);          // 年月日 时分秒 纳秒          LocalDateTime d2 = LocalDateTime.of(2013, 12, 31, 23, 59, 59, 11);          // 使用瞬时时间 + 时区          Instant instant = Instant.now();          LocalDateTime d3 = LocalDateTime.ofInstant(Instant.now(), ZoneId.systemDefault());          System.out.println(d3);          // 解析String---&gt;LocalDateTime          LocalDateTime d4 = LocalDateTime.parse(&quot;2013-12-31T23:59&quot;);          System.out.println(d4);          LocalDateTime d5 = LocalDateTime.parse(&quot;2013-12-31T23:59:59.999&quot;);// 999毫秒                                                                              // 等价于999000000纳秒          System.out.println(d5);          // 使用DateTimeFormatter API 解析 和 格式化          DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy/MM/dd HH:mm:ss&quot;);          LocalDateTime d6 = LocalDateTime.parse(&quot;2013/12/31 23:59:59&quot;, formatter);          System.out.println(formatter.format(d6));          // 时间获取          System.out.println(d6.getYear());          System.out.println(d6.getMonth());          System.out.println(d6.getDayOfYear());          System.out.println(d6.getDayOfMonth());          System.out.println(d6.getDayOfWeek());          System.out.println(d6.getHour());          System.out.println(d6.getMinute());          System.out.println(d6.getSecond());          System.out.println(d6.getNano());          // 时间增减          LocalDateTime d7 = d6.minusDays(1);          LocalDateTime d8 = d7.plus(1, IsoFields.QUARTER_YEARS);          // LocalDate 即年月日 无时分秒          // LocalTime即时分秒 无年月日          // API和LocalDateTime类似就不演示了      }      public static void testZonedDateTime() {          // 即带有时区的date-time 存储纳秒、时区和时差（避免与本地date-time歧义）。          // API和LocalDateTime类似，只是多了时差(如2013-12-20T10:35:50.711+08:00[Asia/Shanghai])          ZonedDateTime now = ZonedDateTime.now();          System.out.println(now);          ZonedDateTime now2 = ZonedDateTime.now(ZoneId.of(&quot;Europe/Paris&quot;));          System.out.println(now2);          // 其他的用法也是类似的 就不介绍了          ZonedDateTime z1 = ZonedDateTime.parse(&quot;2013-12-31T23:59:59Z[Europe/Paris]&quot;);          System.out.println(z1);      }      public static void testDuration() {          // 表示两个瞬时时间的时间段          Duration d1 = Duration.between(Instant.ofEpochMilli(System.currentTimeMillis() - 12323123), Instant.now());          // 得到相应的时差          System.out.println(d1.toDays());          System.out.println(d1.toHours());          System.out.println(d1.toMinutes());          System.out.println(d1.toMillis());          System.out.println(d1.toNanos());          // 1天时差 类似的还有如ofHours()          Duration d2 = Duration.ofDays(1);          System.out.println(d2.toDays());      }      public static void testChronology() {          // 提供对java.util.Calendar的替换，提供对年历系统的支持          Chronology c = HijrahChronology.INSTANCE;          ChronoLocalDateTime d = c.localDateTime(LocalDateTime.now());          System.out.println(d);      }      /**      * 新旧日期转换      */      public static void testNewOldDateConversion() {          Instant instant = new Date().toInstant();          Date date = Date.from(instant);          System.out.println(instant);          System.out.println(date);      }  }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java之前，JDK的日期和时间库一直被人们所诟病，比如其非线程安全的、不可变的、容易出错等。很多开发人员会选择更好用的 JodaTime 类库。&lt;br&gt;但是在Java8推出之后，我们就可以彻底放弃JodaTime了，因为Java 8提供了其所有功能。但是，如果你的代码运行在一个低版本的JDK中，那么JodaTime还是值得使用的。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="java类库" scheme="http://yoursite.com/tags/java%E7%B1%BB%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JAVA开发常用类库--PDF处理库</title>
    <link href="http://yoursite.com/2018/03/13/java-api04/"/>
    <id>http://yoursite.com/2018/03/13/java-api04/</id>
    <published>2018-03-13T10:45:08.000Z</published>
    <updated>2018-03-13T11:08:31.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iText"><a href="#iText" class="headerlink" title="iText"></a>iText</h1><p>iText是一个能够快速产生PDF文件的java类库。iText的java类对于那些要产生包含文本，表格，图形的只读文档是很有用的。它的类库尤其与java Servlet有很好的给合。使用iText与PDF能够使你正确的控制Servlet的输出。<br>该项目主页:<a href="http://www.lowagie.com/iText/" target="_blank" rel="noopener">http://www.lowagie.com/iText/</a></p><p>iText是著名的开放项目，是用于生成PDF文档的一个java类库。通过iText不仅可以生成PDF或rtf的文档，而且可以将XML、Html文件转化为PDF文件。</p><p>Harness the power of PDF with iText</p><p>Easy PDF generation and manipulation for Java and .NET developers</p><a id="more"></a><h2 id="生成一个PDF"><a href="#生成一个PDF" class="headerlink" title="生成一个PDF"></a>生成一个PDF</h2><pre><code>//Step 1—Create a Document.  Document document = new Document();  //Step 2—Get a PdfWriter instance.  PdfWriter.getInstance(document, new FileOutputStream(FILE_DIR + &quot;createSamplePDF.pdf&quot;));  //Step 3—Open the Document.  document.open();  //Step 4—Add content.  document.add(new Paragraph(&quot;Hello World&quot;));  //Step 5—Close the Document.  document.close(); </code></pre><h2 id="页面大小-页面背景色-页边空白-Title-Author-Subject-Keywords"><a href="#页面大小-页面背景色-页边空白-Title-Author-Subject-Keywords" class="headerlink" title="页面大小,页面背景色,页边空白,Title,Author,Subject,Keywords"></a>页面大小,页面背景色,页边空白,Title,Author,Subject,Keywords</h2><pre><code>//页面大小  Rectangle rect = new Rectangle(PageSize.B5.rotate());  //页面背景色  rect.setBackgroundColor(BaseColor.ORANGE);  Document doc = new Document(rect);  PdfWriter writer = PdfWriter.getInstance(doc, out);  //PDF版本(默认1.4)  writer.setPdfVersion(PdfWriter.PDF_VERSION_1_2);  //文档属性  doc.addTitle(&quot;Title@sample&quot;);  doc.addAuthor(&quot;Author@rensanning&quot;);  doc.addSubject(&quot;Subject@iText sample&quot;);  doc.addKeywords(&quot;Keywords@iText&quot;);  doc.addCreator(&quot;Creator@iText&quot;);  //页边空白  doc.setMargins(10, 20, 30, 40);  doc.open();  doc.add(new Paragraph(&quot;Hello World&quot;)); </code></pre><h2 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h2><pre><code>PdfWriter writer = PdfWriter.getInstance(doc, out);  // 设置密码为：&quot;World&quot;  writer.setEncryption(&quot;Hello&quot;.getBytes(), &quot;World&quot;.getBytes(),          PdfWriter.ALLOW_SCREENREADERS,          PdfWriter.STANDARD_ENCRYPTION_128);  doc.open();  doc.add(new Paragraph(&quot;Hello World&quot;));</code></pre><h2 id="添加Page"><a href="#添加Page" class="headerlink" title="添加Page"></a>添加Page</h2><pre><code>document.open();  document.add(new Paragraph(&quot;First page&quot;));  document.add(new Paragraph(Document.getVersion()));  document.newPage();  writer.setPageEmpty(false);  document.newPage();  document.add(new Paragraph(&quot;New page&quot;));</code></pre><h2 id="添加水印-背景图"><a href="#添加水印-背景图" class="headerlink" title="添加水印(背景图)"></a>添加水印(背景图)</h2><pre><code>//图片水印  PdfReader reader = new PdfReader(FILE_DIR + &quot;setWatermark.pdf&quot;);  PdfStamper stamp = new PdfStamper(reader, new FileOutputStream(FILE_DIR          + &quot;setWatermark2.pdf&quot;));  Image img = Image.getInstance(&quot;resource/watermark.jpg&quot;);  img.setAbsolutePosition(200, 400);  PdfContentByte under = stamp.getUnderContent(1);  under.addImage(img);  //文字水印  PdfContentByte over = stamp.getOverContent(2);  over.beginText();  BaseFont bf = BaseFont.createFont(BaseFont.HELVETICA, BaseFont.WINANSI,          BaseFont.EMBEDDED);  over.setFontAndSize(bf, 18);  over.setTextMatrix(30, 30);  over.showTextAligned(Element.ALIGN_LEFT, &quot;DUPLICATE&quot;, 230, 430, 45);  over.endText();  //背景图  Image img2 = Image.getInstance(&quot;resource/test.jpg&quot;);  img2.setAbsolutePosition(0, 0);  PdfContentByte under2 = stamp.getUnderContent(3);  under2.addImage(img2);  stamp.close();  reader.close();</code></pre><h2 id="插入Chunk-Phrase-Paragraph-List"><a href="#插入Chunk-Phrase-Paragraph-List" class="headerlink" title="插入Chunk, Phrase, Paragraph, List"></a>插入Chunk, Phrase, Paragraph, List</h2><pre><code>//Chunk对象: a String, a Font, and some attributes  document.add(new Chunk(&quot;China&quot;));  document.add(new Chunk(&quot; &quot;));  Font font = new Font(Font.FontFamily.HELVETICA, 6, Font.BOLD, BaseColor.WHITE);  Chunk id = new Chunk(&quot;chinese&quot;, font);  id.setBackground(BaseColor.BLACK, 1f, 0.5f, 1f, 1.5f);  id.setTextRise(6);  document.add(id);  document.add(Chunk.NEWLINE);  document.add(new Chunk(&quot;Japan&quot;));  document.add(new Chunk(&quot; &quot;));  Font font2 = new Font(Font.FontFamily.HELVETICA, 6, Font.BOLD, BaseColor.WHITE);  Chunk id2 = new Chunk(&quot;japanese&quot;, font2);  id2.setBackground(BaseColor.BLACK, 1f, 0.5f, 1f, 1.5f);  id2.setTextRise(6);  id2.setUnderline(0.2f, -2f);  document.add(id2);  document.add(Chunk.NEWLINE);  //Phrase对象: a List of Chunks with leading  document.newPage();  document.add(new Phrase(&quot;Phrase page&quot;));  Phrase director = new Phrase();  Chunk name = new Chunk(&quot;China&quot;);  name.setUnderline(0.2f, -2f);  director.add(name);  director.add(new Chunk(&quot;,&quot;));  director.add(new Chunk(&quot; &quot;));  director.add(new Chunk(&quot;chinese&quot;));  director.setLeading(24);  document.add(director);  Phrase director2 = new Phrase();  Chunk name2 = new Chunk(&quot;Japan&quot;);  name2.setUnderline(0.2f, -2f);  director2.add(name2);  director2.add(new Chunk(&quot;,&quot;));  director2.add(new Chunk(&quot; &quot;));  director2.add(new Chunk(&quot;japanese&quot;));  director2.setLeading(24);  document.add(director2);  //Paragraph对象: a Phrase with extra properties and a newline  document.newPage();  document.add(new Paragraph(&quot;Paragraph page&quot;));  Paragraph info = new Paragraph();  info.add(new Chunk(&quot;China &quot;));  info.add(new Chunk(&quot;chinese&quot;));  info.add(Chunk.NEWLINE);  info.add(new Phrase(&quot;Japan &quot;));  info.add(new Phrase(&quot;japanese&quot;));  document.add(info);  //List对象: a sequence of Paragraphs called ListItem  document.newPage();  List list = new List(List.ORDERED);  for (int i = 0; i &lt; 10; i++) {      ListItem item = new ListItem(String.format(&quot;%s: %d movies&quot;,              &quot;country&quot; + (i + 1), (i + 1) * 100), new Font(              Font.FontFamily.HELVETICA, 6, Font.BOLD, BaseColor.WHITE));      List movielist = new List(List.ORDERED, List.ALPHABETICAL);      movielist.setLowercase(List.LOWERCASE);      for (int j = 0; j &lt; 5; j++) {          ListItem movieitem = new ListItem(&quot;Title&quot; + (j + 1));          List directorlist = new List(List.UNORDERED);          for (int k = 0; k &lt; 3; k++) {              directorlist.add(String.format(&quot;%s, %s&quot;, &quot;Name1&quot; + (k + 1),                      &quot;Name2&quot; + (k + 1)));          }          movieitem.add(directorlist);          movielist.add(movieitem);      }      item.add(movielist);      list.add(item);  }  document.add(list);</code></pre><h2 id="插入Anchor-Image-Chapter-Section"><a href="#插入Anchor-Image-Chapter-Section" class="headerlink" title="插入Anchor, Image, Chapter, Section"></a>插入Anchor, Image, Chapter, Section</h2><pre><code>//Anchor对象: internal and external links  Paragraph country = new Paragraph();  Anchor dest = new Anchor(&quot;china&quot;, new Font(Font.FontFamily.HELVETICA, 14, Font.BOLD, BaseColor.BLUE));  dest.setName(&quot;CN&quot;);  dest.setReference(&quot;http://www.china.com&quot;);//external  country.add(dest);  country.add(String.format(&quot;: %d sites&quot;, 10000));  document.add(country);  document.newPage();  Anchor toUS = new Anchor(&quot;Go to first page.&quot;, new Font(Font.FontFamily.HELVETICA, 14, Font.BOLD, BaseColor.BLUE));  toUS.setReference(&quot;#CN&quot;);//internal  document.add(toUS);  //Image对象  document.newPage();  Image img = Image.getInstance(&quot;resource/test.jpg&quot;);  img.setAlignment(Image.LEFT | Image.TEXTWRAP);  img.setBorder(Image.BOX);  img.setBorderWidth(10);  img.setBorderColor(BaseColor.WHITE);  img.scaleToFit(1000, 72);//大小  img.setRotationDegrees(-30);//旋转  document.add(img);  //Chapter, Section对象（目录）  document.newPage();  Paragraph title = new Paragraph(&quot;Title&quot;);  Chapter chapter = new Chapter(title, 1);  title = new Paragraph(&quot;Section A&quot;);  Section section = chapter.addSection(title);  section.setBookmarkTitle(&quot;bmk&quot;);  section.setIndentation(30);  section.setBookmarkOpen(false);  section.setNumberStyle(  Section.NUMBERSTYLE_DOTTED_WITHOUT_FINAL_DOT);  Section subsection = section.addSection(new Paragraph(&quot;Sub Section A&quot;));  subsection.setIndentationLeft(20);  subsection.setNumberDepth(1);  document.add(chapter);  </code></pre><h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><pre><code>//左右箭头  document.add(new VerticalPositionMark() {      public void draw(PdfContentByte canvas, float llx, float lly,              float urx, float ury, float y) {          canvas.beginText();          BaseFont bf = null;          try {              bf = BaseFont.createFont(BaseFont.ZAPFDINGBATS, &quot;&quot;, BaseFont.EMBEDDED);          } catch (Exception e) {              e.printStackTrace();          }          canvas.setFontAndSize(bf, 12);          // LEFT          canvas.showTextAligned(Element.ALIGN_CENTER, String.valueOf((char) 220), llx - 10, y, 0);          // RIGHT          canvas.showTextAligned(Element.ALIGN_CENTER, String.valueOf((char) 220), urx + 10, y + 8, 180);          canvas.endText();      }  });  //直线  Paragraph p1 = new Paragraph(&quot;LEFT&quot;);  p1.add(new Chunk(new LineSeparator()));  p1.add(&quot;R&quot;);  document.add(p1);  //点线  Paragraph p2 = new Paragraph(&quot;LEFT&quot;);  p2.add(new Chunk(new DottedLineSeparator()));  p2.add(&quot;R&quot;);  document.add(p2);  //下滑线  LineSeparator UNDERLINE = new LineSeparator(1, 100, null, Element.ALIGN_CENTER, -2);  Paragraph p3 = new Paragraph(&quot;NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN&quot;);  p3.add(UNDERLINE);  document.add(p3);  </code></pre><h2 id="设置段落"><a href="#设置段落" class="headerlink" title="设置段落"></a>设置段落</h2><pre><code>Paragraph p = new Paragraph(&quot;In the previous example, you added a header and footer with the showTextAligned() method. This example demonstrates that it’s sometimes more interesting to use PdfPTable and writeSelectedRows(). You can define a bottom border for each cell so that the header is underlined. This is the most elegant way to add headers and footers, because the table mechanism allows you to position and align lines, images, and text.&quot;);  //默认  p.setAlignment(Element.ALIGN_JUSTIFIED);  document.add(p);  document.newPage();  p.setAlignment(Element.ALIGN_JUSTIFIED);  p.setIndentationLeft(1 * 15f);  p.setIndentationRight((5 - 1) * 15f);  document.add(p);  //居右  document.newPage();  p.setAlignment(Element.ALIGN_RIGHT);  p.setSpacingAfter(15f);  document.add(p);  //居左  document.newPage();  p.setAlignment(Element.ALIGN_LEFT);  p.setSpacingBefore(15f);  document.add(p);  //居中  document.newPage();  p.setAlignment(Element.ALIGN_CENTER);  p.setSpacingAfter(15f);  p.setSpacingBefore(15f);  document.add(p);  </code></pre><h2 id="删除Page"><a href="#删除Page" class="headerlink" title="删除Page"></a>删除Page</h2><pre><code>FileOutputStream out = new FileOutputStream(FILE_DIR + &quot;deletePage.pdf&quot;);  Document document = new Document();  PdfWriter writer = PdfWriter.getInstance(document, out);  document.open();  document.add(new Paragraph(&quot;First page&quot;));  document.add(new Paragraph(Document.getVersion()));  document.newPage();  writer.setPageEmpty(false);  document.newPage();  document.add(new Paragraph(&quot;New page&quot;));  document.close();  PdfReader reader = new PdfReader(FILE_DIR + &quot;deletePage.pdf&quot;);  reader.selectPages(&quot;1,3&quot;);  PdfStamper stamp = new PdfStamper(reader, new FileOutputStream(FILE_DIR          + &quot;deletePage2.pdf&quot;));  stamp.close();  reader.close();  </code></pre><h2 id="插入Page"><a href="#插入Page" class="headerlink" title="插入Page"></a>插入Page</h2><pre><code>FileOutputStream out = new FileOutputStream(FILE_DIR + &quot;insertPage.pdf&quot;);  Document document = new Document();  PdfWriter.getInstance(document, out);  document.open();  document.add(new Paragraph(&quot;1 page&quot;));  document.newPage();  document.add(new Paragraph(&quot;2 page&quot;));  document.newPage();  document.add(new Paragraph(&quot;3 page&quot;));  document.close();  PdfReader reader = new PdfReader(FILE_DIR + &quot;insertPage.pdf&quot;);  PdfStamper stamp = new PdfStamper(reader, new FileOutputStream(FILE_DIR          + &quot;insertPage2.pdf&quot;));  stamp.insertPage(2, reader.getPageSize(1));  ColumnText ct = new ColumnText(null);  ct.addElement(new Paragraph(24, new Chunk(&quot;INSERT PAGE&quot;)));  ct.setCanvas(stamp.getOverContent(2));  ct.setSimpleColumn(36, 36, 559, 770);  stamp.close();  reader.close();  </code></pre><h2 id="排序page"><a href="#排序page" class="headerlink" title="排序page"></a>排序page</h2><pre><code>PdfWriter writer = PdfWriter.getInstance(doc, out);  writer.setLinearPageMode();  doc.open();  doc.add(new Paragraph(&quot;1 page&quot;));  doc.newPage();  doc.add(new Paragraph(&quot;2 page&quot;));  doc.newPage();  doc.add(new Paragraph(&quot;3 page&quot;));  doc.newPage();  doc.add(new Paragraph(&quot;4 page&quot;));  doc.newPage();  doc.add(new Paragraph(&quot;5 page&quot;));  int[] order = {4,3,2,1};  writer.reorderPages(order);  </code></pre><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><pre><code>// Code 1  document.add(new Chunk(&quot;Chapter 1&quot;).setLocalDestination(&quot;1&quot;));  document.newPage();  document.add(new Chunk(&quot;Chapter 2&quot;).setLocalDestination(&quot;2&quot;));  document.add(new Paragraph(new Chunk(&quot;Sub 2.1&quot;).setLocalDestination(&quot;2.1&quot;)));  document.add(new Paragraph(new Chunk(&quot;Sub 2.2&quot;).setLocalDestination(&quot;2.2&quot;)));  document.newPage();  document.add(new Chunk(&quot;Chapter 3&quot;).setLocalDestination(&quot;3&quot;));  // Code 2  PdfContentByte cb = writer.getDirectContent();  PdfOutline root = cb.getRootOutline();  // Code 3  @SuppressWarnings(&quot;unused&quot;)  PdfOutline oline1 = new PdfOutline(root, PdfAction.gotoLocalPage(&quot;1&quot;, false), &quot;Chapter 1&quot;);  PdfOutline oline2 = new PdfOutline(root, PdfAction.gotoLocalPage(&quot;2&quot;, false), &quot;Chapter 2&quot;);  oline2.setOpen(false);  @SuppressWarnings(&quot;unused&quot;)  PdfOutline oline2_1 = new PdfOutline(oline2, PdfAction.gotoLocalPage(&quot;2.1&quot;, false), &quot;Sub 2.1&quot;);  @SuppressWarnings(&quot;unused&quot;)  PdfOutline oline2_2 = new PdfOutline(oline2, PdfAction.gotoLocalPage(&quot;2.2&quot;, false), &quot;Sub 2.2&quot;);  @SuppressWarnings(&quot;unused&quot;)  PdfOutline oline3 = new PdfOutline(root, PdfAction.gotoLocalPage(&quot;3&quot;, false), &quot;Chapter 3&quot;);  </code></pre><h2 id="Header-Footer"><a href="#Header-Footer" class="headerlink" title="Header, Footer"></a>Header, Footer</h2><pre><code>PdfWriter writer = PdfWriter.getInstance(doc, new FileOutputStream(FILE_DIR + &quot;setHeaderFooter.pdf&quot;));  writer.setPageEvent(new PdfPageEventHelper() {      public void onEndPage(PdfWriter writer, Document document) {          PdfContentByte cb = writer.getDirectContent();          cb.saveState();          cb.beginText();          BaseFont bf = null;          try {              bf = BaseFont.createFont(BaseFont.HELVETICA, BaseFont.WINANSI, BaseFont.EMBEDDED);          } catch (Exception e) {              e.printStackTrace();          }          cb.setFontAndSize(bf, 10);          //Header          float x = document.top(-20);          //左          cb.showTextAligned(PdfContentByte.ALIGN_LEFT,                             &quot;H-Left&quot;,                             document.left(), x, 0);          //中          cb.showTextAligned(PdfContentByte.ALIGN_CENTER,                              writer.getPageNumber()+ &quot; page&quot;,                             (document.right() + document.left())/2,                             x, 0);          //右          cb.showTextAligned(PdfContentByte.ALIGN_RIGHT,                             &quot;H-Right&quot;,                             document.right(), x, 0);          //Footer          float y = document.bottom(-20);          //左          cb.showTextAligned(PdfContentByte.ALIGN_LEFT,                             &quot;F-Left&quot;,                             document.left(), y, 0);          //中          cb.showTextAligned(PdfContentByte.ALIGN_CENTER,                              writer.getPageNumber()+&quot; page&quot;,                             (document.right() + document.left())/2,                             y, 0);          //右          cb.showTextAligned(PdfContentByte.ALIGN_RIGHT,                             &quot;F-Right&quot;,                             document.right(), y, 0);          cb.endText();          cb.restoreState();      }  });  doc.open();  doc.add(new Paragraph(&quot;1 page&quot;));          doc.newPage();  doc.add(new Paragraph(&quot;2 page&quot;));          doc.newPage();  doc.add(new Paragraph(&quot;3 page&quot;));          doc.newPage();  doc.add(new Paragraph(&quot;4 page&quot;));  </code></pre><h2 id="左右文字"><a href="#左右文字" class="headerlink" title="左右文字"></a>左右文字</h2><pre><code>PdfWriter writer = PdfWriter.getInstance(document, out);  document.open();  PdfContentByte canvas = writer.getDirectContent();  Phrase phrase1 = new Phrase(&quot;This is a test!left&quot;);  Phrase phrase2 = new Phrase(&quot;This is a test!right&quot;);  Phrase phrase3 = new Phrase(&quot;This is a test!center&quot;);  ColumnText.showTextAligned(canvas, Element.ALIGN_LEFT, phrase1, 10, 500, 0);  ColumnText.showTextAligned(canvas, Element.ALIGN_RIGHT, phrase2, 10, 536, 0);  ColumnText.showTextAligned(canvas, Element.ALIGN_CENTER, phrase3, 10, 572, 0);  </code></pre><h2 id="幻灯片放映"><a href="#幻灯片放映" class="headerlink" title="幻灯片放映"></a>幻灯片放映</h2><pre><code>PdfWriter writer = PdfWriter.getInstance(doc, out);  writer.setPdfVersion(PdfWriter.VERSION_1_5);  writer.setViewerPreferences(PdfWriter.PageModeFullScreen);//全屏  writer.setPageEvent(new PdfPageEventHelper() {      public void onStartPage(PdfWriter writer, Document document) {          writer.setTransition(new PdfTransition(PdfTransition.DISSOLVE, 3));          writer.setDuration(5);//间隔时间      }  });  doc.open();  doc.add(new Paragraph(&quot;1 page&quot;));  doc.newPage();  doc.add(new Paragraph(&quot;2 page&quot;));  doc.newPage();  doc.add(new Paragraph(&quot;3 page&quot;));  doc.newPage();  doc.add(new Paragraph(&quot;4 page&quot;));  doc.newPage();  doc.add(new Paragraph(&quot;5 page&quot;));  </code></pre><h2 id="压缩PDF到Zip"><a href="#压缩PDF到Zip" class="headerlink" title="压缩PDF到Zip"></a>压缩PDF到Zip</h2><pre><code>ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(FILE_DIR + &quot;zipPDF.zip&quot;));  for (int i = 1; i &lt;= 3; i++) {      ZipEntry entry = new ZipEntry(&quot;hello_&quot; + i + &quot;.pdf&quot;);      zip.putNextEntry(entry);      Document document = new Document();      PdfWriter writer = PdfWriter.getInstance(document, zip);      writer.setCloseStream(false);      document.open();      document.add(new Paragraph(&quot;Hello &quot; + i));      document.close();      zip.closeEntry();  }  zip.close();  </code></pre><h2 id="分割PDF"><a href="#分割PDF" class="headerlink" title="分割PDF"></a>分割PDF</h2><pre><code>FileOutputStream out = new FileOutputStream(FILE_DIR + &quot;splitPDF.pdf&quot;);  Document document = new Document();  PdfWriter.getInstance(document, out);  document.open();  document.add(new Paragraph(&quot;1 page&quot;));  document.newPage();  document.add(new Paragraph(&quot;2 page&quot;));  document.newPage();  document.add(new Paragraph(&quot;3 page&quot;));  document.newPage();  document.add(new Paragraph(&quot;4 page&quot;));  document.close();  PdfReader reader = new PdfReader(FILE_DIR + &quot;splitPDF.pdf&quot;);  Document dd = new Document();  PdfWriter writer = PdfWriter.getInstance(dd, new FileOutputStream(FILE_DIR + &quot;splitPDF1.pdf&quot;));  dd.open();  PdfContentByte cb = writer.getDirectContent();  dd.newPage();  cb.addTemplate(writer.getImportedPage(reader, 1), 0, 0);  dd.newPage();  cb.addTemplate(writer.getImportedPage(reader, 2), 0, 0);  dd.close();  writer.close();  Document dd2 = new Document();  PdfWriter writer2 = PdfWriter.getInstance(dd2, new FileOutputStream(FILE_DIR + &quot;splitPDF2.pdf&quot;));  dd2.open();  PdfContentByte cb2 = writer2.getDirectContent();  dd2.newPage();  cb2.addTemplate(writer2.getImportedPage(reader, 3), 0, 0);  dd2.newPage();  cb2.addTemplate(writer2.getImportedPage(reader, 4), 0, 0);  dd2.close();  writer2.close();  </code></pre><h2 id="合并PDF"><a href="#合并PDF" class="headerlink" title="合并PDF"></a>合并PDF</h2><pre><code>PdfReader reader1 = new PdfReader(FILE_DIR + &quot;splitPDF1.pdf&quot;);  PdfReader reader2 = new PdfReader(FILE_DIR + &quot;splitPDF2.pdf&quot;);  FileOutputStream out = new FileOutputStream(FILE_DIR + &quot;mergePDF.pdf&quot;);  Document document = new Document();  PdfWriter writer = PdfWriter.getInstance(document, out);  document.open();  PdfContentByte cb = writer.getDirectContent();  int totalPages = 0;  totalPages += reader1.getNumberOfPages();  totalPages += reader2.getNumberOfPages();  java.util.List&lt;PdfReader&gt; readers = new ArrayList&lt;PdfReader&gt;();  readers.add(reader1);  readers.add(reader2);  int pageOfCurrentReaderPDF = 0;  Iterator&lt;PdfReader&gt; iteratorPDFReader = readers.iterator();  // Loop through the PDF files and add to the output.  while (iteratorPDFReader.hasNext()) {      PdfReader pdfReader = iteratorPDFReader.next();      // Create a new page in the target for each source page.      while (pageOfCurrentReaderPDF &lt; pdfReader.getNumberOfPages()) {          document.newPage();          pageOfCurrentReaderPDF++;          PdfImportedPage page = writer.getImportedPage(pdfReader, pageOfCurrentReaderPDF);          cb.addTemplate(page, 0, 0);      }      pageOfCurrentReaderPDF = 0;  }  out.flush();  document.close();  out.close();  </code></pre><h2 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h2><pre><code>PdfWriter writer = PdfWriter.getInstance(doc, out);  writer.setLinearPageMode();  doc.open();  doc.add(new Paragraph(&quot;1 page&quot;));  doc.add(new Annotation(&quot;Title&quot;, &quot;This is a annotation!&quot;));  doc.newPage();  doc.add(new Paragraph(&quot;2 page&quot;));  Chunk chunk = new Chunk(&quot;\u00a0&quot;);  chunk.setAnnotation(PdfAnnotation.createText(writer, null, &quot;Title&quot;, &quot;This is a another annotation!&quot;, false, &quot;Comment&quot;));  doc.add(chunk);  //添加附件  doc.newPage();  doc.add(new Paragraph(&quot;3 page&quot;));  Chunk chunk2 = new Chunk(&quot;\u00a0\u00a0&quot;);  PdfAnnotation annotation = PdfAnnotation.createFileAttachment(          writer, null, &quot;Title&quot;, null,          &quot;resource/test2.jpg&quot;,          &quot;img.jpg&quot;);  annotation.put(PdfName.NAME,          new PdfString(&quot;Paperclip&quot;));  chunk2.setAnnotation(annotation);  doc.add(chunk2);  </code></pre><h2 id="插入一个Table"><a href="#插入一个Table" class="headerlink" title="插入一个Table"></a>插入一个Table</h2><pre><code>PdfPTable table = new PdfPTable(3);  PdfPCell cell;  cell = new PdfPCell(new Phrase(&quot;Cell with colspan 3&quot;));  cell.setColspan(3);  table.addCell(cell);  cell = new PdfPCell(new Phrase(&quot;Cell with rowspan 2&quot;));  cell.setRowspan(2);  table.addCell(cell);  table.addCell(&quot;row 1; cell 1&quot;);  table.addCell(&quot;row 1; cell 2&quot;);  table.addCell(&quot;row 2; cell 1&quot;);  table.addCell(&quot;row 2; cell 2&quot;);  document.add(table);  </code></pre><h2 id="表格嵌套"><a href="#表格嵌套" class="headerlink" title="表格嵌套"></a>表格嵌套</h2><pre><code>PdfPTable table = new PdfPTable(4);  //1行2列  PdfPTable nested1 = new PdfPTable(2);  nested1.addCell(&quot;1.1&quot;);  nested1.addCell(&quot;1.2&quot;);  //2行1列  PdfPTable nested2 = new PdfPTable(1);  nested2.addCell(&quot;2.1&quot;);  nested2.addCell(&quot;2.2&quot;);  //将表格插入到指定位置  for (int k = 0; k &lt; 24; ++k) {      if (k == 1) {          table.addCell(nested1);      } else if (k == 20) {          table.addCell(nested2);      } else {          table.addCell(&quot;cell &quot; + k);      }  }  document.add(table);  </code></pre><h2 id="设置表格宽度"><a href="#设置表格宽度" class="headerlink" title="设置表格宽度"></a>设置表格宽度</h2><pre><code>PdfPTable table = new PdfPTable(3);  PdfPCell cell;  cell = new PdfPCell(new Phrase(&quot;Cell with colspan 3&quot;));  cell.setColspan(3);  table.addCell(cell);  cell = new PdfPCell(new Phrase(&quot;Cell with rowspan 2&quot;));  cell.setRowspan(2);  table.addCell(cell);  table.addCell(&quot;row 1; cell 1&quot;);  table.addCell(&quot;row 1; cell 2&quot;);  table.addCell(&quot;row 2; cell 1&quot;);  table.addCell(&quot;row 2; cell 2&quot;);  //100%  table.setWidthPercentage(100);  document.add(table);          document.add(new Paragraph(&quot;\n\n&quot;));  //宽度50% 居左  table.setHorizontalAlignment(Element.ALIGN_LEFT);  document.add(table);  document.add(new Paragraph(&quot;\n\n&quot;));  //宽度50% 居中  table.setHorizontalAlignment(Element.ALIGN_CENTER);  document.add(table);  document.add(new Paragraph(&quot;\n\n&quot;));  //宽度50% 居右  table.setWidthPercentage(50);  table.setHorizontalAlignment(Element.ALIGN_RIGHT);  document.add(table);  document.add(new Paragraph(&quot;\n\n&quot;));  //固定宽度  table.setTotalWidth(300);  table.setLockedWidth(true);  document.add(table);  </code></pre><h2 id="设置表格前后间隔"><a href="#设置表格前后间隔" class="headerlink" title="设置表格前后间隔"></a>设置表格前后间隔</h2><pre><code>PdfPTable table = new PdfPTable(3);  PdfPCell cell = new PdfPCell(new Paragraph(&quot;合并3个单元格&quot;,fontZH));  cell.setColspan(3);  table.addCell(cell);  table.addCell(&quot;1.1&quot;);  table.addCell(&quot;2.1&quot;);  table.addCell(&quot;3.1&quot;);  table.addCell(&quot;1.2&quot;);  table.addCell(&quot;2.2&quot;);  table.addCell(&quot;3.2&quot;);  cell = new PdfPCell(new Paragraph(&quot;红色边框&quot;,fontZH));  cell.setBorderColor(new BaseColor(255, 0, 0));  table.addCell(cell);  cell = new PdfPCell(new Paragraph(&quot;合并单2个元格&quot;,fontZH));  cell.setColspan(2);  cell.setBackgroundColor(new BaseColor(0xC0, 0xC0, 0xC0));  table.addCell(cell);  table.setWidthPercentage(50);  document.add(new Paragraph(&quot;追加2个表格&quot;,fontZH));  document.add(table);  document.add(table);  document.newPage();  document.add(new Paragraph(&quot;使用&apos;SpacingBefore&apos;和&apos;setSpacingAfter&apos;&quot;,fontZH));  table.setSpacingBefore(15f);  document.add(table);  document.add(table);  document.add(new Paragraph(&quot;这里没有间隔&quot;,fontZH));  table.setSpacingAfter(15f);  </code></pre><h2 id="设置单元格宽度"><a href="#设置单元格宽度" class="headerlink" title="设置单元格宽度"></a>设置单元格宽度</h2><pre><code>//按比例设置单元格宽度  float[] widths = {0.1f, 0.1f, 0.05f, 0.75f};  PdfPTable table = new PdfPTable(widths);  table.addCell(&quot;10%&quot;);  table.addCell(&quot;10%&quot;);  table.addCell(&quot;5%&quot;);  table.addCell(&quot;75%&quot;);  table.addCell(&quot;aa&quot;);  table.addCell(&quot;aa&quot;);  table.addCell(&quot;a&quot;);  table.addCell(&quot;aaaaaaaaaaaaaaa&quot;);  table.addCell(&quot;bb&quot;);  table.addCell(&quot;bb&quot;);  table.addCell(&quot;b&quot;);  table.addCell(&quot;bbbbbbbbbbbbbbb&quot;);  table.addCell(&quot;cc&quot;);  table.addCell(&quot;cc&quot;);  table.addCell(&quot;c&quot;);  table.addCell(&quot;ccccccccccccccc&quot;);  document.add(table);  document.add(new Paragraph(&quot;\n\n&quot;));  //调整比例  widths[0] = 20f;  widths[1] = 20f;  widths[2] = 10f;  widths[3] = 50f;  table.setWidths(widths);  document.add(table);  //按绝对值设置单元格宽度  widths[0] = 40f;  widths[1] = 40f;  widths[2] = 20f;  widths[3] = 300f;  Rectangle r = new Rectangle(PageSize.A4.getRight(72), PageSize.A4.getTop(72));  table.setWidthPercentage(widths, r);  document.add(new Paragraph(&quot;\n\n&quot;));  document.add(table);  </code></pre><h2 id="设置单元格高度"><a href="#设置单元格高度" class="headerlink" title="设置单元格高度"></a>设置单元格高度</h2><pre><code>PdfPTable table = new PdfPTable(2);  PdfPCell cell;  //折行  table.addCell(new PdfPCell(new Paragraph(&quot;折行&quot;, fontZH)));  cell = new PdfPCell(new Paragraph(&quot;blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah&quot;));  cell.setNoWrap(false);  table.addCell(cell);  //不折行  table.addCell(new PdfPCell(new Paragraph(&quot;不折行&quot;, fontZH)));  cell.setNoWrap(true);  table.addCell(cell);  //设置高度  table.addCell(new PdfPCell(new Paragraph(&quot;任意高度&quot;,fontZH)));  cell = new PdfPCell(new Paragraph(&quot;1. blah blah\n2. blah blah blah\n3. blah blah\n4. blah blah blah\n5. blah blah\n6. blah blah blah\n7. blah blah\n8. blah blah blah&quot;));  table.addCell(cell);  //固定高度  table.addCell(new PdfPCell(new Paragraph(&quot;固定高度&quot;,fontZH)));  cell.setFixedHeight(50f);  table.addCell(cell);  //最小高度  table.addCell(new PdfPCell(new Paragraph(&quot;最小高度&quot;,fontZH)));  cell = new PdfPCell(new Paragraph(&quot;最小高度：50&quot;,fontZH));  cell.setMinimumHeight(50f);  table.addCell(cell);  //最后一行拉长到page底部  table.setExtendLastRow(true);  table.addCell(new PdfPCell(new Paragraph(&quot;拉长最后一行&quot;,fontZH)));  cell = new PdfPCell(new Paragraph(&quot;最后一行拉长到page底部&quot;,fontZH));  table.addCell(cell);  document.add(table);  </code></pre><h2 id="设置单元格颜色"><a href="#设置单元格颜色" class="headerlink" title="设置单元格颜色"></a>设置单元格颜色</h2><pre><code>PdfPTable table = new PdfPTable(4);  PdfPCell cell;  cell = new PdfPCell(new Paragraph(&quot;颜色测试&quot;,fontZH));  table.addCell(cell);  //红色背景，无边框  cell = new PdfPCell(new Paragraph(&quot;红色背景，无边框&quot;,fontZH));  cell.setBorder(Rectangle.NO_BORDER);  cell.setBackgroundColor(BaseColor.RED);  table.addCell(cell);  //绿色背景，下边框  cell = new PdfPCell(new Paragraph(&quot;绿色背景，下边框&quot;,fontZH));  cell.setBorder(Rectangle.BOTTOM);  cell.setBorderColorBottom(BaseColor.MAGENTA);  cell.setBorderWidthBottom(5f);  cell.setBackgroundColor(BaseColor.GREEN);  table.addCell(cell);  //蓝色背景，上边框  cell = new PdfPCell(new Paragraph(&quot;蓝色背景，上边框&quot;,fontZH));  cell.setBorder(Rectangle.TOP);  cell.setUseBorderPadding(true);  cell.setBorderWidthTop(5f);  cell.setBorderColorTop(BaseColor.CYAN);  cell.setBackgroundColor(BaseColor.BLUE);  table.addCell(cell);  cell = new PdfPCell(new Paragraph(&quot;背景灰色度&quot;,fontZH));  table.addCell(cell);  cell = new PdfPCell(new Paragraph(&quot;0.25&quot;));  cell.setBorder(Rectangle.NO_BORDER);  cell.setGrayFill(0.25f);  table.addCell(cell);  cell = new PdfPCell(new Paragraph(&quot;0.5&quot;));  cell.setBorder(Rectangle.NO_BORDER);  cell.setGrayFill(0.5f);  table.addCell(cell);  cell = new PdfPCell(new Paragraph(&quot;0.75&quot;));  cell.setBorder(Rectangle.NO_BORDER);  cell.setGrayFill(0.75f);  table.addCell(cell);  document.add(table);  </code></pre><h2 id="插入图像"><a href="#插入图像" class="headerlink" title="插入图像"></a>插入图像</h2><pre><code>Image image = Image.getInstance(&quot;resource/test2.jpg&quot;);  float[] widths = { 1f, 4f };  PdfPTable table = new PdfPTable(widths);  //插入图片  table.addCell(new PdfPCell(new Paragraph(&quot;图片测试&quot;, fontZH)));  table.addCell(image);  //调整图片大小  table.addCell(&quot;This two&quot;);  table.addCell(new PdfPCell(image, true));  //不调整  table.addCell(&quot;This three&quot;);  table.addCell(new PdfPCell(image, false));  document.add(table);  </code></pre><h2 id="设置表头"><a href="#设置表头" class="headerlink" title="设置表头"></a>设置表头</h2><pre><code>String[] bogusData = { &quot;M0065920&quot;, &quot;SL&quot;, &quot;FR86000P&quot;, &quot;PCGOLD&quot;,          &quot;119000&quot;, &quot;96 06&quot;, &quot;2001-08-13&quot;, &quot;4350&quot;, &quot;6011648299&quot;,          &quot;FLFLMTGP&quot;, &quot;153&quot;, &quot;119000.00&quot; };  int NumColumns = 12;  // 12  PdfPTable datatable = new PdfPTable(NumColumns);  int headerwidths[] = { 9, 4, 8, 10, 8, 11, 9, 7, 9, 10, 4, 10 }; // percentage  datatable.setWidths(headerwidths);  datatable.setWidthPercentage(100);  datatable.getDefaultCell().setPadding(3);  datatable.getDefaultCell().setBorderWidth(2);  datatable.getDefaultCell().setHorizontalAlignment(Element.ALIGN_CENTER);  datatable.addCell(&quot;Clock #&quot;);  datatable.addCell(&quot;Trans Type&quot;);  datatable.addCell(&quot;Cusip&quot;);  datatable.addCell(&quot;Long Name&quot;);  datatable.addCell(&quot;Quantity&quot;);  datatable.addCell(&quot;Fraction Price&quot;);  datatable.addCell(&quot;Settle Date&quot;);  datatable.addCell(&quot;Portfolio&quot;);  datatable.addCell(&quot;ADP Number&quot;);  datatable.addCell(&quot;Account ID&quot;);  datatable.addCell(&quot;Reg Rep ID&quot;);  datatable.addCell(&quot;Amt To Go &quot;);  datatable.setHeaderRows(1);  //边框  datatable.getDefaultCell().setBorderWidth(1);  //背景色  for (int i = 1; i &lt; 1000; i++) {      for (int x = 0; x &lt; NumColumns; x++) {          datatable.addCell(bogusData[x]);      }  }  document.add(datatable);  </code></pre><h2 id="分割表格"><a href="#分割表格" class="headerlink" title="分割表格"></a>分割表格</h2><pre><code>//横向分割  PdfContentByte cb = writer.getDirectContent();  PdfPTable table = new PdfPTable(10);  for (int k = 1; k &lt;= 100; ++k) {      table.addCell(&quot;The number &quot; + k);  }  table.setTotalWidth(400);  table.writeSelectedRows(0, 5, 0, -1, 5, 700, cb);  table.writeSelectedRows(5, -1, 0, -1, 210, 700, cb);  </code></pre><h2 id="设置单元格留白"><a href="#设置单元格留白" class="headerlink" title="设置单元格留白"></a>设置单元格留白</h2><pre><code>PdfPTable table = new PdfPTable(2);  PdfPCell cell;  Paragraph p = new Paragraph(&quot;Quick brown fox jumps over the lazy dog. Quick brown fox jumps over the lazy dog.&quot;);  table.addCell(new PdfPCell(new Paragraph(&quot;默认&quot;,fontZH)));  table.addCell(p);  table.addCell(new PdfPCell(new Paragraph(&quot;Padding：10&quot;,fontZH)));  cell = new PdfPCell(p);  cell.setPadding(10f);  table.addCell(cell);  table.addCell(new PdfPCell(new Paragraph(&quot;Padding：0&quot;,fontZH)));  cell = new PdfPCell(p);  cell.setPadding(0f);  table.addCell(cell);  table.addCell(new PdfPCell(new Paragraph(&quot;上Padding：0 左Padding：20&quot;,fontZH)));  cell = new PdfPCell(p);  cell.setPaddingTop(0f);  cell.setPaddingLeft(20f);  table.addCell(cell);  document.add(table);  document.newPage();  table = new PdfPTable(2);  table.addCell(new PdfPCell(new Paragraph(&quot;没有Leading&quot;,fontZH)));  table.getDefaultCell().setLeading(0f, 0f);  table.addCell(&quot;blah blah\nblah blah blah\nblah blah\nblah blah blah\nblah blah\nblah blah blah\nblah blah\nblah blah blah\n&quot;);  table.getDefaultCell().setLeading(14f, 0f);  table.addCell(new PdfPCell(new Paragraph(&quot;固定Leading：14pt&quot;,fontZH)));  table.addCell(&quot;blah blah\nblah blah blah\nblah blah\nblah blah blah\nblah blah\nblah blah blah\nblah blah\nblah blah blah\n&quot;);  table.addCell(new PdfPCell(new Paragraph(&quot;相对于字体&quot;,fontZH)));  table.getDefaultCell().setLeading(0f, 1.0f);  table.addCell(&quot;blah blah\nblah blah blah\nblah blah\nblah blah blah\nblah blah\nblah blah blah\nblah blah\nblah blah blah\n&quot;);  document.add(table);  设置单元格边框 //没有边框  PdfPTable table1 = new PdfPTable(3);    table1.getDefaultCell().setBorder(PdfPCell.NO_BORDER);    table1.addCell(new Paragraph(&quot;Cell 1&quot;));   table1.addCell(new Paragraph(&quot;Cell 2&quot;));   table1.addCell(new Paragraph(&quot;Cell 3&quot;));   document.add(table1);  //边框粗细颜色  document.newPage();  Rectangle b1 = new Rectangle(0f, 0f);  b1.setBorderWidthLeft(6f);  b1.setBorderWidthBottom(5f);  b1.setBorderWidthRight(4f);  b1.setBorderWidthTop(2f);  b1.setBorderColorLeft(BaseColor.RED);  b1.setBorderColorBottom(BaseColor.ORANGE);  b1.setBorderColorRight(BaseColor.YELLOW);  b1.setBorderColorTop(BaseColor.GREEN);  PdfPTable table2 = new PdfPTable(1);  PdfPCell cell =  new PdfPCell(new Paragraph(&quot;Cell 1&quot;));  cell.cloneNonPositionParameters(b1);  table2.addCell(cell);  document.add(table2);  </code></pre><h2 id="生成Barcode-QRCode"><a href="#生成Barcode-QRCode" class="headerlink" title="生成Barcode QRCode"></a>生成Barcode QRCode</h2><pre><code>String myString = &quot;http://www.google.com&quot;;  Barcode128 code128 = new Barcode128();  code128.setCode(myString.trim());  code128.setCodeType(Barcode128.CODE128);  Image code128Image = code128.createImageWithBarcode(cb, null, null);  code128Image.setAbsolutePosition(10,700);  code128Image.scalePercent(125);  doc.add(code128Image);  BarcodeQRCode qrcode = new BarcodeQRCode(myString.trim(), 1, 1, null);  Image qrcodeImage = qrcode.getImage();  qrcodeImage.setAbsolutePosition(10,600);  qrcodeImage.scalePercent(200);  doc.add(qrcodeImage);  </code></pre><h2 id="HTML-to-PDF"><a href="#HTML-to-PDF" class="headerlink" title="HTML to PDF"></a>HTML to PDF</h2><pre><code>Document document = new Document(PageSize.LETTER);  PdfWriter.getInstance(document, new FileOutputStream(&quot;c://testpdf1.pdf&quot;));  document.open();  HTMLWorker htmlWorker = new HTMLWorker(document);  htmlWorker.parse(new StringReader(&quot;&lt;h1&gt;This is a test!&lt;/h1&gt;&quot;));  document.close();        </code></pre><h1 id="JFreeReport"><a href="#JFreeReport" class="headerlink" title="JFreeReport"></a>JFreeReport</h1><p>JFreeReport的数据继承自Swing组件的TableModel接口。JFreeReport生成的报表可以分页预览、打印或者保存为多种格式的文件包括pdf、Excel、html等。<br>该项目主页:<a href="http://www.jfree.org/jfreereport/" target="_blank" rel="noopener">http://www.jfree.org/jfreereport/</a></p><h1 id="PJX"><a href="#PJX" class="headerlink" title="PJX"></a>PJX</h1><p>PJX支持读取，组合，处理，和生成PDF文档（注意：PJX需要 J2SE 1.4.0 或更高版本）。<br>该项目主页:<a href="http://www.etymon.com/epub.html" target="_blank" rel="noopener">http://www.etymon.com/epub.html</a></p><h1 id="Apache-FOP"><a href="#Apache-FOP" class="headerlink" title="Apache FOP"></a>Apache FOP</h1><p>FOP是由James Tauber发起的一个开源项目，原先的版本是利用xsl-fo将xml文件转换成pdf文件。但最新的版本它可以将xml文件转换成pdf，mif，pcl，txt等多种格式以及直接输出到打印机，并且支持使用SVG描述图形。<br>该项目主页:<a href="http://xml.apache.org/fop/" target="_blank" rel="noopener">http://xml.apache.org/fop/</a></p><h1 id="gnujpdf"><a href="#gnujpdf" class="headerlink" title="gnujpdf"></a>gnujpdf</h1><p>gnujpdf是一个java类包(gnu.jpdf.*),它提供了一个简单的API来创建与打印PDF文件。遵循LGPL开源协议。<br>该项目主页:<a href="http://gnujpdf.sourceforge.net/" target="_blank" rel="noopener">http://gnujpdf.sourceforge.net/</a></p><h1 id="PDF-Box"><a href="#PDF-Box" class="headerlink" title="PDF Box"></a>PDF Box</h1><p>PDFBox是一个开源的可以操作PDF文档的Java PDF类库。它可以创建一个新PDF文档,操作现有PDF文档并提取文档中的内容。<br>它具有以下特性:<br>1.将一个PDF文档转换输出为一个文本文件。<br>2.可以从文本文件创建一个PDF文档。<br>3.加密/解密PDF文档。<br>4.向已有PDF文档中追加内容。<br>5.可以从PDF文档生成一张图片。<br>6.可以与Jakarta Lucene搜索引擎的整合。<br>该项目主页:<a href="http://www.pdfbox.org/" target="_blank" rel="noopener">http://www.pdfbox.org/</a></p><h1 id="Connla"><a href="#Connla" class="headerlink" title="Connla"></a>Connla</h1><p>Connla是一个Java包用于创建可导成TXT,CSV,HTML,XHTML,XML,PDF和XLS等格式的数据集。<br>该项目主页:<a href="http://connla.sourceforge.net/" target="_blank" rel="noopener">http://connla.sourceforge.net/</a></p><h1 id="PDF-Split-amp-Merge"><a href="#PDF-Split-amp-Merge" class="headerlink" title="PDF Split &amp; Merge"></a>PDF Split &amp; Merge</h1><p>PDF Split&amp;Merge是一款实用基于GPL许可协议发布的PDF文件分割与合并工具。您可以指定页码范围将一个PDF文件分割为若干PDF 文件(支持单页和多页混合)，或将多个PDF文件按指定顺序合并成一个PDF文件。其转换速度非常快。它采用Java Swing开发,运用到的第三方组件包括：iText,jcmdline和JGoodies界面包。<br>该项目主页:<a href="http://pdfsam.sourceforge.net/" target="_blank" rel="noopener">http://pdfsam.sourceforge.net/</a></p><h1 id="PDF-Clown-for-Java"><a href="#PDF-Clown-for-Java" class="headerlink" title="PDF Clown for Java"></a>PDF Clown for Java</h1><p>PDF Clown for Java是一个基于Java1.5用于读，写和操作PDF文档的Java类包。它提供多个抽象层来满足不同的编程风格：从底层(PDF对象模型)到高级(PDF文档结构和内容流)。<br>该项目主页:<a href="http://www.stefanochizzolini.it/en/projects/clown/" target="_blank" rel="noopener">http://www.stefanochizzolini.it/en/projects/clown/</a></p><h1 id="iText-toolbox"><a href="#iText-toolbox" class="headerlink" title="iText toolbox"></a>iText toolbox</h1><p>iText toolbox是一个Java Swing应用程序,其起初是iText类库的一部分。iText toolbox既可以作为一个可执行的Jar，也可作为Java Webstart应用程序运行。对于完成各种类型的PDF相关文件操作，iText toolbox是一个非常有用的工具比如：把一个目录下的所有图片转换成一个PDF文档，合并现有PDF文档等。此外开发人员可以把它当成一个学习iText类库各项功能的工具。<br>该项目主页:<a href="http://itexttoolbox.sourceforge.net/" target="_blank" rel="noopener">http://itexttoolbox.sourceforge.net/</a></p><h1 id="PDFjet"><a href="#PDFjet" class="headerlink" title="PDFjet"></a>PDFjet</h1><p>PDFjet是一个用于动态生成PDF文档的Java类库。支持绘制点、线、方框、圆、贝塞尔曲线(Bezier Curves) 、多边形、星形、复杂路径和形状。支持unicode，文本间距调整，嵌入超链接等。<br>该项目主页:<a href="http://pdfjet.com/os/edition.html" target="_blank" rel="noopener">http://pdfjet.com/os/edition.html</a></p><h1 id="ICEpdf"><a href="#ICEpdf" class="headerlink" title="ICEpdf"></a>ICEpdf</h1><p>ICEpdf是一个开源Java PDF引擎，用于展示/查看PDF文档，转换和抽取PDF文档的内容。可以集成到Java桌面应用程序或Web服务器中使用。<br>该项目主页:<a href="http://www.icepdf.org/" target="_blank" rel="noopener">http://www.icepdf.org/</a></p><h1 id="JSignPdf"><a href="#JSignPdf" class="headerlink" title="JSignPdf"></a>JSignPdf</h1><p>JSignPdf是一个用于为PDF文档添加数字签名的Java应用程序。它既可以单独使用，也可以作为OpenOffice.org的插件使用。支持设置验证级别，PDF加密和设置权限，添加签名图标，批量转换（通过命令行参数控制）。<br>该项目主页:<a href="http://jsignpdf.sourceforge.net/" target="_blank" rel="noopener">http://jsignpdf.sourceforge.net/</a></p><h1 id="PDF-Renderer"><a href="#PDF-Renderer" class="headerlink" title="PDF Renderer"></a>PDF Renderer</h1><p>PDF Renderer是一个采用纯Java实现的PDF阅读器和渲染器。 可以利用它实现在你的应用中查看PDF文件；在导出PDF文件之前进行预览；在服务器端Web应用中将PDF转成PNGs图片；在一个3D场景中查看PDF。<br>该项目主页:<a href="https://pdf-renderer.dev.java.net/" target="_blank" rel="noopener">https://pdf-renderer.dev.java.net/</a></p><p>文章来自 <a href="http://blog.csdn.net/rongbo_j/article/details/50196909" target="_blank" rel="noopener">http://blog.csdn.net/rongbo_j/article/details/50196909</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;iText&quot;&gt;&lt;a href=&quot;#iText&quot; class=&quot;headerlink&quot; title=&quot;iText&quot;&gt;&lt;/a&gt;iText&lt;/h1&gt;&lt;p&gt;iText是一个能够快速产生PDF文件的java类库。iText的java类对于那些要产生包含文本，表格，图形的只读文档是很有用的。它的类库尤其与java Servlet有很好的给合。使用iText与PDF能够使你正确的控制Servlet的输出。&lt;br&gt;该项目主页:&lt;a href=&quot;http://www.lowagie.com/iText/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.lowagie.com/iText/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;iText是著名的开放项目，是用于生成PDF文档的一个java类库。通过iText不仅可以生成PDF或rtf的文档，而且可以将XML、Html文件转化为PDF文件。&lt;/p&gt;
&lt;p&gt;Harness the power of PDF with iText&lt;/p&gt;
&lt;p&gt;Easy PDF generation and manipulation for Java and .NET developers&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="java类库" scheme="http://yoursite.com/tags/java%E7%B1%BB%E5%BA%93/"/>
    
  </entry>
  
</feed>
