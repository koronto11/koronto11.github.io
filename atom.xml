<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>刻写未来！</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-19T04:54:02.961Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>黄上</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>创业之路--关于风险投资</title>
    <link href="http://yoursite.com/2018/03/19/fengtou/"/>
    <id>http://yoursite.com/2018/03/19/fengtou/</id>
    <published>2018-03-19T04:39:15.000Z</published>
    <updated>2018-03-19T04:54:02.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于风投泄密及其保密协议"><a href="#关于风投泄密及其保密协议" class="headerlink" title="关于风投泄密及其保密协议"></a>关于风投泄密及其保密协议</h1><p>保密协议就属于防君子不防小人,特别是在商业模式、概念以及技术在早期还很不具象的时候(这恰恰都是初创公司所面临的情况),保密协议起到的作用就更小,因为连保护的标的都不清楚,总不能说保护一个头脑中的idea吧?即使起到作用,通过法律手段花上无数的时间和精力去索赔并成功,损失的时间和精力放在自己的梦想和创业上,是不是会更加划算?天使投资人最大的价值就是,给钱不捣乱,同时需要的时候提供不太计较的支持.</p><a id="more"></a><p>所以题主关心的方向不对,应该更关注如何找到靠谱的天使投资人,而不是在这种ROI极低的地方选择如何去保护自己的利益。如同找老公过日子,越是天使投资越容易走得远成为长期的婚姻关系,关注点更多在于如何选对人,而不是如何利用拉链守住门户.</p><p>而且还有一个基本原则,如果在天使阶段,一个潜在投资人对于你的技术绌节和实现方式如此关注,而对于创始人的人品以及公司的远景却不那么在乎。是不是有点熟悉的感觉,上来就问你的银行存折、小区档次等等?</p><p>保密协议的注意事项1、保密信息的范围从披露方来看，只要是自己提供给对方的非公知信息，都可以纳入保密信息的范围，包括关于自身的保密信息，也包括自己获准披露的第三方保密信息。另一方面，也不能范围过宽延伸到接受信息方已有或者自行开发的信息以及无关第三方披露等原因造成公开的信息，尤其是保密期限比较长的时候，接受信息方也可能因为各种现实原因无法承受过重的保密限制。</p><p>2、商业秘密上文提过，并非所有的保密信息都能构成商业秘密，商业秘密的保护须权利人采取保密措施，例如：技术措施以及要求接触到商业秘密的员工签署保密协议的法律措施等。商业秘密和普通的保密信息需要区分开来。针对保密信息双方可以商定一个有限的持续时间（很多信息因为技术发展几年后就根本没有保密的意义了），期间届满后则不再负有保密义务；但商业秘密则不能轻易地披露给对方，披露给对方也要注意保密措施，并且不受保密期限的限制。</p><p>3、知识产权专利等知识产权与商业秘密的保护方式各有利弊，此处不再展开。有些创意、方法和流程可能无法获得知识产权的保护，所以只能作为商业秘密并通过保密协议等方式防止保密信息进入公知领域。即便是能够申请专利的技术或方案，也需要在申请专利前注意保密，并与接触者签署保密协议，防止被公众所知破坏其新颖性，导致无法申请专利。</p><p>4、保密信息的使用限制保密协议不仅仅限制信息接受方不得对外披露保密信息，而且需要限制信息接受方对保密信息的使用范围和目的。一方面，信息接受方应当仅限于向项目合作过程中确需了解保密信息的人群披露，还要限制信息接受方使用于讨论、评估或依据各方协议约定实施项目合作之外的目的，<br>例如：不得因项目之外的目的擅自使用保密信息。此外，如果披露具有知识产权的内容则需要明确，依据保密协议进行的披露与知识产权的许可使用不同，为签约各方项目合作之目的披露给对方，并不意味着给予了对方知识产权的使用许可。结语保密协议仅仅是保护公司保密信息的一种常见手段，创业公司还需要提高保密意识，并结合技术手段以及知识产权等各种方式，更全面地保护自己来之不易的创造性成果。<br>如果运用得当，即便是创业公司也能有效对抗巨头“友商”窃取自己的劳动果实。</p><p>在《要求投资人签署保密协议 能否保护你的商业秘密》这篇文章中，我曾经表示，通过要求投资人签署保密协议的方式，不能从根本上保护自己的商业秘密。<br>那创业者在融资时，还需要与投资人签署保密协议吗？<br>答案是肯定的。也就是说，保密协议还是要签的。<br>既然它不能从根本上解决问题，那在这里为什么还要建议创业者与投资人签署保密协议呢？<br>因为尽管它不能从根本上解决问题，但毕竟能起一定的作用。而对有些投资人，这点作用就已经足够。<br>不同的投资人，愿意承担的违约风险不同。如果对方可以承受的违约风险幅度很大，那单靠一纸保密协议，不能引起他们足够重视，自然也约束不住他们。这时候，就要附加其他手段。但如果对方可以承受的违约风险幅度很小，那这一纸保密协议就能很好的约束对方。<br>同一份协议，在不同的投资人眼里分量不同，自然对其影响和制约能力也不同。<br>在《周永信说融资泄密17：Term Sheet前投资人不愿签署保密协议的原因及例外》这篇文章中，我也曾提到，投资人是不愿意签署保密协议的，但那指的是在Term Sheet之前。<br>真正到了谈判Term Sheet阶段，甚至尽职调查阶段，投资人是不会拒绝签署保密协议的。因为这是一种合理且常规的要求。到了这一阶段，如果创业者还不要求签署保密协议，投资人甚至会认为创业者不够成熟。因为保密意识是企业成功的必要要素之一，没有投资人愿意投资一个保密意识淡薄的创业者。<br>所以不管是为了保护自己，还是为了取信于投资人，创业者都要要求投资人签署保密协议。只是，要掌握好时间点。</p><p>那么，投资人看重的是什么？<br>第一，商业案思路清晰，市场回报设计方案路径清楚，言之成理，<br>第二，最最重要的：执行团队。换句话说，绝大多数投资人看重的，不是案子，而是能把案子做成买卖的创业团队！所以，千万别想着拿几张天马行空的A4纸去打动别人把几千万给你，他们看都不会看，即便里面写了九阴真经。但如果这纸上的方案，你已经建立起了自己稳定的核心团队，而且靠这个团队已经在小规模范围内取得了一定的商业成功，现在是需要资金扩大规模，那么，加上你的好点子，投资人对你是有兴趣的。</p><p>是否需要签订保密协议,主要还是要具体评估下题主展示或向对方提供的内容是什么。<br>如果是机变的数据资料或者一些数据模型等,付出大量的人力、物力的智力成果,可以达到商业秘密了<br>众所知悉、能芾来经济利益,具有实用性并采取保密措施的技术信息和经营信息)<br>还是非常有必要签署保密协议的。虽然有人说保密协议是防君子不防小人,但有保密协议在,毕竟会对一部分投资人产生威慑,而且后续如果有纠纷,诉诸司法,保密协议毕竟要求对方承担的一个法律文件和基础<br>如果只是一些创意或电子,毕竟法律不保护创意,签与不签,并无实质性区别。</p><h1 id="家装风投"><a href="#家装风投" class="headerlink" title="家装风投"></a>家装风投</h1><p>经纬中国，合力投资，红杉资本，IDG资本，沸点资本，创湃资本，稳国基金，创吧投资，58集团，梧桐树资本，红星美凯龙，北辰星，<br>天使湾，印尼力保集团，华耀资本，氪空间，中骏基金等等</p><p>基本涵盖种子轮，天使轮，Pre-A轮，A轮，B轮，C轮，C+轮以后，。。。，F轮，上市前。</p><p>天使投资人需要做进一步的网络爬虫</p><p>不局限于拿国内资本投资，可考虑境外投资或者联合投资形式</p><p>A+轮后可考虑资本市场，多家融资</p><p> VC风险投资(venture capital)</p><h1 id="轮次融资"><a href="#轮次融资" class="headerlink" title="轮次融资"></a>轮次融资</h1><p>同时也是解读资本与企业发展之间关系的学问。</p><h1 id="种子轮"><a href="#种子轮" class="headerlink" title="种子轮"></a>种子轮</h1><p>种子投资极具风险，大多数种子投资者明白70%的初创企业投资最终都会失败。但是，他们也明白，只需一个成功的初创企业，便可带来大量的财富。因此，种子投资者明白，在寻找成功企业的过程中，他们需要与企业“风险共担”，更重要的是，要避免“FOMO”的陷阱，即“错过”下一个取得巨大成功的初创企业[2]  。<br>由于更多的种子投资者承担更多的风险，因此早期的种子融资变得更加普遍、丰富，也更容易获得。尤其在许多初创企业明白快速进入市场的重要性之后，种子融资的易得性和不断增长的资金池对初创企业来说无疑是好消息。具有讽刺意味的是，这种发展也给初创企业带来了严重的问题。<br>种子融资后，会对初创企业创始人进行早期的估值、收入和客户标准检查，并规定达成业绩的严格时限。如果初创企业过早进入种子融资，在接下来的轮次融资阶段，如A轮融资时，则会遇到严重的挑战。轮次融资通常更加重要和复杂，因此如不能满足标准，会给接下来的投资人带来强烈的负面信息。</p><p>在融资中，这一般被称之为“种子轮”投资，它是指公司发展的一个阶段。在这个阶段，公司只有创意却没有具体的产品或服务，创业者只拥有一项技术上的新发明、新设想以及对未来企业的一个蓝图，缺乏初始资金投入。创业者在这一阶段寻找投资的时候，最需要的讲清楚的是“我要做什么”，重要的是要给投资人画好你想象中的“大饼”。<br>一般来讲，因为前期资金需求相对较小，也或许是创业者大都抱有“先做出一点成绩或者先做出个样子”的想法，种子期的所需要的资金都是创业者自筹或者通过亲朋好友来筹集。当然，也有种子期投资人和投资机构。<br>注意，种子期的投资资金一般在10万-100万RMB左右。当然，也有破例。比如，最近VR比较火，森声科技在3月就宣布获得了数百万元的天使投资。森声科技想做的是，基于双耳录音(Binaural recording)技术，为广大 VR 影视团队提供一套简便的全景声录制和播放解决方案。</p><p>种子期的项目，往往只有一个idea和初始团队（有些只有一两个创始人），idea能不能转换为一个make sense的business，具有高度的不确定性，需要通过一段时间的尝试，对idea背后的各种假设进行验证，从而探索到真正可行的方向。在此过程中项目的方向和内容随时有可能面临调整，而且项目一没有历史，二缺乏连续性，唯一稳定的、可供投资者参考的因素就是团队（而且主要是创始人），因此种子期的投资主要看人。人是极其复杂的，要想对一个人作出判断就必须深入了解他、和他打交道。由于这个过程依赖大量的经验和直觉，很难进行理性的分析，因此履行这个任务、做这个决策的，一般都是个人投资者。这也是“天使”这个称号的来历。此外，由于尝试和探索所需的资金量一般不是太多，个人投资者出得起，且项目越早期风险越大，所以天使投资的金额一般也较小，一般都在500万（人民币）以下。</p><p>—————————–<strong>破土期</strong>———————————————————</p><h1 id="天使轮"><a href="#天使轮" class="headerlink" title="天使轮"></a>天使轮</h1><p>天使轮是指公司有了产品初步的模样，商业模式也已初步形成，同时积累了一部分的核心用户。投资来源一般是天使投资人、天使投资机构。相比之后的融资，这个时期想要拿到融资还是相对容易的，投资人主要看的是创业团队和创业方向。<br>对于成熟理性的天使投资机构来说，种子期和天使期项目在阶段上的差别不大，区别最大的就是在融资金额上。因此，也有人会把这种初创公司的融资阶段称为“种子天使”。</p><p>天使轮，即天使投资（Angel Investment），是指个人出资协助具有专门技术或独特概念而缺少自有资金的创业家进行创业，并承担创业中的高风险和享受创业成功后的高收益，或者说是自由投资者或非正式风险投资机构对原创项目构思或小型初创企业进行的一次性的前期投资。天使投资是风险投资的一种特殊形式。</p><p>天使轮的投资资金额度一般在100万RMB到1000万RMB左右。上限为2000万左右。<br>2015年12月，刚刚成立半年多的美国P2P保险公司Lemonade获得红杉资本1300万美元的种子轮投资。Quartz称，这是红杉历史上最大的种子轮投资之一。</p><p>种子、天使轮，顾名思义就是很早期的公司，可能只是一个idea、没有实际的走出去，这个时候VC机构，一般会看创业者的背景、愿景，但最重要的还是个人背景，如果你是一个已经很牛的人，那你的天使轮估值肯定会很高，比如瓜子二手车天使轮就能拿到6000万美元的融资，就是因为杨浩涌以前有过成功创业的经验，即使他做出渣来也会有人投资的。</p><p>天使投资也属于风险投资的范围，只是更为早期，风险更大，同时回报也可能更高。天使投资的来源更广泛，早年最常见的三类天使投资人，3F，family，friend，fool。</p><p>随着越来越多的互联网公司上市，大量掌握大笔资金，熟悉上市流程，和投资机构关系密切，了解行业动向，具有大量人脉的前互联网公司高管们开始成为专业的天使投资人，他们是最合适的天使投资人选，也会有相当多的好项目被他们挖掘获得成长。</p><p>同时，天使机构化的趋势也开始明显，一些新的天使投资开始就以正规军的方式作战，一些以往A轮起投的风险投资机构也开始向天使扩展，所以天使投资和风险投资的界限也开始模糊，天使和VC主要用在界定投资金额的多少，比如通常天使是100-200万人民币，A轮是100-200万美金，B轮是500-1000万美金，等等，但是也并不确定，有人天使就上千万美金了。</p><p>除了资金多少的区别，我通常会按照项目的状态来界定项目的阶段以及投资款的用途。天使阶段，商业模式还没有建立，钱是不够烧的，天使投资的钱更主要用来搭建团队，大量试错，为A轮较大资金进入，具有可复制的商业模式的基础做准备，要能证明后续资金可以高效的使用才值得引进新的投资，也才容易拿到后续的风险投资。（当然，这个市场上充满了反例和个案）</p><p>成长期则似乎没有公认的定义，我个人的理解是当一个项目经历过种子期的摸索，探索到一条有较大可行性的道路时，便进入到成长期。可以说种子期是纸上谈兵，成长期则经过了实践，从市场的反应中看到了希望。企业进入成长期以后，战略基本成型，准备着手投入资源（其中资金是关键资源）去实现这个战略。这个时候投进去的，就可以算作是VC了。所以VC是企业战略初步成型以后用以支撑企业去实施战略的投资。此时企业刚刚在市场上取得一些成绩，或者看到了一些成功的苗头，但企业自身的资源不足以支撑它，需要引进外部的资源。对投资者而言，企业战略所隐含的关键性的假设通过市场已经有所验证，此时可以对项目进行理性的分析，并能够对面临的风险进行相对准确的评估。这就有了机构化投资的基础，也即实际的出资人可以委托专业的投资人士进行操作并对投资人士实施监督，从而在投资领域产生了委托－代理关系；另一方面，这个阶段企业需要的资金量相对比较大，如果由个人投资者投资将很难分散风险，因此投资的机构化也成为必然。因此，VC一般都是以基金的方式实行机构化运作的，投资额一般在千万量级。</p><p>天使的话，我喜欢你，看得起你， 相信你，就可以了。看中的可能只是被投资人的某个闪光点而已。</p><p>天使投资无疑是“单个项目的回报”最高的。早期项目估值低，一旦项目成为了独角兽，百倍千倍的回报完全可以实现。一版情况下项目如果没有5倍、10倍的回报，都不好意思拿出来和同行说。但是对应风险也是非常高的。比如，天使投资人一年投10个项目，其中有9个血本无归，只靠成功的那个项目赚了百倍收益来弥补9个的亏损，这种情况也是时有发生。VC和PE投资随着公司估值不断上升，单个项目的回报倍数越低，相对投资成功的概率会比天使投资高不少。</p><p>所以天使轮也被称为独角兽投资。</p><h1 id="Pre-A轮"><a href="#Pre-A轮" class="headerlink" title="Pre-A轮"></a>Pre-A轮</h1><p>按照正常的融资进程，下一轮的融资应该是是A轮融资。但是，有的公司会增加一轮融资：Pre-A轮。</p><p>Pre的意思是前期，Pre-A就是A轮之前的融资。增加这轮融资的原因是多方面的，创业公司在估值不理想;资金困难，但又没有达到A轮阶段的规模，以上这些情况都有可能。Pre-A可以看作一个缓冲阶段，可以让创业者资金压力缓解，也可以让新的投资人进来。</p><p>———————————<strong>天堑期</strong>—————————————————————–</p><h1 id="A轮"><a href="#A轮" class="headerlink" title="A轮"></a>A轮</h1><p>A轮，其实A轮也是初创公司，很多有资历、有人脉的，通过自己或创始团队搞定了天使轮，真正向VC拿钱的时候是A轮，A轮公司特征是已经有了产品原型，可以拿到市场上面对用户了，但基本还没有收入或者收入很小，类似的公司有小米、平安好医生等，都是有产品了拿到了A轮，但公司还是不盈利；这个时候投资人还是更看重创业者资历背景，但这时候也会看些市场前景，以及公司的愿景了。</p><p>在A轮融资阶段，创业公司的产品已经基本成熟，产品上线或者服务已经正常运作一段时间，并有完整详细的商业及盈利模式。另外，创业公司在行业内拥有一定地位和口碑，但是还处于亏损的状态，有诱人的前景。A轮的投资资金额度一般在1000万RMB到1亿RMB左右。</p><p>2015年12月，58到家宣布与阿里巴巴，平安，KKR完成了A轮融资协议的签署，58到家将以超过10亿美金的估值融资3亿美金。据说，这是互联网史上最巨额的A轮融资。<br>当然，从天使到A轮是很多创业公司很难踏出的一步。在这个时期，是考验创业公司的产品、商业模式、盈利模式和创业团队等各个方面的阶段。如果一个环节出现问题就可能导致一个项目的失败或者说创业失败。</p><h1 id="B轮"><a href="#B轮" class="headerlink" title="B轮"></a>B轮</h1><p>创业公司经过一轮烧钱后，获得了较大发展。甚至一些公司开始盈利，盈利模式趋于完善，可能需要推出新业务、拓展新领域。资金来源一般是大多是上一轮的风险投资机构跟投、新的风投机构加入、私募股权投资机构加入。投资资金额度一般在2亿RMB以上。</p><p>———————————<strong>换血期</strong>————————————————————————</p><h1 id="C轮"><a href="#C轮" class="headerlink" title="C轮"></a>C轮</h1><p>到达C轮融资的时候，创业公司又会遇到一个瓶颈。<br>这时公司已经非常成熟了，离上市不远了。这轮除了拓展新业务，讲讲“生态”，就要开始准备上市了。资金来源主要是私募股权投资，有些之前的VC也会选择跟投，投资资金一般在10亿RMB左右。<br>大部分公司一般C轮后就会上市，但也有公司选择融D轮，甚至更多轮的融资。<br>这些需要更多轮融资的公司大部分是其本身的业务所决定的，有的项目需要大量的烧钱，过早上市就不符合这类公司的发展战略，最为形象的例子就是滴滴了，滴滴由于烧钱补贴，现在已经G轮了，还在融资。</p><h1 id="C-轮–至死亡轮"><a href="#C-轮–至死亡轮" class="headerlink" title="C+轮–至死亡轮"></a>C+轮–至死亡轮</h1><p>简单来说就是无数的资本融入。</p><h1 id="IPO期"><a href="#IPO期" class="headerlink" title="IPO期"></a>IPO期</h1><p>完成以上这些融资阶段后，公司就可以上市了。<br>上市之前第一件事就是IPO。<br>IPO(Initial Public Offerings)即为首次公开募股，是指一家企业或公司 (股份有限公司)第一次将它的股份向公众出售(首次公开发行，指股份公司首次向社会公众公开招股的发行方式)。只有首次公开上市完成后，公司才可以申请到证券交易所或报价系统挂牌交易。IPO需要经过多个环节的严格审核。<br>以上，就是一家公司从创立初到上市的全过程。</p><h1 id="天使投资、VC-以及-PE-的区别是什么？"><a href="#天使投资、VC-以及-PE-的区别是什么？" class="headerlink" title="天使投资、VC 以及 PE 的区别是什么？"></a>天使投资、VC 以及 PE 的区别是什么？</h1><p>VC即风险投资，PE即私募股权</p><p>回答这个问题,需要看一下私募股权基金的发展历史,以及在PE这个大概念里产生的V和 Angel</p><p>私募股权基金,是伴随着上世纪七八十年代的并购潮起来的概念,可以看做一个替代资本市场,为<br>需要资本或者想岀手资产的企业提供类似股票市场和银行信贷功能的一种金融产品</p><p>私募股权基金,最早从事的就是兼并收购,随看市场的变化,老牌的PE基金,比如黑石,KKR<br>在随时调整并改变其投资策略,但是,这些老的PE基金在折腾纳贝斯克,折腾UCAR,折腾轮轴制<br>造公司的时候,他们亻脑子里想的是现金流状况,是持续盈利能力和稳定的偿债能力</p><p>于是,这些老PE和他们所实际控制的传统企业的光芒,被来自硅谷的人和他们背后的资本力量所遮<br>挡了,而VC和天使们的故事,要从1995年4月 Netscape的IPO开始谈起。</p><p>对于黑石和KKR来说,像网景这样 Pre ipo收入只有1600万美元,净亏损430万美元的公司能上市<br>简直就是荒唐的事情,但来自硅谷的另类PE——VC们告诉黑石,新世纪,投资者会对那些用新技<br>术实现高成长的公司充满信心。于是,传统金融领域闻所未闻的IPO大批出现,包括:雅虎<br>Amazon甚至包括 Google。</p><p>买股票,不用看盈利水平,不用看财务报表,来自西海岸的投资者们一次又一次抽打华尔街那些穿<br>看笔挺西装的人们的脸。一个又一个天价的IPO,让华尔街的PE们开始反思传统并购和私募股权融<br>资创造的资本价值是否还有没有意义。</p><p>时,美国的PE团伙集中在曼哈顿,而∨C和天使们则聚集在苹果的老家帕拉奥图。PE们每天打看<br>爱马仕领带,而VC们则穿看和乔布斯一样的衣服到处瞎比溜达,找他们心中无需看财务报表,只看<br>技术和团队的下一个网景或者亚马逊。</p><p>如果说PE们考的是财务模型和数学分析,那V们靠的就是对技术领先性和市场占有率的赌局。事实<br>证明,西海岸的∨C们比曼哈顿的那帮老头更讨人喜欢。黑石,KKR们动辄几百亿的并购,也敌不过<br>西海岸一个又一个高科技上市公司的造富神话。</p><p>那么,说完了历史问题,针对题主的可题,讲点更直接的东西</p><p>1.PE更关注的是财务数据,现金流状况,以及各种极限环境下的损失测算,因此PE失败的概率较<br>小,但暴富的概率也不大<br>2.VC需要关注的则是产品本身,市场潜力和社会价值,要准确的洞察历史的演进和应用的趋势,并<br>成为下一个风囗里的猪<br>3.天使更需要准确的洞察趋势,以及赌对一个产品或团队<br>上世纪末,因为互联网和高科技行业的譟动,伴随看大批高科技企业的IPO,一大批VC和天使基<br>金就此崛起。</p><p>但,VC和天使们所面对的行业趋势不可预知性和极大地投资风险,是他们相对PE最大的区别所在<br>要了解vc和天使的区别,就必须要了解他们的起源和PE的发展历史,以及几个重要的历史变革<br>vc和天使的投资理念,孬资风格都是从我讲的这些历史里演化而来的。</p><p>VC和PE的发展时间较长，资金来源比较丰富，高净值个人、专业风险基金、杠杆并购基金、战略投资者、养老基金、保险公司。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于风投泄密及其保密协议&quot;&gt;&lt;a href=&quot;#关于风投泄密及其保密协议&quot; class=&quot;headerlink&quot; title=&quot;关于风投泄密及其保密协议&quot;&gt;&lt;/a&gt;关于风投泄密及其保密协议&lt;/h1&gt;&lt;p&gt;保密协议就属于防君子不防小人,特别是在商业模式、概念以及技术在早期还很不具象的时候(这恰恰都是初创公司所面临的情况),保密协议起到的作用就更小,因为连保护的标的都不清楚,总不能说保护一个头脑中的idea吧?即使起到作用,通过法律手段花上无数的时间和精力去索赔并成功,损失的时间和精力放在自己的梦想和创业上,是不是会更加划算?天使投资人最大的价值就是,给钱不捣乱,同时需要的时候提供不太计较的支持.&lt;/p&gt;
    
    </summary>
    
      <category term="创业之路" scheme="http://yoursite.com/categories/%E5%88%9B%E4%B8%9A%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="风险投资" scheme="http://yoursite.com/tags/%E9%A3%8E%E9%99%A9%E6%8A%95%E8%B5%84/"/>
    
      <category term="VC" scheme="http://yoursite.com/tags/VC/"/>
    
      <category term="融资" scheme="http://yoursite.com/tags/%E8%9E%8D%E8%B5%84/"/>
    
  </entry>
  
  <entry>
    <title>google-Google Protocol Buffer</title>
    <link href="http://yoursite.com/2018/03/15/google-tech00/"/>
    <id>http://yoursite.com/2018/03/15/google-tech00/</id>
    <published>2018-03-15T12:46:01.000Z</published>
    <updated>2018-03-16T13:56:51.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Google-Protocol-Buffer"><a href="#Google-Protocol-Buffer" class="headerlink" title="Google Protocol Buffer"></a>Google Protocol Buffer</h1><p>什么是 Google Protocol Buffer？ 假如您在网上搜索，应该会得到类似这样的文字介绍：<br>Google Protocol Buffer( 简称 Protobuf) 是 Google 公司内部的混合语言数据标准，目前已经正在使用的有超过 48,162 种报文格式定义和超过 12,183 个 .proto 文件。他们用于 RPC 系统和持续数据存储系统。<br>Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API。<br>或许您和我一样，在第一次看完这些介绍后还是不明白 Protobuf 究竟是什么，那么我想一个简单的例子应该比较有助于理解它。</p><p><img src="/2018/03/15/google-tech00/p1.png" alt="logo"></p><a id="more"></a><p>移动应用客户端与服务器之间的通信协议,目前比较主流的有Facebook的Thrift,腾讯的JCE,以及Google的ProtocolBuffer(以下简称protobuf),本文主要介绍protobuf基本概念,协议解析,以及在Android中的应用实践。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>一种 结构化数据 的数据存储格式（类似于 <code>XML、Json</code> ）,用于网络世界的数据交换</p><p>Google 出品 （开源）<br>Protocol Buffer 目前有两个版本：proto2 和 proto3<br>因为proto3 还是beta 版，所以本次讲解是 proto2</p><p>Protobuf是一种灵活高效的,用于序列化结构化数据的机制,类似于XML,但比XML更小,更快,更简单。Protobuf序列化为二进制数据,不依赖于平台和语言,同时具备很好的兼容性。</p><p>通过将 结构化的数据 进行 串行化（序列化），从而实现 数据存储 / RPC(Remote Procedure Call Protocol远程过程调用协议) 数据交换的功能：</p><p>序列化： 将 数据结构或对象 转换成 二进制串 的过程<br>反序列化：将在序列化过程中所生成的二进制串 转换成 数据结构或者对象 的过程</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>传输数据量大 &amp; 网络环境不稳定 的数据存储、RPC 数据交换 的需求场景</p><p>如 即时IM （QQ、微信）的需求场景</p><p>在 传输数据量较大的需求场景下，Protocol Buffer比XML、Json 更小、更快、使用 &amp; 维护更简单！</p><h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><h3 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h3><h3 id="OSI-RM协议模型"><a href="#OSI-RM协议模型" class="headerlink" title="OSI/RM协议模型"></a>OSI/RM协议模型</h3><p>说到GPB（Google protocol Buffer）通过序列化与反序列化来进行数据传输，那么我们来聊聊序列化的问题。</p><p>序列化 &amp; 反序列化 属于通讯协议的一部分<br>通讯协议采用分层模型：TCP/IP模型（四层） &amp; OSI 模型 （七层）</p><p>ISO/OSI的参考模型共有7层，由低层至高层分别为：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><p>各层功能分别为：</p><p>（1）物理层</p><p>提供建立、维护和拆除物理链路所需的机械、电气、功能和规程的特性；提供有关在传输介质上传输非结构的位流</p><p>及物理链路故障检测指示。在这一层，数据还没有被组织，仅作为原始的位流或电气电压处理，单位是比特。</p><p>（2）数据链路层</p><p>负责在两个相邻结点间的线路上，无差错地传送以帧为单位的数据，并进行流量控制。每一帧包括一定数量的数据</p><p>和一些必要的控制信息。与物理层相似，数据链路层要负责建立、维持和释放数据链路的连接。在传送数据时，如</p><p>果接收点检测到所传数据中有差错，就要通知发方重发这一帧。</p><p>（3）网络层</p><p>为传输层实体提供端到端的交换网络数据传送功能，使得传输层摆脱路由选择、交换方式、拥挤控制等网络传输</p><p>细节；可以为传输层实体建立、维持和拆除一条或多条通信路径；对网络传输中发生的不可恢复的差错予以报告。</p><p>网络层将数据链路层提供的帧组成数据包，包中封装有网络层包头，其中含有逻辑地址信息——源站点和目的站点</p><p>地址的网络地址。</p><p>（4）传输层</p><p>为会话层实体提供透明、可靠的数据传输服务，保证端到端的数据完整性；选择网络层的最适宜的服务；提供建</p><p>立、维护和拆除传输连接功能。传输层根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间提</p><p>供建立、维护和取消传输连接的功能，并以可靠和经济的方式传输数据。在这一层，信息的传送单位是报文。</p><p>（5）会话层</p><p>为彼此合作的表示层实体提供建立、维护和结束会话连接的功能；完成通信进程的逻辑名字与物理名字间的对应；</p><p>提供会话管理服务。</p><p>（6）表示层</p><p>为应用层进程提供能解释所交换信息含义的一组服务，即将欲交换的数据从适合于某一用户的抽象语法，转换为</p><p>适合于OSI系统内部使用的传送语法，提供格式化的表示和转换数据服务。数据的压缩，解压缩，加密和解密等</p><p>工作都由表示层负责。</p><p>（7）应用层</p><p>提供OSI用户服务，即确定进程之间通信的性质，以满足用户需要以及提供网络与用户应用软件之间的接口服务。</p><p>简言之，各层的作用：</p><p>物理层：在物理媒体上传输原始的数据比特流。</p><p>数据链路层：将数据分成一个个数据帧，以数据帧为单位传输。有应有答，遇错重发。</p><p>网络层：将数据分成一定长度的分组，将分组穿过通信子网，从信源选择路径后传到信宿。</p><p>传输层：提供不具体网络的高效、经济、透明的端到端数据传输服务。</p><p>会话层：进程间的对话也称为会话，会话层管理不同主机上各进程间的对话。</p><p>表示层： 为应用层进程提供格式化的表示和转换数据服务。</p><p>应用层：提供应用程序访问OSI环境的手段。</p><p>OSI网络体系结构各层协议：</p><p>（1）应用层：TELNET、FTP、TFTP、SMTP、SNMP、HTTP、BOOTP、DHCP、DNS<br>（2）表示层：<br> 　　文本：ASCII，EBCDIC<br> 　　图形：TIFF，JPEG，GIF，PICT<br> 　　声音：MIDI，MPEG，QUICKTIME<br>（3）会话层：NFS、SQL、RPC 、X-WINDOWS、ASP（APPTALK会话协议）、SCP<br>（4）传输层：TCP、UDP、SPX<br>（5）网络层：IP、IPX、ICMP、RIP、OSPF(Open Shortest Path First开放式最短路径优先)<br>（6）数据链路层：SDLC、HDLC、PPP、STP（Spanning Tree Protocol）、帧中继<br>（7）物理层：EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45</p><p>常用端口（每个协议都有一个缺省端口）</p><p><img src="/2018/03/15/google-tech00/p5.png" alt="logo"></p><h3 id="TCP-IP协议模型"><a href="#TCP-IP协议模型" class="headerlink" title="TCP/IP协议模型"></a>TCP/IP协议模型</h3><p>TCP/IP概念层次中与OSI模型相互对应</p><p><img src="/2018/03/15/google-tech00/p2.png" alt="logo"></p><p><img src="/2018/03/15/google-tech00/p4.jpg" alt="logo"></p><h3 id="两者关系"><a href="#两者关系" class="headerlink" title="两者关系"></a>两者关系</h3><p>OSI引入了服务、接口、协议、分层的概念，TCP/IP借鉴了OSI的这些概念建立TCP/IP模型。</p><p>OSI先有模型，后有协议，先有标准，后进行实践；而TCP/IP则相反，先有协议和应用再提出了模型，且是参照的OSI模型。</p><p>OSI是一种理论下的模型，而TCP/IP已被广泛使用，成为网络互联事实上的标准。</p><ul><li>TCP：transmission control protocol 传输控制协议</li><li>UDP：user data protocol 用户数据报协议</li></ul><p><img src="/2018/03/15/google-tech00/p3.png" alt="logo"></p><p>OSI七层协议模型算是一个理想的规范模型而不应用在实践中，而TCP/IP模型则是现在国际所通用的网络传输协议模型</p><p>序列化 / 反序列化 属于 TCP/IP模型 应用层 和 OSI`模型 展示层的主要功能：</p><ul><li>（序列化）把 应用层的对象 转换成 二进制串</li><li>（反序列化）把 二进制串 转换成 应用层的对象<br>所以， Protocol Buffer属于 TCP/IP模型的应用层 &amp; OSI模型的展示层</li></ul><h2 id="对于数据结构和对象"><a href="#对于数据结构和对象" class="headerlink" title="对于数据结构和对象"></a>对于数据结构和对象</h2><h3 id="数据结构、对象与二进制串"><a href="#数据结构、对象与二进制串" class="headerlink" title="数据结构、对象与二进制串"></a>数据结构、对象与二进制串</h3><p>不同的计算机语言中，数据结构，对象以及二进制串的表示方式并不相同。</p><p>对于面向对象的语言（如Java）：对象 = Object = 类的实例化；在Java中最接近数据结构 即 POJO（Plain Old Java Object），或Javabean（只有 setter/getter 方法的类）</p><p>对于半面向对象的语言（如C++），对象 = class，数据结构 = struct</p><p>对于C++，因为具有内存操作符，所以 二进制串 容易理解：C++的字符串可以直接被传输层使用，因为其本质上就是以 ‘\0’ 结尾的存储在内存中的二进制串</p><p>对于 Java，二进制串 = 字节数组 =byte[]<br>byte 属于 Java 的八种基本数据类型<br>二进制串 容易和 String混淆：String 一种特殊对象（Object）。对于跨语言间的通讯，序列化后的数据当然不能是某种语言的特殊数据类型。</p><h3 id="T-L-V-的数据存储方式"><a href="#T-L-V-的数据存储方式" class="headerlink" title="T - L - V 的数据存储方式"></a>T - L - V 的数据存储方式</h3><ul><li>定义 </li></ul><p>即 Tag - Length - Value，标识 - 长度 - 字段值 存储方式</p><p>作用<br>以 标识 - 长度 - 字段值 表示单个数据，最终将所有数据拼接成一个 字节流，从而 实现 数据存储 的功能</p><p>其中 Length可选存储，如 储存Varint编码数据就不需要存储Length</p><ul><li>示意图</li></ul><p><img src="/2018/03/15/google-tech00/p6.png" alt="logo"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Google-Protocol-Buffer&quot;&gt;&lt;a href=&quot;#Google-Protocol-Buffer&quot; class=&quot;headerlink&quot; title=&quot;Google Protocol Buffer&quot;&gt;&lt;/a&gt;Google Protocol Buffer&lt;/h1&gt;&lt;p&gt;什么是 Google Protocol Buffer？ 假如您在网上搜索，应该会得到类似这样的文字介绍：&lt;br&gt;Google Protocol Buffer( 简称 Protobuf) 是 Google 公司内部的混合语言数据标准，目前已经正在使用的有超过 48,162 种报文格式定义和超过 12,183 个 .proto 文件。他们用于 RPC 系统和持续数据存储系统。&lt;br&gt;Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API。&lt;br&gt;或许您和我一样，在第一次看完这些介绍后还是不明白 Protobuf 究竟是什么，那么我想一个简单的例子应该比较有助于理解它。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/03/15/google-tech00/p1.png&quot; alt=&quot;logo&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Google" scheme="http://yoursite.com/categories/Google/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="java类库" scheme="http://yoursite.com/tags/java%E7%B1%BB%E5%BA%93/"/>
    
      <category term="google" scheme="http://yoursite.com/tags/google/"/>
    
      <category term="protocol Buffer" scheme="http://yoursite.com/tags/protocol-Buffer/"/>
    
      <category term="数据交换" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>JAVA开发常用类库--JDBC故障诊断</title>
    <link href="http://yoursite.com/2018/03/15/java-api13/"/>
    <id>http://yoursite.com/2018/03/15/java-api13/</id>
    <published>2018-03-15T09:32:29.000Z</published>
    <updated>2018-03-15T11:18:57.060Z</updated>
    
    <content type="html"><![CDATA[<p>有不错的JDBC扩展库的存在使得调试变得很容易，例如P6spy，这是一个针对数据库访问操作的动态监测框架，它使得数据库数据可无缝截取和操纵，而不必对现有应用程序的代码作任何修改。P6Spy 分发包包括P6Log，它是一个可记录任何 Java 应用程序的所有JDBC事务的应用程序。其配置完成使用时，可以进行数据访问性能的监测。</p><p>在我们 Java 开发应用程序的过程中，难免会碰到系统的性能问题，特别在企业应用的开发过程中，都会与数据库进行打交道。当我们碰到数据库性能时，最有效的就是直接跟踪每一个 SQL 语句的执行情况，SQL 语句的优化、索引的优化往往也是最容易取得最直接的效果的。</p><p>在应用程序开发过程中，为了方便调试，通常都需要知道在DAO层程序执行的SQL是什么，而P6spy这个组件正是提供了该功能。</p><p>已在Github上开源：<a href="https://github.com/p6spy/p6spy" target="_blank" rel="noopener">https://github.com/p6spy/p6spy</a></p><a id="more"></a><p>依赖添加</p><pre><code>&lt;dependency&gt;  &lt;groupId&gt;p6spy&lt;/groupId&gt;  &lt;artifactId&gt;p6spy&lt;/artifactId&gt;  &lt;version&gt;3.6.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>然后将p6spy的配置文件spy.properties放置项目的src/main/resources目录下,该文件只需要修改logfile，logMessageFormat，dateformat属性即可，如下图所示:</p><pre><code>logfile=mybatis-practices-core.log   //具体文件位置logMessageFormat= net.ittimeline.mybatis.practices.core.p6spy.CustomizeLineFormat   //具体文件信息格式dateformat=yyyy-MM-dd HH:mm:ss   //数据格式databaseDialectDateFormat=yyyy-MM-dd HH:mm:ss   //数据库方言数据格式</code></pre><p>配置参数文档说明在 <a href="https://github.com/p6spy/p6spy/blob/master/docs/configandusage.md" target="_blank" rel="noopener">https://github.com/p6spy/p6spy/blob/master/docs/configandusage.md</a> 中写的很清楚</p><p>然后实现自定义的SQL输出格式</p><p>为了输出的内容足够的简洁，这里只保留了当前时间，执行SQL的耗时以及执行的SQL语句,具体实现如下所示<br>这里用了alibaba.druid的数据库连接池技术，具体大同小异。</p><pre><code>package net.ittimeline.mybatis.practices.core.p6spy;import com.alibaba.druid.sql.SQLUtils;import com.p6spy.engine.spy.appender.MessageFormattingStrategy;/** * @author tony ittimeline@163.com * @date 2018-01-30-下午10:45 * @website wwww.ittimeline.net * @see * @since JDK8u162 */public class CustomizeLineFormat implements MessageFormattingStrategy {    public String buildMessage(String now, long elapsed, String sql) {        StringBuffer content = new StringBuffer();        if (org.apache.commons.lang3.StringUtils.isNotEmpty(now) &amp;&amp; org.apache.commons.lang3.StringUtils.isNotEmpty(Long.valueOf(elapsed).toString())                &amp;&amp; org.apache.commons.lang3.StringUtils.isNotEmpty(sql)) {            content.append(&quot;当前时间:&quot; + now);            content.append(&quot; SQL执行耗时(毫秒)为&quot; + elapsed);            content.append(&quot; SQL执行的语句是\n&quot; + SQLUtils.formatMySql(sql)+&quot;\n\n&quot;);        }        return content.toString();    }    @Override    public String formatMessage(int connectionId, String now, long elapsed, String category, String prepared, String sql) {        return buildMessage(now, elapsed, sql);    }}</code></pre><p>然后增加一个database.properties文件，配置内容如下</p><p>和传统的jdbc配置相比，不同之处在于驱动类和连接地址的配置。</p><pre><code>jdbc.driver=com.p6spy.engine.spy.P6SpyDriverjdbc.url=jdbc:p6spy:mysql://127.0.0.1:3306/mybatis?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=falsejdbc.username=korontojdbc.password=xxxxxxxx</code></pre><p>而mybatis-config.xml文件中只需要增加一行配置<properties resource="database.properties">，然后就可以采用${属性名}的方式获取数据库配置了，配置如下所示</properties></p><pre><code>&lt;properties resource=&quot;database.properties&quot;/&gt;</code></pre> <!--配置数据库连接信息 --><pre><code>&lt;environments default=&quot;development&quot;&gt;    &lt;environment id=&quot;development&quot;&gt;        &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;        &lt;dataSource type=&quot;POOLED&quot;&gt;            &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;            &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;            &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;            &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;        &lt;/dataSource&gt;    &lt;/environment&gt;&lt;/environments&gt;</code></pre><p>然后运行CountryMapperTest.selectAll()方法，会发现在mybatis-practices-core模块的根路径下存在一个mybatis-practices-core.log的文件，内容如下</p><pre><code>当前时间:2018-01-30 23:03:07 SQL执行耗时(毫秒)为0 SQL执行的语句是SELECT country_id AS countryId, country_name AS countryName, country_code AS countryCodeFROM t_country</code></pre><p>把具体的SQL语句信息给打印出来了。</p><p>在 P6Spy 发布包中，它包含 P6Log 和 P6Outage 两个模块：</p><ul><li><p>P6Log<br>P6Log 是用来拦截和记录任务应用程序的 JDBC 语句的。这个功能对于开发者监控 EJB 服务器上的 SQL 语句执行情况尤其有用，可以让开发者完成尽可能高效的代码。同时 P6Spy 的部署是极其简单的，而且根本不需要更改任何一行代码，即对现有的应用是无侵入性的。</p></li><li><p>P6Outage<br>P6Outage 专门用来检测和记录执行时间比较长的 SQL 语句，P6Outage 只记录超过配置条件里时间的那些信息，并对可能影响到数据库的运行效率减小到最低。</p></li></ul><h1 id="架构原理"><a href="#架构原理" class="headerlink" title="架构原理"></a>架构原理</h1><p>简单地讲，我们可以认为 P6Spy 就是一个代理（Proxy），它只做了一层对 JDBC 驱动的拦截，然后转发出去，这样的设计与实际的应用程序没有任何的耦合性，除了在配置中将驱动程序改成 P6Spy 的拦截驱动外，程序其他地方并不需要做任何的改变。这层拦截器除了可能会给系统带来略微的性能下降外，对程序其他方面没有任何的影响。而相对于这一点点的性能下降，在开发环境中对于开发人员来说是无法感觉到，相比它所带来的好处，完全可以忽略不计。</p><p>P6Spy 对数据库进行拦截监控的处理过程如下：</p><p><img src="/2018/03/15/java-api13/p1.png" alt="logo"></p><h1 id="问题与解决"><a href="#问题与解决" class="headerlink" title="问题与解决"></a>问题与解决</h1><p>如果在你的应用程序启动后，却在 spy.log 文件中发现了如下的提示信息，那就是驱动程序加载先后的问题了。</p><pre><code>&lt;你的程序的数据库驱动名称&gt; is a real driver in spy.properties, but it has been loaded before p6spy.  p6spy will not wrap these connections.  Either prevent the driver from loading, or try setting&apos;deregisterdrivers&apos; to true in spy.properties</code></pre><p>解决办法：</p><p>请把 spy.properties 配置文件里的 deregisterdrivers=false 改为 deregisterdrivers=true，重新运行即可。<br>这是因为有些应用系统中会先于 P6Spy 加载了真正的数据库的驱动程序，导致 P6Spy 无法监控到，设置 deregisterdrivers 为 true，是显式地把真正的数据库的驱动程序进行反注册掉，而采用 P6Spy 的驱动程序。</p><h1 id="配置参数及相关意义"><a href="#配置参数及相关意义" class="headerlink" title="配置参数及相关意义"></a>配置参数及相关意义</h1><p>下表列出了 spy.properties 配置文件中的各配置项的名称、默认值及其意义和相关注意事项：</p><pre><code>配置项名称                                                 默认值module.log                                                 com.p6spy.engine.logging. P6LogFactorymodule.outage                                             com.p6spy.engine.outage. P6OutageFactoryrealdriver     realdriver2     realdriver3     deregisterdrivers                                         falseexecutionthreshold     outagedetection    falseoutagedetectioninterval     filter                                                     falseinclude     exclude     sqlexpression     autoflush                                                 truedateformat     includecategories     excludecategories     stringmatcher     stacktrace                                                 falsestacktraceclass     reloadproperties                                         falsereloadpropertiesinterval                                 60useprefix                                                 falseappender                                                 com.p6spy.engine.logging. appender.FileLoggerlogfile                                                     spy.logappend    truelog4j.appender.STDOUT                                     org.apache.log4j.ConsoleAppenderlog4j.appender.STDOUT.layout                            org.apache.log4j.PatternLayoutlog4j.appender.STDOUT. layout.ConversionPattern            p6spy - %m%nlog4j.logger.p6spy                                        INFO,STDOUTrealdatasource     realdatasourceclass     realdatasourceproperties     jndicontextfactory     jndicontextproviderurl     jndicontextcustom</code></pre><h1 id="SQL-Profiler"><a href="#SQL-Profiler" class="headerlink" title="SQL Profiler"></a>SQL Profiler</h1><p>SQL Profiler 是一个由 Jahia.org 提供的基于 P6Spy 引擎的快速剖析工具，用来统计 SQL 查询语句以便了解哪里是性能瓶颈，在哪里创建索引或者采取相应的办法才能提高效率，并且能根据 SQL 查询语句的情况帮你生成合适的索引脚本。</p><p>这个小工具可以实时地显示数据库查询的情况，通过集成的 SQL 解析器，在访问大多数表与列上面建立统计分析，并生成索引脚本。当然，其它的信息也会进行收集和显示，比如：单个数据库请求的时间、一类请求的时间以及所有请求的时间。因此，可以有效地通过视图的排序来检测数据的性能问题所在。这个工具对于大量的需要进行分析的请求是非常有用的，而不是人工一个个地去做分析。当你需要知道比如对相同的表和列进行访问但是采用不同的查询值时，这种分组的查询可以用建立在 ANTLR 上的 SQL 解析器进行分析。</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><p>首先，你的应用系统同样也应当是基于数据库的，然后你需要去获取 SQL Profiler 相关的文件（在 参考资源 中可以找到下载链接，您可以直接下载软件包）。下面介绍 SQL Profiler 的安装与使用的详细操作过程：<br>下载 SQL Profiler 的文件包进行安装；<br>把 p6spy.jar 及 sqlprofiler.jar 放到 CLASSPATH 中，如果是 Web 应用程序则放在 YourWebApp/WEB-INF/lib/ 目录下；<br>把 spy.properties 放到 CLASSPATH 目录下，如果是 Web 应用程序就放在 YourWebApp/WEB-INF/classess/ 目录下，注意不是 lib/ 目录；<br>修改你应用系统中的数据库驱动名称为 P6Spy 的驱动程序名称 com.p6spy.engine.spy.P6SpyDriver 其它的全部使用默认值，暂时不用修改；<br>打开 spy.properties 文件，把 realdriver 的值改为你的程序的数据库驱动名称；<br>注意要先运行 java -jar sqlprofiler.jar 来启动 SQL Profiler，并成功看到启动界面；<br>然后再启动你的应用程序或服务器，并开始进行正常的系统请求处理操作；<br>这样就可以在 SQL Profiler 图形化的界面上看到结果并进行分析了。</p><p>参考资料：<a href="http://blog.csdn.net/heyeqingquan/article/details/71743814" target="_blank" rel="noopener">http://blog.csdn.net/heyeqingquan/article/details/71743814</a></p><h2 id="分析结果"><a href="#分析结果" class="headerlink" title="分析结果"></a>分析结果</h2><p>经过一段时间的系统运行后，点击 Pause 按钮停止拦截，可以得到分析结果如下图：</p><p>SQL Profiler 的分析结果 Profiler 视图</p><p><img src="/2018/03/15/java-api13/p2.png" alt="logo"></p><p>接着，可以切换到 Loggers 视图，这是 Lgger 视图的信息：</p><p>SQL Profiler 的分析结果 Logger 视图</p><p><img src="/2018/03/15/java-api13/p3.png" alt="logo"></p><p>当然，也可以切换到 Analysis 视图，这是 Analysis 视图的分析结果信息：</p><p>SQL Profiler 的分析结果 Analysis 视图</p><p><img src="/2018/03/15/java-api13/p4.png" alt="logo"></p><p>在经过分析后，我们可以直接通过 SQLProfiler 提交的保存按钮，直接导出应当进行数据库优化的建议的索引脚本，通过查看索引脚本，我们可以看到创建索引的详细 SQL 脚本，这样，我们就可以非常方便地进行数据库调优了。</p><h2 id="问题与解决-1"><a href="#问题与解决-1" class="headerlink" title="问题与解决"></a>问题与解决</h2><p>最后一个需要注意的问题就是需要先启动 SQLProfiler，然后再启动应用程序或者 Tomcat 等应用服务器。这是因为 SQLProfiler 默认使用的是 Log4j 的 SocketAppender，所以要先启动。否则，会因你的应用程序或应用服务器中的 Web 应用之类的因连接不到 Socket 的服务器（SQLProfiler 相当于 Socket 的服务器）而发生错误，可以通过 SQL Profiler 控制界面最下面的连接状态就可以知道是否有程序连接上来。</p><p><img src="/2018/03/15/java-api13/p5.png" alt="logo"></p><h1 id="IronTrack-SQL"><a href="#IronTrack-SQL" class="headerlink" title="IronTrack SQL"></a>IronTrack SQL</h1><p>IronEye，一个专注于 JDBC 性能的监控和测试的开源项目，它包含有三个工具：IronEye SQL，IronEye Cache，IronTrack SQL。其中，IronEye SQL 用于监测 Java 应用和数据库服务器之间查询开销的时间，诊断在性能方面是否存在着相关问题，让开发人员在测试之前就能发现问题。IronEye 于 2003 年 10 月 1 日开始基于 Apache Software License 发布。<br>IronEye SQL 这个轻量级的 Java 工具提供所有流动在数据库与应用程序之间的 SQL 统计信息并用多张图表展现，可以快速优化程序的性能。<br>IronGrid 相对于 Continuous Integration 提出了 Continuous Performance 的概念，即在项目开发过程中随时关注性能问题，而不是传统的出了问题再解决的方案。<br>IronGrid 在应用程序对数据库的操作上的 Continuous Performance 是通过 IronTrack SQL 进行体现的。IronTrack SQL 能通过对 JDBC 的包装来拦截应用程序对数据库的请求，完成性能监控。IronTrack SQL 的好处在于不需要修改任何代码或者在数据库端安装任何程序，只需要在测试时把依赖的 JDBC 替换就可以了。</p><h2 id="使用步骤-1"><a href="#使用步骤-1" class="headerlink" title="使用步骤"></a>使用步骤</h2><p>首先，你的应用系统同样也应当是基于数据库的，然后你需要去获取 IronTrack SQL 相关的文件（在 参考资源 中可以找到下载链接，您可以直接下载软件包）。下面介绍 IronTrack SQL 的安装与使用的详细操作过程：<br>下载 IronTrack SQL 的文件包进行安装；<br>把 irontracksql.jar, p6spy.jar 和 log4j-1.2.8.jar 放到 CLASSPATH 中，如果是 Web 应用程序则放在 YourWebApp/WEB-INF/lib/ 目录下；<br>把 spy.properties 放到 CLASSPATH 目录下，如果是 Web 应用程序就放在 YourWebApp/WEB-INF/classess/ 目录下，注意不是 lib/ 目录；<br>修改你程序的数据库驱动名称为 P6Spy 的驱动程序名称 com.p6spy.engine.spy.P6SpyDriver 其它的都不用更改；<br>打开配置文件 spy.properties 文件，找到 realdriver，把它的值改为你的应用系统的真正的数据库驱动名称；<br>设置监听端口号 monitorport=2000；<br>先运行 java -jar irontracksql.jar 来启动 IronTrack SQL；<br>再启动你的应用程序或服务器；<br>可以在 IronTrack SQL 图形化的界面上看到结果并进行分析了。</p><p>连接设置<br>点击“Config”按钮就可以设置主机名、端口与刷新的时间（毫秒为单位）。根据你的服务器与端口的不同而进行相应地改变，下面以本地和 2000 端口，刷新时间为 500 毫秒为示例。设置完成后，确定，点击“Connect”就可以连接应用系统并进行监测与分析了，当要停止分析时，只要点击“Disconnect”按扭即可立刻停止分析了。<br>在分析的过程中，我们可以根据需要点击“Purge”按钮，它可以清除目前所监测到的内容，然后重新进行记录监测信息，很方便地进行重新开始。</p><p>IronTrack SQL 连接示例</p><p><img src="/2018/03/15/java-api13/p6.png" alt="logo"></p><h2 id="分析结果-1"><a href="#分析结果-1" class="headerlink" title="分析结果"></a>分析结果</h2><p>经过一段时间的系统运行后，我们可以直接得到分析的结果与相应的图形分析示例。相关的信息显示如下：</p><p>IronTrack SQL 分析结果</p><p><img src="/2018/03/15/java-api13/p7.png" alt="logo"></p><p>Count 列显示 SQL 语句的调用次数；<br>Avg Time 列显示 SQL 语句的执行平均时间；<br>Max Time 列显示 SQL 语句花费的最高时间；<br>SQL 列显示真正执行的 SQL 语句内容。<br>同时也可以通过设置过滤条件来显示指定条件的结果，比如：只关注平均调用次数大于 100 次 的结果。点击“Filtering”左边的小三角图标，可以显示如下的过滤条件设置栏目：</p><p>IronTrack SQL 设置相关的过滤条件</p><p><img src="/2018/03/15/java-api13/p8.png" alt="logo"></p><p>设置完成后，点击“Apply Filter”按钮即可以获取所需要的相关结果了。这样可以更加方便地集中精力进行所需要的内容分析，可以更加方便快速地定位到问题的所在之处，然后进行解决。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过使用 P6Spy、SQL Profiler、IronTrack SQL 工具，我们可以无侵入已有的应用系统而有效地进行数据库操作的监控与剖析，为发现系统的性能瓶颈，寻找系统的性能调优提供了相当便利的方法。</p><p>p6spy专区：<a href="http://www.p6spy.com/" target="_blank" rel="noopener">http://www.p6spy.com/</a><br>sqlprofiler专区：<a href="https://sourceforge.net/projects/sqlprofiler/" target="_blank" rel="noopener">https://sourceforge.net/projects/sqlprofiler/</a><br><a href="https://www.ibm.com/developerworks/cn/java/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有不错的JDBC扩展库的存在使得调试变得很容易，例如P6spy，这是一个针对数据库访问操作的动态监测框架，它使得数据库数据可无缝截取和操纵，而不必对现有应用程序的代码作任何修改。P6Spy 分发包包括P6Log，它是一个可记录任何 Java 应用程序的所有JDBC事务的应用程序。其配置完成使用时，可以进行数据访问性能的监测。&lt;/p&gt;
&lt;p&gt;在我们 Java 开发应用程序的过程中，难免会碰到系统的性能问题，特别在企业应用的开发过程中，都会与数据库进行打交道。当我们碰到数据库性能时，最有效的就是直接跟踪每一个 SQL 语句的执行情况，SQL 语句的优化、索引的优化往往也是最容易取得最直接的效果的。&lt;/p&gt;
&lt;p&gt;在应用程序开发过程中，为了方便调试，通常都需要知道在DAO层程序执行的SQL是什么，而P6spy这个组件正是提供了该功能。&lt;/p&gt;
&lt;p&gt;已在Github上开源：&lt;a href=&quot;https://github.com/p6spy/p6spy&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/p6spy/p6spy&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="java类库" scheme="http://yoursite.com/tags/java%E7%B1%BB%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JAVA开发常用类库--嵌入式SQL</title>
    <link href="http://yoursite.com/2018/03/15/java-api12/"/>
    <id>http://yoursite.com/2018/03/15/java-api12/</id>
    <published>2018-03-15T09:23:52.000Z</published>
    <updated>2018-03-15T12:22:40.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="嵌入式SQL"><a href="#嵌入式SQL" class="headerlink" title="嵌入式SQL"></a>嵌入式SQL</h1><p>嵌入式SQL(英文 Embedded SQL)是一种将SQL语句直接写入C语言，COBOL，FORTRAN, Ada等编程语言的源代码中的方法。<br>借此方法，可使得应用程序拥有了访问数据以及处理数据的能力。在这一方法中，将SQL文嵌入的目标源码的语言称为宿主语言。</p><p>在SQL标准的SQL86(1986年发布)中定义了对于COBOL, FORTRAN（福传语言，即数学公式语言）, PI/L等语言的嵌入式SQL的规范。在SQL89(1989年发布)规范中，定义了对于C语言的嵌入式SQL的规范。一些大型的数据库厂商发布的数据库产品中，都提供了对于嵌入式SQL的支持。比如Oracle, DB2等。</p><a id="more"></a><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>提供对于嵌入式SQL的支持，需要数据库厂商除了提供DBMS之外，还必须提供一些工具。为了实现对于嵌入式SQL的支持，技术上必须解决以下4个问题:</p><p>1.宿主语言的编译器不可能识别和接受SQL文，需要解决如何将SQL的宿主语言源代码编译成可执行码;<br>2.宿主语言的应用程序如何与DBMS之间传递数据和消息;<br>3.如何把对数据的查询结果逐次赋值给宿主语言程序中的变量以供其处理;<br>4.数据库的数据类型与宿主语言的数据类型有时不完全对应或等价，如何解决必要的数据类型转换问题。</p><p>嵌入式SQL源码的处理流程 为了解决上述这些问题，数据库厂商需要提供一个嵌入式SQL的预编译器，把包含有嵌入式SQL文的宿主语言源码转换成纯宿主语言的代码。这样一来，源码即可使用宿主语言对应的编译器进行编译。通常情况下，经过嵌入式SQL的预编译之后，原有的嵌入式SQL会被转换成一系列函数调用。因此，数据库厂商还需要提供一系列函数库，以确保链接器能够把代码中的函数调用与对应的实现链接起来。</p><h2 id="扩展语法"><a href="#扩展语法" class="headerlink" title="扩展语法"></a>扩展语法</h2><p>嵌入式SQL中除了可以执行标准SQL文之外，为了对应嵌入的需要，还增加了一些额外的语法成分。主要包含以下内容：</p><ul><li>宿主变量使用声明的语法</li><li>数据库访问的语法</li><li>事务控制的语法</li><li>游标操作的语法</li></ul><h2 id="嵌入形式"><a href="#嵌入形式" class="headerlink" title="嵌入形式"></a>嵌入形式</h2><p>对宿主型数据库语言SQL，DBMS可以采用两种方法处理，一种是预编译，另一种是修改和扩充主语言使之能处理SQL语句。目前采用较多的是预编译的方法。即有DBMS的预处理程序对源程序进行扫描，识别出SQL语句，把它们转换成主语言调用语句，以使主语言编译程序能识别它，最后由主语言的编译程序将整个源程序编译成目标码。<br>在嵌入式SQL中，为了能够区分SQL语句与主语言语句，所以SQL语句都必须加前缀EXEC SQL。SQL语句的结束标准则随主语言的不同而不同。<br>例如：在PL/1和C中以分号（;）结束：<br>EXEC SQL<sql 语句="">;<br>在COBOL中以END-EXEC结束：<br>EXEC SQL&lt;SQL语句&gt; END-EXEC<br>例如一条交互形式的SQL语句：<br>DROP TABLE Student;<br>嵌入到C程序中应写作：EXEC SQL DROP TABLE Student;</sql></p><p>可参考文章</p><p><a href="http://blog.csdn.net/shaoshuo/article/details/2463632" target="_blank" rel="noopener">http://blog.csdn.net/shaoshuo/article/details/2463632</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;嵌入式SQL&quot;&gt;&lt;a href=&quot;#嵌入式SQL&quot; class=&quot;headerlink&quot; title=&quot;嵌入式SQL&quot;&gt;&lt;/a&gt;嵌入式SQL&lt;/h1&gt;&lt;p&gt;嵌入式SQL(英文 Embedded SQL)是一种将SQL语句直接写入C语言，COBOL，FORTRAN, Ada等编程语言的源代码中的方法。&lt;br&gt;借此方法，可使得应用程序拥有了访问数据以及处理数据的能力。在这一方法中，将SQL文嵌入的目标源码的语言称为宿主语言。&lt;/p&gt;
&lt;p&gt;在SQL标准的SQL86(1986年发布)中定义了对于COBOL, FORTRAN（福传语言，即数学公式语言）, PI/L等语言的嵌入式SQL的规范。在SQL89(1989年发布)规范中，定义了对于C语言的嵌入式SQL的规范。一些大型的数据库厂商发布的数据库产品中，都提供了对于嵌入式SQL的支持。比如Oracle, DB2等。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="java类库" scheme="http://yoursite.com/tags/java%E7%B1%BB%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JAVA开发常用类库--HTML解析库</title>
    <link href="http://yoursite.com/2018/03/15/java-api11/"/>
    <id>http://yoursite.com/2018/03/15/java-api11/</id>
    <published>2018-03-15T05:13:05.000Z</published>
    <updated>2018-03-15T09:22:44.155Z</updated>
    
    <content type="html"><![CDATA[<p>dom解析是常用dom4j。android中我们常用的是sax、pull。因为它们更省内存。而html解析,则也有很多框架</p><p>java的HTML解析通常用在利用java做网页的垂直爬虫</p><p>HTML是WEB的核心，互联网中你看到的所有页面都是HTML，不管它们是由JavaScript，JSP，PHP,ASP或者是别的什么WEB技术动态生成的。你的浏览器会去解析HTML并替你去渲染它们。不过如果你需要自己在Java程序中解析HTML文档并查找某些元素，标签，属性或者检查某个特定的元素是否存在的话，那又该如何呢？如果你已经使用Java编程多年了，我相信你肯定试过去解析XML，也使用过类似DOM或者SAX这样的解析器，不过很有可能你从未进行过任何的HTML解析的工作。更讽刺的是，在Java应用中，很少会有需要你去解析HTML文档的时候，这里并不包括Servlet或者其它的Java WEB技术。更糟糕的是，JDK核心里也没有包括HTTP或者HTML的库，至少我并不知道有这个。这就是为什么一碰上解析HTML文件时，许多Java程序员就得先Google一下 ，看看如何在Java中取出一个HTML的标签。当我有这个需要的时候，我相信肯定会有一些开源库能实现这个，不过我没有想到竟然有JSoup这么酷的并且功能齐全的库。它不仅能支持读取并解析HTML文档，而且还能让你从HTML文件抽取出任何的元素，以及它们的属性，它们的CSS属性，你还能进它们进行修改。有了JSoup你简直可以对HTML文档做任何事情。我们将会看到如何在Java中从google主页或者任何URL中下载并解析HTML文件的示例。</p><a id="more"></a><p>一般来说，一个爬虫包括几个部分：</p><ul><li>页面下载</li></ul><p>页面下载是一个爬虫的基础。下载页面之后才能进行其他后续操作。</p><ul><li>链接提取</li></ul><p>一般爬虫都会有一些初始的种子URL，但是这些URL对于爬虫是远远不够的。爬虫在爬页面的时候，需要不断发现新的链接。</p><ul><li>URL管理</li></ul><p>最基础的URL管理，就是对已经爬过的URL和没有爬的URL做区分，防止重复爬取。</p><ul><li>内容分析和持久化</li></ul><p>一般来说，我们最终需要的都不是原始的HTML页面。我们需要对爬到的页面进行分析，转化成结构化的数据，并存储下来。</p><p><strong>不同的爬虫，对这几部分的要求是不一样的。</strong></p><p>HTML分析是一个比较复杂的工作，Java世界主要有几款比较方便的分析工具：</p><ul><li>Jsoup</li></ul><p>Jsoup是一个集强大和便利于一体的HTML解析工具。它方便的地方是，可以用于支持用jquery中css selector的方式选取元素，这对于熟悉js的开发者来说基本没有学习成本。</p><p>Jsoup是一个开源的Java库，它可以用于处理实际应用中的HTML。它提供了非常便利的API来进行数据的提取及修改，充分利用了DOM，CSS以及jquery风格方法的长处。Jsoup实现了WAHTWG HTML5的规范，它从HTML解析出来的DOM和Chrome以及Firefox这样的现代浏览器解析出来的完全一致。下面是Jsoup库的一些有用的特性：</p><p>1.Jsoup可以从URL，文件，或者字符串中获取并解析HTML。<br>2.Jsoup可以查找并提取数据，可以使用DOM遍历或者CSS选择器。<br>3.你可以使用Jsoup来修改HTML元素，属性以及文本。<br>4.Jsoup通过一个安全的白名单确保了用户提交的内容是干净的，以防止XSS攻击。<br>5.Jsoup还能输出整洁的HTML。</p><p>在Java中使用Jsoup进行HTML解析</p><p>在这篇Java HTML解析的教程中，我们会看到在Java中使用Jsoup解析及遍历HTML的三个不同的示例。第一个例子中，我们会解析一个HTML字符串，它的内容就是Java中的字符串字面量组成的标签。第二个例子中，我们会从WEB中下载HTML文档，而第三个例子中，我们会加载一个HTML示例文件login.html来进行解析。这个文件是一个HTML文档的示例，它包含title标签,body里面有一个div标签，里面包含一个表单。它拥有input标签来用于获取用户名及密码，同时还有提交及重置的按钮用来进行下一步操作。它是一个正确有效的HTML，也就是说，所有的标签和属性都是正确地闭合的。下面是我们这个HTML的示例文件：</p><p>复制代码代码如下:</p><pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;   &lt;html&gt;   &lt;head&gt;   &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=ISO-8859-1&quot;&gt;   &lt;title&gt;Login Page&lt;/title&gt;   &lt;/head&gt;   &lt;body&gt;   &lt;div id=&quot;login&quot; class=&quot;simple&quot; &gt;   &lt;form action=&quot;login.do&quot;&gt;   Username : &lt;input id=&quot;username&quot; type=&quot;text&quot; /&gt;&lt;br&gt;   Password : &lt;input id=&quot;password&quot; type=&quot;password&quot; /&gt;&lt;br&gt;   &lt;input id=&quot;submit&quot; type=&quot;submit&quot; /&gt;   &lt;input id=&quot;reset&quot; type=&quot;reset&quot; /&gt;   &lt;/form&gt;   &lt;/div&gt;   &lt;/body&gt;   &lt;/html&gt;  </code></pre><p>使用Jsoup来解析HTML非常简单，你只需调用它的静态方法Jsoup.parse()并传入你的HTML字符串给它就可以了。Jsoup提供了多个重载的parse()方法，它可以从字符串，文件，URI，URL，甚至InputStream中读取HTML文件。如果不是UTF-8编码的话，你还可以指定字符编码，这样可以正确地读取HTML文件。下面是Jsoup库中HTML解析方法的一个完整的列表。parse(String html)方法将输入的HTML解析成一个新的Document。在Jsoup里，Document继承了Element，而它又继承自Node。同样的TextNode也继承自Node。只要你传入的是一个不为null的字符串，你就肯定能获取到一个成功的有意义的解析，得到一个包含head和body元素的Document。一旦你拿到这个Document，你就可以调用Document以及它的父类Element和Node上面的适当的方法来获取到你想要的数据了。</p><p>解析HTML文档的Java程序</p><p>下面是一个解析HTML字符串，网络上下载的HTML文件，以及本地文件系统中的HTML文件的完整的Java程序。你可以使用Eclipse IDE或者别的IDE甚至命令来运行这个程序。在Eclipse里面则很简单，拷贝这份代码，新建一个Java工程，在src包上右键并粘贴进去就可以了。Eclipse会去创建正确的包及同名的Java源文件的，因此工作量最小。如果你已经有一个Java示例工程了，那么仅需一步就可以了。下面的这个Java程序展示了解析及遍历HTML文件的三个不同例子。第一个例子中，我们直接解析了一个内容为HTML的字符串，第二个例子中我们解析了一个从URL中下载的HTML文件，第三个中我们从本地文件系统中加载了一个HTML文档并进行解析。第一和第三个例子中都用到了parse方法来获取一个Document对象，你可以查询它来提取出任何的标签值或者属性值。第二个例子中，我们用到了Jsoup.connect方法，它会去创建URL的连接，下载HTML并进行解析。这个方法也会返回Document，它可以用于后续的查询及获取标签或者属性的值。</p><p>复制代码代码如下:</p><pre><code>import java.io.IOException;  import org.jsoup.Jsoup;  import org.jsoup.nodes.Document;  import org.jsoup.nodes.Element;  /**  [*] Java Program to parse/read HTML documents from File using Jsoup library.  [*] Jsoup is an open source library which allows Java developer to parse HTML  [*] files and extract elements, manipulate data, change style using DOM, CSS and  [*] JQuery like method.  [*]  [*] @author Javin Paul  [*]/  public class HTMLParser{      public static void main(String args[]) {          // Parse HTML String using JSoup library          String HTMLSTring = &quot;&lt;!DOCTYPE html&gt;&quot;                  + &quot;&lt;html&gt;&quot;                  + &quot;&lt;head&gt;&quot;                  + &quot;&lt;title&gt;JSoup Example&lt;/title&gt;&quot;                  + &quot;&lt;/head&gt;&quot;                  + &quot;&lt;body&gt;&quot;                  + &quot;|[b]HelloWorld[/b]&quot;                  + &quot;&quot;                  + &quot;&lt;/body&gt;&quot;                  + &quot;&lt;/html&gt;&quot;;          Document html = Jsoup.parse(HTMLSTring);          String title = html.title();          String h1 = html.body().getElementsByTag(&quot;h1&quot;).text();          System.out.println(&quot;Input HTML String to JSoup :&quot; + HTMLSTring);          System.out.println(&quot;After parsing, Title : &quot; + title);          System.out.println(&quot;Afte parsing, Heading : &quot; + h1);          // JSoup Example 2 - Reading HTML page from URL          Document doc;          try {              doc = Jsoup.connect(&quot;http://google.com/&quot;).get();              title = doc.title();          } catch (IOException e) {              e.printStackTrace();          }          System.out.println(&quot;Jsoup Can read HTML page from URL, title : &quot; + title);          // JSoup Example 3 - Parsing an HTML file in Java          //Document htmlFile = Jsoup.parse(&quot;login.html&quot;, &quot;ISO-8859-1&quot;); // wrong          Document htmlFile = null;          try {              htmlFile = Jsoup.parse(new File(&quot;login.html&quot;), &quot;ISO-8859-1&quot;);          } catch (IOException e) {              // TODO Auto-generated catch block              e.printStackTrace();          } // right          title = htmlFile.title();          Element div = htmlFile.getElementById(&quot;login&quot;);          String cssClass = div.className(); // getting class form HTML element          System.out.println(&quot;Jsoup can also parse HTML file directly&quot;);          System.out.println(&quot;title : &quot; + title);          System.out.println(&quot;class of div tag : &quot; + cssClass);      }  }  </code></pre><p>输出：</p><p>复制代码代码如下:</p><pre><code>Input HTML String to JSoup :&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;JSoup Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;h1&gt;HelloWorld&lt;/h1&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;  After parsing, Title : JSoup Example  Afte parsing, Heading : HelloWorld  Jsoup Can read HTML page from URL, title : Google  Jsoup can also parse HTML file directly title : Login Page  class of div tag : simple  </code></pre><p>Jsoup的好处就是它的健壮性很强。Jsoup HTML解析器会对你提供的HTML进行尽量干净的解析，而不去考虑这个HTML是否是格式良好的。它可以处理如下这些错误：未闭合的标签（比如，Java </p><p>Scala to </p><p>JavaScala)，隐式标签（比如，一个裸的|Java is Great被封装到了|里面），它总能创建出一个文档结构（包含head及body的HTML，并且head里只会包含正确的元素）。这就是在Java中如何进行HTML的解析。Jsoup是一个优秀的健壮的开源库，它使得读取HTML文档，body片段，HTML字符串，以及直接从WEB中解析HTML内容都变得相当简单。在这篇文章中，我们学习了如何在Java中获取一个特定的HTML标签，正如第一个例子中我们将title及H1标签的值提取成了文本，而第三个例子中我们学习到了如何通过提取CSS属性来从HTML标签中获取属性值。除了强大的jQuery风格的html.body().getElementsByTag(“h1”).text()方法，你还可以提取任意的HTML标签，它还提供了像Document.title()和Element.className()这样便捷的方法，你可以快速获取到标题及CSS类。希望JSoup能让你玩得愉快，很快我们将会看到关于这个API的更多的一些例子。</p><p>Jsoup的设计初衷是用于处理现实生活中出现的各种不同的HTML，包括正确有效的HTML以及不完整的无效的标签集合。Jsoup的一个核心竞争力就是它的健壮性。</p><p>转载自 <a href="http://www.jb51.net/article/55620.html" target="_blank" rel="noopener">http://www.jb51.net/article/55620.html</a></p><p>在线文档:<a href="http://www.osctools.net/apidocs/apidoc?api=jsoup-1.6.3;http://jsoup.org/" target="_blank" rel="noopener">http://www.osctools.net/apidocs/apidoc?api=jsoup-1.6.3;http://jsoup.org/</a> </p><pre><code>&lt;!-- lang: java --&gt;String content = &quot;blabla&quot;;Document doc = JSoup.parse(content);Elements links = doc.select(&quot;a[href]&quot;);</code></pre><p>Jsoup还支持白名单过滤机制，对于网站防止XSS攻击也是很好的。</p><ul><li>HtmlParser</li></ul><p>HtmlParser的功能比较完备，也挺灵活，但谈不上方便。这个项目很久没有维护了，最新版本是2.1。HtmlParser的核心元素是Node，对应一个HTML标签，支持getChildren()等树状遍历方式。HtmlParser另外一个核心元素是NodeFilter，通过实现NodeFilter接口，可以对页面元素进行筛选。</p><p>htmlparser是一个纯的java写的html解析的库,它不依赖于其它的java库文件,主要用于改造或提取html。它能超高速解析html,而且不会出错。现在htmlparser最新版本为2.0。 据说htmlparser就是目前最好的html解析和分析的工具。 无论你是想抓取网页数据还是改造html的内容,用了htmlparser绝对会忍不住称赞。</p><p>在线文档:<a href="http://www.osctools.net/apidocs/apidoc?api=HTMLParser[/url];http://htmlparser.sourceforge.net/project-info.html" target="_blank" rel="noopener">http://www.osctools.net/apidocs/apidoc?api=HTMLParser[/url];http://htmlparser.sourceforge.net/project-info.html</a> </p><p>示例代码:<br>    Parser parser = new Parser (“<a href="http://www.dangdang.com&quot;)" target="_blank" rel="noopener">http://www.dangdang.com&quot;)</a>;<br>    NodeList list = parser.parse (null);<br>    Node node = list.elementAt (0);<br>    NodeList sublist = node.getChildren ();<br>    System.out.println (sublist.size ());</p><ul><li>Apache tika</li></ul><p>tika是专为抽取而生的工具，还支持PDF、Zip甚至是Java Class。使用tika分析HTML，需要自己定义一个抽取内容的Handler并继承org.xml.sax.helpers.DefaultHandler，解析方式就是xml标准的方式。crawler4j中就使用了tika作为解析工具。SAX这种流式的解析方式对于分析大文件很有用，我个人倒是认为对于解析html意义不是很大。</p><pre><code>InputStream inputStream = null;HtmlParser htmlParser = new HtmlParser();htmlParser.parse(new ByteArrayInputStream(page.getContentData()), contentHandler, metadata, new ParseContext()); </code></pre><ul><li>HtmlCleaner与XPath</li></ul><p>HtmlCleaner最大的优点是：支持XPath的方式选取元素。XPath是一门在XML中查找信息的语言，也可以用于抽取HTML元素。XPath与CSS Selector大部分功能都是重合的，但是CSS Selector专门针对HTML，写法更简洁，而XPath则是通用的标准，可以精确到属性值。XPath有一定的学习成本，但是对经常需要编写爬虫的人来说，这点投入绝对是值得的。</p><p>学习XPath可以参考w3school的XPath 教程。<br><a href="http://www.w3school.com.cn/xpath/" target="_blank" rel="noopener">http://www.w3school.com.cn/xpath/</a><br>下面是使用HtmlCleaner和xpath进行抽取的一段代码：</p><pre><code>&lt;!-- lang: java --&gt;HtmlCleaner htmlCleaner = new HtmlCleaner();TagNode tagNode = htmlCleaner.clean(text);Object[] objects = tagNode.evaluateXPath(&quot;xpathStr&quot;);</code></pre><ul><li>几个工具的对比</li></ul><p>在这里评价这些工具的主要标准是“方便”。就拿抽取页面所有链接这一基本任务来说，几种代码分别如下：</p><ul><li><p>XPath:</p><pre><code>&lt;!-- lang: java --&gt;tagNode.evaluateXPath(&quot;//a/@href&quot;)</code></pre></li><li><p>CSS Selector:</p><pre><code>&lt;!-- lang: java --&gt;//使用类似js的实现$(&quot;a[href]&quot;).attr(&quot;href&quot;)</code></pre></li><li><p>HtmlParser：</p><pre><code>&lt;!-- lang: java --&gt;Parser p = new Parser(value);NodeFilter aFilter = new TagNameFilter(&quot;a&quot;);NodeList nodes = p.extractAllNodesThatMatch(aFilter);for (int i = 0; i &lt; nodes.size(); i++) {    Node eachNode = nodes.elementAt(i);    if (eachNode instanceof LinkTag) {        LinkTag linkTag = (LinkTag) eachNode;        System.out.println(linkTag.extractLink());    }}</code></pre></li></ul><p>XPath是最简单的，可以精确选取到href属性值；而CSS Selector则次之，可以选取到HTML标签，属性值需要调用函数去获取；而HtmlParser和SAX则需要手动写程序去处理标签了，比较麻烦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;dom解析是常用dom4j。android中我们常用的是sax、pull。因为它们更省内存。而html解析,则也有很多框架&lt;/p&gt;
&lt;p&gt;java的HTML解析通常用在利用java做网页的垂直爬虫&lt;/p&gt;
&lt;p&gt;HTML是WEB的核心，互联网中你看到的所有页面都是HTML，不管它们是由JavaScript，JSP，PHP,ASP或者是别的什么WEB技术动态生成的。你的浏览器会去解析HTML并替你去渲染它们。不过如果你需要自己在Java程序中解析HTML文档并查找某些元素，标签，属性或者检查某个特定的元素是否存在的话，那又该如何呢？如果你已经使用Java编程多年了，我相信你肯定试过去解析XML，也使用过类似DOM或者SAX这样的解析器，不过很有可能你从未进行过任何的HTML解析的工作。更讽刺的是，在Java应用中，很少会有需要你去解析HTML文档的时候，这里并不包括Servlet或者其它的Java WEB技术。更糟糕的是，JDK核心里也没有包括HTTP或者HTML的库，至少我并不知道有这个。这就是为什么一碰上解析HTML文件时，许多Java程序员就得先Google一下 ，看看如何在Java中取出一个HTML的标签。当我有这个需要的时候，我相信肯定会有一些开源库能实现这个，不过我没有想到竟然有JSoup这么酷的并且功能齐全的库。它不仅能支持读取并解析HTML文档，而且还能让你从HTML文件抽取出任何的元素，以及它们的属性，它们的CSS属性，你还能进它们进行修改。有了JSoup你简直可以对HTML文档做任何事情。我们将会看到如何在Java中从google主页或者任何URL中下载并解析HTML文件的示例。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="java类库" scheme="http://yoursite.com/tags/java%E7%B1%BB%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JAVA开发常用类库--邮件</title>
    <link href="http://yoursite.com/2018/03/15/java-api10/"/>
    <id>http://yoursite.com/2018/03/15/java-api10/</id>
    <published>2018-03-15T05:03:15.000Z</published>
    <updated>2018-03-15T05:10:23.032Z</updated>
    
    <content type="html"><![CDATA[<p>所想要看的java邮件相关知识在这里都有，因为作者的权限问题，不好转载。</p><p><a href="http://blog.csdn.net/acmman/article/category/6843840" target="_blank" rel="noopener">http://blog.csdn.net/acmman/article/category/6843840</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;所想要看的java邮件相关知识在这里都有，因为作者的权限问题，不好转载。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/acmman/article/category/6843840&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="java类库" scheme="http://yoursite.com/tags/java%E7%B1%BB%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JAVA开发常用类库--HTTP库</title>
    <link href="http://yoursite.com/2018/03/15/java-api09/"/>
    <id>http://yoursite.com/2018/03/15/java-api09/</id>
    <published>2018-03-15T04:19:21.000Z</published>
    <updated>2018-03-15T04:59:52.073Z</updated>
    
    <content type="html"><![CDATA[<p>我不是很喜欢JDK的一个重要原因就包括他们缺乏对HTTP的支持。虽然可以使用java.net包类，但是这和直接使用像 Apache HttpClient 和 HttpCore 等开源类库比起来麻烦太多了。</p><p>尽管JDK 9将开始HTTP 2.0，也对HTTP的支持做了优化，但是我还是强烈建议所有的Java开发人员熟悉流行的HTTP处理类库，例如HttpClient和HttpCore HTTP等库。</p><a id="more"></a><h1 id="传统的java-net包类"><a href="#传统的java-net包类" class="headerlink" title="传统的java.net包类"></a>传统的java.net包类</h1><p>InetAddress类:表示互联网协议 (IP) 地址</p><p>URL类:代表一个统一资源定位符，它是指向互联网“资源”的指针。</p><p>   资源可以是简单的文件或目录，也可以是对更为复杂的对象的引用，例如对数据库或搜索引擎的查询。</p><p>URLConnection类:用于读取和写入此 URL 引用的资源。</p><p>使用步骤:<br>通过在 URL 上调用 openConnection 方法创建连接对象。<br>处理设置参数和一般请求属性。<br>使用 connect 方法建立到远程对象的实际连接。<br>远程对象变为可用。远程对象的头字段和内容变为可访问。</p><p>DatagramPacket类:此类表示数据报包。</p><p>  数据报包用来实现无连接包投递服务。每条报文仅根据该包中包含的信息从一台机器路由到另一台机器。</p><p>DatagramSocket类:此类表示用来发送和接收数据报包的套接字。</p><p>数据报套接字是包投递服务的发送或接收点。每个在数据报套接字上发送或接收的包都是单独编址和路由的。从一台机<br>器发送到另一台机器的多个包可能选择不同的路由，也可能按不同的顺序到达。</p><ul><li>ServerSocket类:此类实现服务器套接字。</li></ul><p>ServerSocket类主要用在服务器端程序的开发上，用于接收客户端的连接请求</p><p><img src="/2018/03/15/java-api09/p1.png" alt="logo"></p><p>服务器套接字等待请求通过网络传入。它基于该请求执行某些操作，然后可能向请求者返回结果。</p><ul><li>Socket类:此类实现客户端套接字（也可以就叫“套接字”）。</li></ul><p>则是在客户端上运行的，在服务器每次运行时都要使用accept()方法来获取客户端连接，此方法执行之后服务器端将进入阻塞状态，<br>直到客户端连接之后才可以继续向下执行，此方法的返回值类型是Socket，每一个Socket都表示一个客户端对象</p><p>本包中的主线应该是Socket和ServalSocket两个类。将围绕socket和serverSocket的通信而展开。</p><p>首先，如何建立一个客户端和服务器端的通信？</p><p>一、客户端</p><p>1.首先new一个socket（有连接的socket和未连接的socket两种：指定服务器端的ip地址（或主机名）与port号的为连接的，没指定或使用socket（Proxy proxy）的为未连接的）。</p><p>2.设置socket的各项参数：时间？（连接之后还能设置么？)</p><p>3.通过getInputputStream()和getOutputStream()方法得到InputStream和OutputStream流。</p><p>4.操作InputStream和OutputStream流读取或写入数据。</p><p>5.close</p><p>二、服务器端</p><p>1.首先new一个serverSocket（有绑定的serverSocket和未绑定的serverSocket两种：指定服务器端的Port号为绑定的，未指定的为未绑定的）。</p><p>2.设置serverSocket的各项参数：buffersize？</p><p>3.调用accept()方法获得一个和客户端连接的Socket。</p><p>4.通过getInputputStream()和getOutputStream()方法得到InputStream和OutputStream流。</p><p>5.close</p><p>通过以上步骤我们基本上就建立起了客户端和服务器端的通信链路。然后我们讲讲关于Socket和ServerSocket参数设置的问题。</p><p>本文的第二个主线是DatagramSocket和DatagramPacket两个类。</p><p>首先，如何通过UDP协议建立一个客户端和服务器端的通信？</p><p>一、客户端</p><p>1.首先new 一个DatagramSocket（有绑定的DatagramSocket和未绑定的DatagramSocket两种：需指定本地的ip地址和port号，DatagramSocket(SocketAddress localAddr)如果localAddr未null，则为未绑定）。</p><p>2,new一个DatagramPacket实例（需指定主机地址和端口号），填充数据，将其传递给DatagramSocket的send方法。</p><p>3.接收数据时将DatagramPacket实例传递给DatagramSocket的receive方法。</p><p>3,close</p><p>二、服务器端</p><p>其实本质和客户端一样的。</p><p>示例：</p><pre><code>import java.io.BufferedReader;  import java.io.IOException;  import java.io.InputStreamReader;  import java.io.PrintWriter;  import java.net.URL;  import java.net.URLConnection;  import java.util.List;  import java.util.Map;  /**  * @Title   SendRequestUtils.java  * @Package com.pro.huanbao.common.utils  * @author  wanpu_ly  * @dade    2017年10月13日 上午8:43:42  * @version V1.0  * 类说明:   */  public class SendRequestUtils {      /**      * 向指定URL发送GET方法的请求      *       * @param url      *            发送请求的URL      * @param param      *            请求参数，请求参数应该是 name1=value1&amp;name2=value2 的形式。      * @return URL 所代表远程资源的响应结果      */      public static String sendGet(String url, String param) {          String result = &quot;&quot;;          BufferedReader in = null;          try {              String urlNameString = url + &quot;?&quot; + param;              if (param == null) {                  urlNameString = url;              }              URL realUrl = new URL(urlNameString);              // 打开和URL之间的连接              URLConnection connection = realUrl.openConnection();              // 设置通用的请求属性              connection.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;);              connection.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;);              connection.setRequestProperty(&quot;user-agent&quot;,                      &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)&quot;);              // 建立实际的连接              connection.connect();              // 获取所有响应头字段              Map&lt;String, List&lt;String&gt;&gt; map = connection.getHeaderFields();              // 遍历所有的响应头字段              for (String key : map.keySet()) {                  System.out.println(key + &quot;---&gt;&quot; + map.get(key));              }              // 定义 BufferedReader输入流来读取URL的响应              in = new BufferedReader(new InputStreamReader(                      connection.getInputStream()));              String line;              while ((line = in.readLine()) != null) {                  result += line;              }          } catch (Exception e) {              System.out.println(&quot;发送GET请求出现异常！&quot; + e);              e.printStackTrace();          }          // 使用finally块来关闭输入流          finally {              try {                  if (in != null) {                      in.close();                  }              } catch (Exception e2) {                  e2.printStackTrace();              }          }          return result;      }      /**       * 向指定 URL 发送POST方法的请求       *        * @param url       *            发送请求的 URL       * @param param       *            请求参数，请求参数应该是 name1=value1&amp;name2=value2 的形式。       * @return 所代表远程资源的响应结果       */      public static String sendPost(String url, String param) {          PrintWriter out = null;          BufferedReader in = null;          String result = &quot;&quot;;          try {              URL realUrl = new URL(url);              // 打开和URL之间的连接              URLConnection conn = realUrl.openConnection();              // 设置通用的请求属性              conn.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;);              conn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;);              conn.setRequestProperty(&quot;user-agent&quot;,                      &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)&quot;);              // 发送POST请求必须设置如下两行              conn.setDoOutput(true);              conn.setDoInput(true);              // 获取URLConnection对象对应的输出流              out = new PrintWriter(conn.getOutputStream());              // 发送请求参数              out.print(param);              // flush输出流的缓冲              out.flush();              // 定义BufferedReader输入流来读取URL的响应              in = new BufferedReader(                      new InputStreamReader(conn.getInputStream()));              String line;              while ((line = in.readLine()) != null) {                  result += line;              }          } catch (Exception e) {              System.out.println(&quot;发送 POST 请求出现异常！&quot;+e);              e.printStackTrace();          }          //使用finally块来关闭输出流、输入流          finally{              try{                  if(out!=null){                      out.close();                  }                  if(in!=null){                      in.close();                  }              }              catch(IOException ex){                  ex.printStackTrace();              }          }          return result;      }    }  </code></pre><p>不过由于java.net的局限性和性能上的不足，基本上开发互联网产品的时候不会用到</p><p>接下来介绍一些第三方流行的Http库</p><h1 id="apache的httpclient工具类"><a href="#apache的httpclient工具类" class="headerlink" title="apache的httpclient工具类"></a>apache的httpclient工具类</h1><p>示例：</p><pre><code>package org.egg.utils;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.entity.StringEntity;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.nio.charset.Charset;/** * @author dataochen * @Description * @date: 2017/11/7 17:49 */public class HttpRequestUtil {    private static CloseableHttpClient httpClient;    static {        PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();        cm.setMaxTotal(100);        cm.setDefaultMaxPerRoute(20);        cm.setDefaultMaxPerRoute(50);        httpClient = HttpClients.custom().setConnectionManager(cm).build();    }    public static String get(String url) {        CloseableHttpResponse response = null;        BufferedReader in = null;        String result = &quot;&quot;;        try {            HttpGet httpGet = new HttpGet(url);            RequestConfig requestConfig = RequestConfig.custom().setConnectTimeout(30000).setConnectionRequestTimeout(30000).setSocketTimeout(30000).build();            httpGet.setConfig(requestConfig);            httpGet.setConfig(requestConfig);            httpGet.addHeader(&quot;Content-type&quot;, &quot;application/json; charset=utf-8&quot;);            httpGet.setHeader(&quot;Accept&quot;, &quot;application/json&quot;);            response = httpClient.execute(httpGet);            in = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));            StringBuffer sb = new StringBuffer(&quot;&quot;);            String line = &quot;&quot;;            String NL = System.getProperty(&quot;line.separator&quot;);            while ((line = in.readLine()) != null) {                sb.append(line + NL);            }            in.close();            result = sb.toString();        } catch (IOException e) {            e.printStackTrace();        } finally {            try {                if (null != response) {                    response.close();                }            } catch (IOException e) {                e.printStackTrace();            }        }        return result;    }    public static String post(String url, String jsonString) {        CloseableHttpResponse response = null;        BufferedReader in = null;        String result = &quot;&quot;;        try {            HttpPost httpPost = new HttpPost(url);            RequestConfig requestConfig = RequestConfig.custom().setConnectTimeout(30000).setConnectionRequestTimeout(30000).setSocketTimeout(30000).build();            httpPost.setConfig(requestConfig);            httpPost.setConfig(requestConfig);            httpPost.addHeader(&quot;Content-type&quot;, &quot;application/json; charset=utf-8&quot;);            httpPost.setHeader(&quot;Accept&quot;, &quot;application/json&quot;);            httpPost.setEntity(new StringEntity(jsonString, Charset.forName(&quot;UTF-8&quot;)));            response = httpClient.execute(httpPost);            in = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));            StringBuffer sb = new StringBuffer(&quot;&quot;);            String line = &quot;&quot;;            String NL = System.getProperty(&quot;line.separator&quot;);            while ((line = in.readLine()) != null) {                sb.append(line + NL);            }            in.close();            result = sb.toString();        } catch (IOException e) {            e.printStackTrace();        } finally {            try {                if (null != response) {                    response.close();                }            } catch (IOException e) {                e.printStackTrace();            }        }        return result;    }}</code></pre><p>代码所用jar包maven坐标：<br><!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpclient --><br>    <dependency><br>        <groupid>org.apache.httpcomponents</groupid><br>        <artifactid>httpclient</artifactid><br>        <version>4.5.3</version><br>    </dependency><br><!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpcore --><br>    <dependency><br>        <groupid>org.apache.httpcomponents</groupid><br>        <artifactid>httpcore</artifactid><br>        <version>4.4.8</version><br>    </dependency></p><p>Http协议的重要性相信不用我多说了，HttpClient相比传统JDK自带的URLConnection，增加了易用性和灵活性（具体区别，日后我们再讨论），它不仅是客户端发送Http请求变得容易，而且也方便了开发人员测试接口（基于Http协议的），即提高了开发的效率，也方便提高代码的健壮性。因此熟练掌握HttpClient是很重要的必修内容，掌握HttpClient后，相信对于Http协议的了解会更加深入。</p><p>一、简介<br>HttpClient是Apache Jakarta Common下的子项目，用来提供高效的、最新的、功能丰富的支持HTTP协议的客户端编程工具包，并且它支持HTTP协议最新的版本和建议。HttpClient已经应用在很多的项目中，比如Apache Jakarta上很著名的另外两个开源项目Cactus和HTMLUnit都使用了HttpClient。</p><p>二、特性</p><ol><li>基于标准、纯净的java语言。实现了Http1.0和Http1.1</li><li>以可扩展的面向对象的结构实现了Http全部的方法（GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE）。</li><li>支持HTTPS协议。</li><li>通过Http代理建立透明的连接。</li><li>利用CONNECT方法通过Http代理建立隧道的https连接。</li><li>Basic, Digest, NTLMv1, NTLMv2, NTLM2 Session, SNPNEGO/Kerberos认证方案。</li><li>插件式的自定义认证方案。</li><li>便携可靠的套接字工厂使它更容易的使用第三方解决方案。</li><li>连接管理器支持多线程应用。支持设置最大连接数，同时支持设置每个主机的最大连接数，发现并关闭过期的连接。</li><li>自动处理Set-Cookie中的Cookie。</li><li>插件式的自定义Cookie策略。</li><li>Request的输出流可以避免流中内容直接缓冲到socket服务器。</li><li>Response的输入流可以有效的从socket服务器直接读取相应内容。</li><li>在http1.0和http1.1中利用KeepAlive保持持久连接。</li><li>直接获取服务器发送的response code和 headers。</li><li>设置连接超时的能力。</li><li>实验性的支持http1.1 response caching。</li><li>源代码基于Apache License 可免费获取</li></ol><p>三、使用方法<br>   Mavn坐标<br>Java代码  收藏代码<br>    <dependency><br>        <groupid>org.apache.httpcomponents</groupid><br>        <artifactid>httpclient</artifactid><br>        <version>4.3.4</version><br>    </dependency>  </p><p>使用HttpClient发送请求、接收响应很简单，一般需要如下几步即可。</p><ol><li>创建HttpClient对象。</li><li>创建请求方法的实例，并指定请求URL。如果需要发送GET请求，创建HttpGet对象；如果需要发送POST请求，创建HttpPost对象。</li><li>如果需要发送请求参数，可调用HttpGet、HttpPost共同的setParams(HetpParams params)方法来添加请求参数；对于HttpPost对象而言，也可调用setEntity(HttpEntity entity)方法来设置请求参数。</li><li>调用HttpClient对象的execute(HttpUriRequest request)发送请求，该方法返回一个HttpResponse。</li><li>调用HttpResponse的getAllHeaders()、getHeaders(String name)等方法可获取服务器的响应头；调用HttpResponse的getEntity()方法可获取HttpEntity对象，该对象包装了服务器的响应内容。程序可通过该对象获取服务器的响应内容。</li><li>释放连接。无论执行方法是否成功，都必须释放连接</li></ol><p>四.post跟get请求示例<br>Java代码  收藏代码<br>    package com.ickes;  </p><pre><code>import java.util.ArrayList;  import java.util.List;  import org.apache.http.HttpEntity;  import org.apache.http.NameValuePair;  import org.apache.http.client.entity.UrlEncodedFormEntity;  import org.apache.http.client.methods.CloseableHttpResponse;  import org.apache.http.client.methods.HttpGet;  import org.apache.http.client.methods.HttpPost;  import org.apache.http.entity.StringEntity;  import org.apache.http.impl.client.CloseableHttpClient;  import org.apache.http.impl.client.HttpClients;  import org.apache.http.message.BasicNameValuePair;  import org.apache.http.protocol.HTTP;  import org.apache.http.util.EntityUtils;  public class HttpClientDemo {      public static void main(String[] args) throws Exception  {           get();      }      /**      * post方式提交json代码      * @throws Exception       */      public static void postJson() throws Exception{          //创建默认的httpClient实例.           CloseableHttpClient httpclient = null;          //接收响应结果          CloseableHttpResponse response = null;          try {              //创建httppost              httpclient = HttpClients.createDefault();                String url =&quot;http://192.168.16.36:8081/goSearch/gosuncn/deleteDocs.htm&quot;;              HttpPost httpPost = new HttpPost(url);              httpPost.addHeader(HTTP.CONTENT_TYPE,&quot;application/x-www-form-urlencoded&quot;);              //参数              String json =&quot;{&apos;ids&apos;:[&apos;html1&apos;,&apos;html2&apos;]}&quot;;              StringEntity se = new StringEntity(json);              se.setContentEncoding(&quot;UTF-8&quot;);              se.setContentType(&quot;application/json&quot;);//发送json需要设置contentType              httpPost.setEntity(se);              response = httpclient.execute(httpPost);              //解析返结果              HttpEntity entity = response.getEntity();               if(entity != null){                  String resStr = EntityUtils.toString(entity, &quot;UTF-8&quot;);                      System.out.println(resStr);              }          } catch (Exception e) {              throw e;          }finally{              httpclient.close();              response.close();          }      }       /**       * post方式提交表单（模拟用户登录请求）       * @throws Exception       */        public static void postForm() throws Exception  {            // 创建默认的httpClient实例.              CloseableHttpClient httpclient = null;          //发送请求          CloseableHttpResponse response = null;          try {              httpclient = HttpClients.createDefault();                // 创建httppost                  String url= &quot;http://localhost:8080/search/ajx/user.htm&quot;;              HttpPost httppost = new HttpPost(url);                // 创建参数队列                  List&lt;NameValuePair&gt; formparams = new ArrayList&lt;NameValuePair&gt;();                formparams.add(new BasicNameValuePair(&quot;username&quot;, &quot;admin&quot;));                formparams.add(new BasicNameValuePair(&quot;password&quot;, &quot;123456&quot;));              //参数转码              UrlEncodedFormEntity uefEntity = new UrlEncodedFormEntity(formparams, &quot;UTF-8&quot;);                httppost.setEntity(uefEntity);               response = httpclient.execute(httppost);                HttpEntity entity = response.getEntity();                if (entity != null) {                      System.out.println(EntityUtils.toString(entity, &quot;UTF-8&quot;));                }                //释放连接          } catch (Exception e) {              throw e;          }finally{               httpclient.close();               response.close();          }      }        /**       * 发送 get请求       * @throws Exception       */        public static void get() throws Exception {            CloseableHttpClient httpclient = null;          CloseableHttpResponse response = null;          try {              httpclient = HttpClients.createDefault();                // 创建httpget.                  HttpGet httpget = new HttpGet(&quot;http://www.baidu.com/&quot;);                // 执行get请求.                  response = httpclient.execute(httpget);                // 获取响应实体                  HttpEntity entity = response.getEntity();                // 打印响应状态                  System.out.println(response.getStatusLine().getStatusCode());                if (entity != null) {                    // 打印响应内容                      System.out.println(&quot;Response content: &quot; + EntityUtils.toString(entity));                }          } catch (Exception e) {              throw e;          }finally{              httpclient.close();              response.close();          }      }  }  </code></pre><p>五、SSL跟上传文件实例</p><p>Java代码  收藏代码<br>    package com.test;  </p><pre><code>import java.io.File;  import java.io.FileInputStream;  import java.io.IOException;  import java.io.UnsupportedEncodingException;  import java.security.KeyManagementException;  import java.security.KeyStore;  import java.security.KeyStoreException;  import java.security.NoSuchAlgorithmException;  import java.security.cert.CertificateException;  import java.util.ArrayList;  import java.util.List;  import javax.net.ssl.SSLContext;  import org.apache.http.HttpEntity;  import org.apache.http.NameValuePair;  import org.apache.http.ParseException;  import org.apache.http.client.ClientProtocolException;  import org.apache.http.client.entity.UrlEncodedFormEntity;  import org.apache.http.client.methods.CloseableHttpResponse;  import org.apache.http.client.methods.HttpGet;  import org.apache.http.client.methods.HttpPost;  import org.apache.http.conn.ssl.SSLConnectionSocketFactory;  import org.apache.http.conn.ssl.SSLContexts;  import org.apache.http.conn.ssl.TrustSelfSignedStrategy;  import org.apache.http.entity.ContentType;  import org.apache.http.entity.mime.MultipartEntityBuilder;  import org.apache.http.entity.mime.content.FileBody;  import org.apache.http.entity.mime.content.StringBody;  import org.apache.http.impl.client.CloseableHttpClient;  import org.apache.http.impl.client.HttpClients;  import org.apache.http.message.BasicNameValuePair;  import org.apache.http.util.EntityUtils;  import org.junit.Test;  public class HttpClientTest {      @Test      public void jUnitTest() {          ssl();      }      /**      * HttpClient连接SSL      */      public void ssl() {          CloseableHttpClient httpclient = null;          try {              KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());              FileInputStream instream = new FileInputStream(new File(&quot;d:\\tomcat.keystore&quot;));              try {                  // 加载keyStore d:\\tomcat.keystore                    trustStore.load(instream, &quot;123456&quot;.toCharArray());              } catch (CertificateException e) {                  e.printStackTrace();              } finally {                  try {                      instream.close();                  } catch (Exception ignore) {                  }              }              // 相信自己的CA和所有自签名的证书              SSLContext sslcontext = SSLContexts.custom().loadTrustMaterial(trustStore, new TrustSelfSignedStrategy()).build();              // 只允许使用TLSv1协议              SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslcontext, new String[] { &quot;TLSv1&quot; }, null,                      SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);              httpclient = HttpClients.custom().setSSLSocketFactory(sslsf).build();              // 创建http请求(get方式)              HttpGet httpget = new HttpGet(&quot;https://localhost:8443/myDemo/Ajax/serivceJ.action&quot;);              System.out.println(&quot;executing request&quot; + httpget.getRequestLine());              CloseableHttpResponse response = httpclient.execute(httpget);              try {                  HttpEntity entity = response.getEntity();                  System.out.println(&quot;----------------------------------------&quot;);                  System.out.println(response.getStatusLine());                  if (entity != null) {                      System.out.println(&quot;Response content length: &quot; + entity.getContentLength());                      System.out.println(EntityUtils.toString(entity));                      EntityUtils.consume(entity);                  }              } finally {                  response.close();              }          } catch (ParseException e) {              e.printStackTrace();          } catch (IOException e) {              e.printStackTrace();          } catch (KeyManagementException e) {              e.printStackTrace();          } catch (NoSuchAlgorithmException e) {              e.printStackTrace();          } catch (KeyStoreException e) {              e.printStackTrace();          } finally {              if (httpclient != null) {                  try {                      httpclient.close();                  } catch (IOException e) {                      e.printStackTrace();                  }              }          }      }      /**      * 上传文件      */      public void upload() {          CloseableHttpClient httpclient = HttpClients.createDefault();          try {              HttpPost httppost = new HttpPost(&quot;http://localhost:8080/myDemo/Ajax/serivceFile.action&quot;);              FileBody bin = new FileBody(new File(&quot;F:\\image\\sendpix0.jpg&quot;));              StringBody comment = new StringBody(&quot;A binary file of some kind&quot;, ContentType.TEXT_PLAIN);              HttpEntity reqEntity = MultipartEntityBuilder.create().addPart(&quot;bin&quot;, bin).addPart(&quot;comment&quot;, comment).build();              httppost.setEntity(reqEntity);              System.out.println(&quot;executing request &quot; + httppost.getRequestLine());              CloseableHttpResponse response = httpclient.execute(httppost);              try {                  System.out.println(&quot;----------------------------------------&quot;);                  System.out.println(response.getStatusLine());                  HttpEntity resEntity = response.getEntity();                  if (resEntity != null) {                      System.out.println(&quot;Response content length: &quot; + resEntity.getContentLength());                  }                  EntityUtils.consume(resEntity);              } finally {                  response.close();              }          } catch (ClientProtocolException e) {              e.printStackTrace();          } catch (IOException e) {              e.printStackTrace();          } finally {              try {                  httpclient.close();              } catch (IOException e) {                  e.printStackTrace();              }          }      }  }  </code></pre><p>   本实例是采用HttpClient4.3最新版本。该版本与之前的代码写法风格相差较大，大家多留意下。</p><p>参考：<a href="http://blog.csdn.net/wangpeng047/article/details/19624529" target="_blank" rel="noopener">http://blog.csdn.net/wangpeng047/article/details/19624529</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我不是很喜欢JDK的一个重要原因就包括他们缺乏对HTTP的支持。虽然可以使用java.net包类，但是这和直接使用像 Apache HttpClient 和 HttpCore 等开源类库比起来麻烦太多了。&lt;/p&gt;
&lt;p&gt;尽管JDK 9将开始HTTP 2.0，也对HTTP的支持做了优化，但是我还是强烈建议所有的Java开发人员熟悉流行的HTTP处理类库，例如HttpClient和HttpCore HTTP等库。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="java类库" scheme="http://yoursite.com/tags/java%E7%B1%BB%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JAVA开发常用类库--消息传递库</title>
    <link href="http://yoursite.com/2018/03/14/java-api08/"/>
    <id>http://yoursite.com/2018/03/14/java-api08/</id>
    <published>2018-03-14T08:23:02.000Z</published>
    <updated>2018-03-15T04:21:22.759Z</updated>
    
    <content type="html"><![CDATA[<p>像日志和数据库连接池一样，消息传递也是很多实际的Java项目中必备的。Java提供了JMS Java消息服务，但这不是JDK的一部分,你需要单独的引入jms.jar。类似地，如果您准备使用第三方消息传递协议， Tibco RV 是个不错的选择。</p><p>1、问： 什么是 Java 消息服务？<br>答: Java 消息服务(Java Message Service，JMS) API 是一个用于访问企业消息传递系统的 API。是 Java 2 Platform, Enterprise（J2EE）的一部分。</p><a id="more"></a><p>2、目前流行的消息传送产品有哪些？<br>答：目前流行的有ActiveMQ、IBM WebSphere MQ、SonicMQ等</p><p>3、什么时候可以用到java消息机制？<br>答 （1）异构系统集成，整合现有资源，提高资源的利用率<br>   （2）异步请求处理，减轻或消除系统瓶颈，提高用户生产率和系统的整体可伸缩性<br>   （3）组件解偶，增加系统的灵活性</p><p>4、消息传送的两种模型<br>发布/订阅模型<br>客户端发送消息到一个名为主题（topic）的虚拟通道中，每个订阅该主题的消费者都会接收到每条消息的一个副本。<br>点对点模型<br>客户端通过队列（queue）这个虚拟通道来同步和异步发送、接收消息，发送到队列的消息只能被一个接收者所接收，即使有多个消费者时也只能有一个消费者处理消息</p><p>5、JMS包含哪些接口？<br>JMS API可以分为3个主要部分：公共API、点对点API和发布/订阅API。在JMS1.1中，公共API可被用于向一个队列或一个主题发送消息，或从其中接收消息。点对点API专门用于使用队列的消息传送，而发布/订阅API则专门用于使用主题的消息传送。<br>在JMS公共API内部，和发送和接收JMS消息有关的JMS API接口主要有7个：</p><ul><li>ConnectionFactory</li><li>Destination</li><li>Connection</li><li>Session</li><li>Message</li><li>MessageProducer</li><li>MessageConsumer</li></ul><p>在这些公共接口中，ConnectionFactory和Destination必须使用JNDI（遵照JMS规范要求）从提供者处获得。其他接口则可以通过工厂方法在不同的API接口中创建。举例来说，一旦有了一个ConnectionFactory，就可以创建一个 Connection。一旦有了一个Connection，就可以创建一个Session。而一旦有了一个Session，就可以创建一个 Message、MessageProducer和MessageConsumer。这7个主要的JMS公共API接口之间的关系如图1-5所示。<br>在JMS中，是Session对象保存着用于消息传送的事务性工作单元（transactional unit），而不是Connection对象。这和JDBC不同，JDBC中是Connection对象保存事务性工作单元。这就意味着在使用JMS时，一个应用程序通常只会有一个Connection对象，但是它可以有一个Session对象池。<br>另外，还有和异常处理、消息优先级及消息持久性有关的其他接口</p><p>6、java消息分为哪些部分？<br>消息头、消息属性、消息自身</p><p>7、消息过滤<br>消息订阅者需要对消息进行过滤，否则订阅者就会接受到主题或队列的每一条消息，浪费了不必要的资源（CPU、内存等），而使用消息过滤技术，能让订阅者只接受它需要的消息。（消息过滤对于队列消费尤其重要，因为一个队列消费者消费消息后其他消费者就不再可用，此时如果不对消息进行过滤处理，这条消息就很可能被浪费掉）。<br>消息选择器使用消息属性和消息头作为条件表达式的传送载体（消息体不能作为消息选择器的参考对象）。<br>消息选择器由标识符、常量和比较运算符组成：<br>例：<br> 创建一个消息如下：<br>TextMessage textMessage = Session.createTextMessage();<br> textMessage.setText(“mytestMsg”);<br> textMessage.setStringProperty(“city”,”hangzhou”);<br> textMessage.setStringProperty(“company”,”mycompany”);<br> 这条消息中设置的消息属性名“city”和“company”代表消息选择器的标识符，”hangzhou”和”mycompany”代表常量</p><p>  在消费端创建一个选择器：<br>  String selector = “city = ‘hangzhou’ AND company=’mycompany’”;<br>  QueueReceiver qReceiver = qSession.createReceiver(testQ,selector);<br>  其中“=”和“AND”为比较运算符，其他常用比较运算符还有：<br>  算数比较运算符（=、&gt;、&lt;、&lt;=、&lt;&gt;等）<br>  like运算符、BETWEEN运算符、IN运算符、IS NULL运算符等</p><p>8 、消息过滤</p><p>消息订阅者需要对消息进行过滤，否则订阅者就会接受到主题或队列的每一条消息，浪费了不必要的资源（ CPU、内存等），而使用消息过滤技术，能让订阅者只接受它需要的消息。（消息过滤对于队列消费尤其重要，因为一个队列消费者消费消息后其他消费者就不再可用，此时如果不对消息进行过滤处理，这条消息就很可能被浪费掉）。</p><p>消息选择器使用消息属性和消息头作为条件表达式的传送载体（消息体不能作为消息选择器的参考对象）。</p><p>消息选择器由标识符、常量和比较运算符组成：</p><p>例：</p><p>创建一个消息如下：</p><p>TextMessage textMessage = Session.createTextMessage();</p><p> textMessage.setText(“mytestMsg”);</p><p>  textMessage.setStringProperty(“city”,”hangzhou”);</p><p> textMessage.setStringProperty(“company”,”alibaba”);</p><p> 这条消息中设置的消息属性名 “city” 和 “company” 代表消息选择器的标识符， ”hangzhou” 和 ”alibaba”代表常量</p><p>  在消费端创建一个选择器：</p><p>  String selector = “city = ‘hangzhou’ AND company=’alibaba’ ”;</p><p>  QueueReceiver qReceiver = qSession.createReceiver(testQ,selector);</p><p>  其中 “=” 和 “AND” 为比较运算符，其他常用比较运算符还有：</p><p>  算数比较运算符（ = 、 &gt; 、 &lt; 、 &lt;= 、 &lt;&gt; 等）</p><p>  like 运算符、 BETWEEN 运算符、 IN 运算符、 IS NULL 运算符等</p><p>9 、消息传送的可靠性</p><p>在消息的传送过程中由于网络、软硬件故障等都会导致消息的发送失败， jms 为保证消息的传送定义了 3 条法则：</p><p>（ 1 ）消息自主性，消息是自包含的自主性实体，当发送端发出这条消息后这条消息就不再受发送端的限制，它可以在多个进程间被多次发送。</p><p>（ 2 ）存储转发，当消息被标记位持久性消息时，就由 jms 提供者利用 “ 保存并转发 ” 机制，将消息保存在可信的介质上，防止发生故障时仍然可以正常恢复</p><p>（ 3 ）消息确认机制，服务器确认已经从发送端收到了消息，消费者则从确认从服务器接收了消息，对消息传送过程的监控，保证了消息的可靠传送。 消息确认的 3 种模式：</p><p>1 、 AUTO_ACKNOWLEDGE<br>从消息生产者角度：发送消息后就开始阻塞，直到从消息服务器收到回复，期间如发生异常则认为消息未被传送   </p><p>从消息服务器角度：非持久消息在接受到消息后通知生产者，并将消息存入内存，持久性消息在接受道消息后先存入磁盘，然后通知生产者   </p><p>从消费者角度：接受到消息后就向服务器发送确认信息，如果服务器没有收到确认，会重新发送   </p><p>2 、 CLIENT_ACKNOWLEDGE<br>消费者可在处理完业务逻辑后在代码重显示调用 message.acknowledge() 通知 jms 提供者已成功接收道消息<br>3 、 DUPS_ACKNOWLEDGE<br>可将一条消息向同一目的地发送两次以上  </p><p>这里介绍两个概念：</p><p>（ 1 ）持久化消息：消息持久化就是在发送者将消息发送出去后，消息中心首先将消息存储到本地数据文件、内存数据库或者远程数据库等，然后试图将消息发送给接收 者，发送成功则将消息从存储中删除，失败则继续尝试。消息中心启动以后首先要检查制定的存储位置，如果有未发送成功的消息，则需要把消息发送出去。通过在消息头设置来实现：如</p><pre><code>MessageProducer producer = session.createProducer(destination);producer.setDeliveryMode(DeliveryMode.PERSISTENT);</code></pre><p>(2) 持久订阅者和非持久订阅者：非持久订阅者是指某个订阅者由于某种原因停止运行，那么在停止运行期间发布到该订阅者所订阅主题的消息就会无法获得，持久订阅者则刚好相反，持久订阅者会接收发送到订阅主题的所有消息，无论订阅者是否正常运行，电子邮件就是类似的一个例子。</p><p>持久化消息和持久订阅者在服务器和消费者端之间的消息传送保证机制比较类似，但在有一种情况下他们还是存在区别的，对持久订阅者来说，当消息服务器向发送者发送确认消息之后，并为当前未运行的持久订阅者将消息保存到介质之间如果发送故障，该消息就会丢失，而持久化消息则是先保存消息道介质，然后才向发送者发送确认消息，所以不存在这个问题，因此严格来说持久化消息的可靠性会更高。</p><p>10 、事务性消息</p><p>jms 事务性保证了一组发送的消息或接收的消息要么全部成功要么全部失败，概念上和我们在java 中使用的jta 相似，但jms 事务是由jms 提供者来管理的，而不是jta 。</p><p>使用方法如下：</p><p>   // 此处用true ，表示使用事务性消息</p><pre><code>Session session =connection.createSession(true, Session.AUTO_ACKNOWLEDGE);</code></pre><p>// 用来发送的3 个消息</p><pre><code>MessageProducer sender = session.createProducer(“queue/testQueue”);try{    TextMessage message1 = session.createTextMessage(“ 要发送的消息1”);　　    sender.send(message);    TextMessage message2 = session.createTextMessage(“ 要发送的消息2”);　　    sender.send(message);    TextMessage message3 = session.createTextMessage(“ 要发送的消息3”);　　    sender.send(message);        session.commit();    }catch(Exception e){        try{          session.rollback();       }catch(JMSException e){       }    }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;像日志和数据库连接池一样，消息传递也是很多实际的Java项目中必备的。Java提供了JMS Java消息服务，但这不是JDK的一部分,你需要单独的引入jms.jar。类似地，如果您准备使用第三方消息传递协议， Tibco RV 是个不错的选择。&lt;/p&gt;
&lt;p&gt;1、问： 什么是 Java 消息服务？&lt;br&gt;答: Java 消息服务(Java Message Service，JMS) API 是一个用于访问企业消息传递系统的 API。是 Java 2 Platform, Enterprise（J2EE）的一部分。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="java类库" scheme="http://yoursite.com/tags/java%E7%B1%BB%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JAVA开发常用类库--字节码库</title>
    <link href="http://yoursite.com/2018/03/14/java-api07/"/>
    <id>http://yoursite.com/2018/03/14/java-api07/</id>
    <published>2018-03-14T04:18:19.000Z</published>
    <updated>2018-03-14T09:39:45.962Z</updated>
    
    <content type="html"><![CDATA[<p>也许你写了无数行的代码，也许你能非常溜的使用高级语言，但是你未必了解那些高级语言的执行过程。例如大行其道的Java。</p><p>Java号称是一门“一次编译到处运行”的语言，但是我们对这句话的理解深度又有多少呢？从我们写的java文件到通过编译器编译成java字节码文件（也就是.class文件），这个过程是java编译过程；而我们的java虚拟机执行的就是字节码文件。不论该字节码文件来自何方，由哪种编译器编译，甚至是手写字节码文件，只要符合java虚拟机的规范，那么它就能够执行该字节码文件。那么本文主要讲讲java字节码文件相关知识。接下来我们通过具体的Demo来深入理解：</p><a id="more"></a><h1 id="首先我们来写一个java源文件"><a href="#首先我们来写一个java源文件" class="headerlink" title="首先我们来写一个java源文件"></a>首先我们来写一个java源文件</h1><p><img src="/2018/03/14/java-api07/p1.png" alt="logo"></p><p>上面是我们写的一个java程序，很简单，只有一个成员变量a以及一个方法testMethod() 。</p><p>接下来我们用javac命令或者ide工具将该java源文件编译成java字节码文件。</p><p><img src="/2018/03/14/java-api07/p2.png" alt="logo"></p><p>上图是编译好的字节码文件，我们可以看到一堆16进制的字节。如果你使用IDE去打开，也许看到的是已经被反编译的我们所熟悉的java代码，而这才是纯正的字节码，这也是我们今天需要讲的内容重点。</p><p>也许你会对这样一堆字节码感到头疼，不过没关系，我们慢慢试着你看懂它，或许有不一样的收获。在开始之前我们先来看一张图</p><p><img src="/2018/03/14/java-api07/p3.png" alt="logo"></p><p>这张图是一张java字节码的总览图，我们也就是按照上面的顺序来对字节码进行解读的。一共含有10部分，包含魔数，版本号，常量池等等，接下来我们按照顺序一步一步解读。</p><h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><p>从上面的总览图中我们知道前4个字节表示的是魔数，对应我们Demo的是 0XCAFE BABE。什么是魔数？魔数是用来区分文件类型的一种标志，一般都是用文件的前几个字节来表示。比如0XCAFE BABE表示的是class文件，那么有人会问，文件类型可以通过文件名后缀来判断啊？是的，但是文件名是可以修改的（包括后缀），那么为了保证文件的安全性，讲文件类型写在文件内部来保证不被篡改。<br>从java的字节码文件类型我们看到，CAFE BABE翻译过来是咖啡宝贝之意，然后再看看java图标。</p><p>CAFE BABE = 咖啡。</p><p><img src="/2018/03/14/java-api07/p4.png" alt="logo"></p><h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><p>我们识别了文件类型之后，接下来要知道版本号。版本号含主版本号和次版本号，都是各占2个字节。在此Demo种为0X0000 0033。其中前面的0000是次版本号，后面的0033是主版本号。通过进制转换得到的是次版本号为0，主版本号为51。<br>从oracle官方网站我们能够知道，51对应的正式jdk1.7，而其次版本为0，所以该文件的版本为1.7.0。如果需要验证，可以在用java –version命令输出版本号，或者修改编译目标版本–target重新编译，查看编译后的字节码文件版本号是否做了相应的修改。</p><p>至此，我们共了解了前8字节的含义，下面讲讲常量池相关内容。</p><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>紧接着主版本号之后的就是常量池入口。常量池是Class文件中的资源仓库，在接下来的内容中我们会发现很多地方会涉及，如Class Name，Interfaces等。常量池中主要存储2大类常量：字面量和符号引用。字面量如文本字符串，java中声明为final的常量值等等，而符号引用如类和接口的全局限定名，字段的名称和描述符，方法的名称和描述符。</p><p>为什么需要类和接口的全局限定名呢？系统引用类或者接口的时候不是通过内存地址进行操作吗？这里大家仔细想想，java虚拟机在没有将类加载到内存的时候根本都没有分配内存地址，也就不存在对内存的操作，所以java虚拟机首先需要将类加载到虚拟机中，那么这个过程设计对类的定位（需要加载A包下的B类，不能加载到别的包下面的别的类中），所以需要通过全局限定名来判别唯一性。这就是为什么叫做全局，限定的意思，也就是唯一性。</p><p>在进行具体常量池分析之前，我们先来了解一下常量池的项目类型表：</p><p><img src="/2018/03/14/java-api07/p5.png" alt="logo"></p><p>上面的表中描述了11中数据类型的结构，其实在jdk1.7之后又增加了3种（CONSTANT_MethodHandle_info,CONSTANT_MethodType_info以及CONSTANT_InvokeDynamic_info)。这样算起来一共是14种。接下来我们按照Demo的字节码进行逐一翻译。</p><p>0x0015：由于常量池的数量不固定（n+2），所以需要在常量池的入口处放置一项u2类型的数据代表常量池数量。因此该16进制是21，表示有20项常量，索引范围为1~20。明明是21，为何是20呢？因为Class文件格式规定，设计者就讲第0项保留出来了，以备后患。从这里我们知道接下来我们需要翻译出20项常量。<br>Constant #1 （一共有20个常量，这是第一个，以此类推…）<br>0x0a-：从常量类型表中我们发现，第一个数据均是u1类型的tag，16进制的0a是十进制的10，对应表中的MethodRef_info。<br>0x-00 04-：Class_info索引项#4<br>0x-00 11-：NameAndType索引项#17<br>Constant #2<br>0x-09: FieldRef_info<br>0x0003 :Class_info索引项#3<br>0x0012：NameAndType索引项#18<br>Constant #3<br>0x07-: Class_info<br>0x-00 13-: 全局限定名常量索引为#19<br>Constant #4<br>0x-07 :Class_info<br>0x0014:全局限定名常量索引为#20<br>Constant #5<br>0x01:Utf-8_info<br>0x-00 01-:字符串长度为1（选择接下来的一个字节长度转义）<br>0x-61:”a”(十六进制转ASCII字符)<br>Constant #6<br>0x01:Utf-8_info<br>0x-00 01：字符串长度为1<br>0x-49:”I”<br>Constant #7<br>0x01:Utf-8_info<br>0x-00 06:字符串长度为6<br>0x-3c 696e 6974 3e-:”<init>“<br>Constant #8<br>0x01 :UTF-8_info<br>0x0003:字符串长度为3<br>0x2829 56:”()V”<br>Constant #9<br>0x-01:Utf-8_info<br>0x0004：字符串长度为4<br>0x436f 6465:”Code”<br>Constant #10<br>0x01:Utf-8_info<br>0x00 0f:字符串长度为15<br>0x4c 696e 654e 756d 6265 7254 6162 6c65:”LineNumberTable”<br>Constant #11<br>ox01: Utf-8_info<br>0x00 12字符串长度为18<br>0x-4c 6f63 616c 5661 7269 6162 6c65 5461 626c 65:”LocalVariableTable”<br>Constant #12<br>0x01:Utf-8_info<br>0x0004 字符串长度为4<br>0x7468 6973 :”this”<br>Constant #13<br>0x01:Utf-8_info<br>0x0f:字符串长度为15<br>0x4c 636f 6d2f 6465 6d6f 2f44 656d 6f3b:”Lcom/demo/Demo;”<br>Constant #14<br>0x01:Utf-8_info<br>0x00 0a:字符串长度为10<br>ox74 6573 744d 6574 686f 64:”testMethod”<br>Constant #15<br>0x01:Utf-8_info<br>0x000a:字符串长度为10<br>0x536f 7572 6365 4669 6c65 :”SourceFile”<br>Constant #16<br>0x01:Utf-8_info<br>0x0009:字符串长度为9<br>0x-44 656d 6f2e 6a61 7661 :”Demo.java”<br>Constant #17<br>0x0c :NameAndType_info<br>0x0007:字段或者名字名称常量项索引#7<br>0x0008:字段或者方法描述符常量索引#8<br>Constant #18<br>0x0c:NameAndType_info<br>0x0005:字段或者名字名称常量项索引#5<br>0x0006:字段或者方法描述符常量索引#6<br>Constant #19<br>0x01:Utf-8_info<br>0x00 0d:字符串长度为13<br>0x63 6f6d 2f64 656d 6f2f 4465 6d6f:”com/demo/Demo”<br>Constant #20<br>0x01:Utf-8_info<br>0x00 10 :字符串长度为16<br>0x6a 6176 612f 6c61 6e67 2f4f 626a 6563 74 :”java/lang/Object”<br>到这里为止我们解析了所有的常量。接下来是解析访问标志位。</init></p><h2 id="Access-Flag-访问标志"><a href="#Access-Flag-访问标志" class="headerlink" title="Access_Flag 访问标志"></a>Access_Flag 访问标志</h2><p>访问标志信息包括该Class文件是类还是接口，是否被定义成public，是否是abstract，如果是类，是否被声明成final。通过上面的源代码，我们知道该文件是类并且是public。</p><p><img src="/2018/03/14/java-api07/p6.png" alt="logo"></p><p>0x 00 21：是0x0020和0x0001的并集。其中0x0020这个标志值涉及到了字节码指令，后期会有专题对字节码指令进行讲解。</p><p>类索引</p><p>类索引用于确定类的全限定名<br>0x00 03 表示引用第3个常量，同时第3个常量引用第19个常量，查找得”com/demo/Demo”。#3.#19</p><h2 id="父类索引"><a href="#父类索引" class="headerlink" title="父类索引"></a>父类索引</h2><p>0x00 04 同理：#4.#20(java/lang/Object)</p><h2 id="接口索引"><a href="#接口索引" class="headerlink" title="接口索引"></a>接口索引</h2><p>通过java_byte.jpeg图我们知道，这个接口有2+n个字节，前两个字节表示的是接口数量，后面跟着就是接口的表。我们这个类没有任何接口，所以应该是0000。果不其然，查找字节码文件得到的就是0000。</p><h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><p>字段表用于描述类和接口中声明的变量。这里的字段包含了类级别变量以及实例变量，但是不包括方法内部声明的局部变量。<br>同样，接下来就是2+n个字段属性。我们只有一个属性a，按道理应该是0001。查找文件果不其然是0001。<br>那么接下来我们要针对这样的字段进行解析。附上字段表结构图</p><p><img src="/2018/03/14/java-api07/p7.png" alt="logo"></p><p>0x00 02 ：访问标志为private（自行搜索字段访问标志）<br>0x00 05 : 字段名称索引为#5，对应的是”a”<br>0x 00 06 :描述符索引为#6，对应的是”I”<br>0x 00 00 :属性表数量为0，因此没有属性表。<br>tips:一些不太重要的表（字段，方法访问标志表）可以自行搜索，这里就不贴出来了，防止篇幅过大。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>我们只有一个方法testMethod，按照道理应该前2个字节是0001。通过查找发现是0x00 02。这是什么原因，这代表着有2个方法呢？且继续看……</p><p><img src="/2018/03/14/java-api07/p8.png" alt="logo"></p><p>上图是一张方法表结构图，按照这个图我们分析下面的字节码：</p><p>第1个方法：</p><p>0x00 01：访问标志 ACC_PUBLIC，表明该方法是public。（可自行搜索方法访问标志表）<br>0x00 07：方法名索引为#7，对应的是”<init>“<br>0x00 08：方法描述符索引为#8，对应的是”()V”<br>0x00 01：属性表数量为1(一个属性表)<br>那么这里涉及到了属性表。什么是属性表呢？可以这么理解，它是为了描述一些专有信息的，上面的方法带有一张属性表。所有属性表的结构如下图：<br>一个u2的属性名称索引，一个u2的属性长度加上属性长度的info。<br>虚拟机规范预定义的属性有很多，比如Code，LineNumberTable，LocalVariableTable，SourceFile等等，这个网上可以搜索到。</init></p><p><img src="/2018/03/14/java-api07/p9.png" alt="logo"></p><p>按照上面的表结构解析得到下面信息：<br>0x0009:名称索引为#9(“Code”)。<br>0x000 00038：属性长度为56字节。<br>那么接下来解析一个Code属性表，按照下图解析</p><p><img src="/2018/03/14/java-api07/p9.png" alt="logo"></p><p>前面6个字节（名称索引2字节+属性长度4字节）已经解析过了，所以接下来就是解析剩下的56-6=50字节即可。<br>0x00 02 ：max_stack=2<br>0x00 01 : max_locals=1<br>0x00 0000 0a : code_length=10<br>0x2a b700 012a 04b5 0002 b1 : 这是code代码，可以通过虚拟机字节码指令进行查找。<br>2a=aload_0(将第一个引用变量推送到栈顶)<br>b7=invokespecial(调用父类构造方法)<br>00=什么都不做<br>01 =将null推送到栈顶<br>2a=同上<br>04=iconst_1 将int型1推送到栈顶<br>b5=putfield 为指定的类的实例变量赋值<br>00= 同上<br>02=iconst_m1 将int型-1推送栈顶<br>b1=return 从当前方法返回void<br>整理，去除无动作指令得到下面<br>0 : aload_0<br>1 : invokespecial<br>4 : aload_0<br>5 : iconst_1<br>6 : putfield<br>9 : return<br>关于虚拟机字节码指令这块内容，后期会继续深入下去…… 目前只需要了解即可。接下来顺着Code属性表继续解析下去:<br>0x00 00 : exception_table_length=0<br>0x00 02 : attributes_count=2(Code属性表内部还含有2个属性表)<br>0x00 0a: 第一个属性表是”LineNumberTable”</p><p><img src="/2018/03/14/java-api07/p10.png" alt="logo"></p><p>0x00 0000 0a : “属性长度为10”<br>0x00 02 ：line_number_table_length=2<br>line_number_table是一个数量为line_number_table_length，类型为line_number_info的集合，line_number_info表包括了start_pc和line_number两个u2类型的数据项，前者是字节码行号，后者是Java源码行号<br>0x00 00 : start_pc =0<br>0x00 03 : end_pc =3<br>0x00 04 : start_pc=4<br>0x00 04 : end_pc=4</p><p>0x00 0b 第二个属性表是：”LocalVariableTable”</p><p><img src="/2018/03/14/java-api07/p11.png" alt="logo"></p><p><img src="/2018/03/14/java-api07/p12.png" alt="logo"></p><p>local_variable_table.png<br>local_variable_info.png<br>0x00 0000 0c：属性长度为12<br>0x00 01 : local_variable_table_length=1<br>然后按照local_variable_info表结构进行解析：<br>0x00 00 : start_pc=0<br>0x00 0a：length=10<br>0x000c : name_index=”this”<br>0x000d : descriptor_index #13 (“Lcom/demo/Demo”)<br>0000 index=0<br>//——-到这里第一个方法就解析完成了——-//<br>Method（<init>)–1个属性Code表-2个属性表（LineNumberTable ，LocalVariableTable）接下来解析第二个方法</init></p><p>第2个方法：</p><p>0x00 04：”protected”<br>0x00 0e: #14（”testMethod”）<br>0x00 08 : “()V”<br>0x0001 ： 属性数量=1<br>0x0009 ：”Code”<br>0x0000 002b 属性长度为43<br>解析一个Code表<br>0000 :max_stack =0<br>0001 : max_local =1<br>0000 0001 : code_length =1<br>0xb1 : return(该方法返回void)<br>0x0000 异常表长度=0<br>0x0002 属性表长度为2<br>//第一个属性表<br>0x000a : #10，LineNumberTable<br>0x0000 0006 : 属性长度为6<br>0x0001 : line_number_length = 1<br>0x0000 : start_pc =0<br>0x0008 : end_pc =8<br>//第二个属性表<br>0x000b : #11 ，LocalVariableTable<br>0x0000 000c : 属性长度为12<br>0x0001 : local_variable_table_length =1<br>0x0000 :start_pc = 0<br>0x0001: length = 1<br>0x000c : name_index =#12 “this”<br>0x000d : 描述索引#13 “Lcom/demo/Demo;”<br>0000 index=0</p><p>//到这里为止，方法解析都完成了，回过头看看顶部解析顺序图，我们接下来就要解析Attributes了。</p><h2 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h2><p>0x0001 ：同样的，表示有1个Attributes了。<br>0x000f : #15(“SourceFile”)<br>0x0000 0002 attribute_length=2<br>0x0010 : sourcefile_index = #16(“Demo.java”)<br>SourceFile属性用来记录生成该Class文件的源码文件名称。</p><p><img src="/2018/03/14/java-api07/p13.png" alt="logo"></p><h1 id="另话"><a href="#另话" class="headerlink" title="另话"></a>另话</h1><p>其实，我们写了这么多确实很麻烦，不过这种过程自己体验一遍的所获所得还是不同的。现在，使用java自带的反编译器来解析字节码文件。<br>javap -verbose Demo //不用带后缀.class</p><p><img src="/2018/03/14/java-api07/p14.png" alt="logo"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到此为止，讲解完成了class文件的解析，这样以后我们也能看懂字节码文件了。了解class文件的结构对后面进一步了解虚拟机执行引擎非常重要，所以这是基础并重要的一步。</p><p>作者：小腊月<br>链接：<a href="https://www.jianshu.com/p/252f381a6bc4" target="_blank" rel="noopener">https://www.jianshu.com/p/252f381a6bc4</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><hr><p>以上是java字节码的介绍<br>属于JVM底层的知识</p><p>接下来介绍的是java操作字节库的类库有哪些及相关操作</p><h1 id="字节码操作"><a href="#字节码操作" class="headerlink" title="字节码操作"></a>字节码操作</h1><p>1.Java动态性的两种常见实现方式：</p><p>字节码操作<br>反射</p><p>2.运行时操作字节码可以实现如下功能：</p><p>动态生成新的类<br>动态改变某个类的结构(添加/删除/修改 新的属性/方法)</p><p>3.优势：</p><p>比反射开销小，性能高<br>Javaasist性能高于反射，低于ASM</p><h2 id="常见的字节码操作类库"><a href="#常见的字节码操作类库" class="headerlink" title="常见的字节码操作类库"></a>常见的字节码操作类库</h2><p>1.BCEL</p><p>Byte Code Engineering Library(BCEL)，这是Apache Software Foundation的Jakarta项目的一部分。BCEL是Java classworking 广泛使用的一种框架，它可以让您深入jvm汇编语言进行类库操作的细节。BCEL与javassist有不同的处理字节码方法，BCEL在实际的jvm指令层次上进行操作(BCEL拥有丰富的jvm指令集支持) 而javassist所强调的是源代码级别的工作。</p><p>2.ASM</p><p>是一个轻量级Java字节码操作框架，直接涉及到JVM底层的操作和指令<br>高性能，高质量</p><p>3.CGLB(code generation library)</p><p>生成类库，基于ASM实现</p><p>4.javassist</p><p>是一个开源的分析，编辑和创建Java字节码的类库。性能较ASM差，跟cglib差不多，但是使用简单。很多开源框架都在使用它。<br>主页： <a href="http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/javassist/" target="_blank" rel="noopener">http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/javassist/</a></p><h2 id="javassist库的API详解"><a href="#javassist库的API详解" class="headerlink" title="javassist库的API详解"></a>javassist库的API详解</h2><p>javassist的最外层的API和java的反射包中的API及其类似</p><p>它主要有CtClass, CtMethod,CtField几个类组成，用于执行和JDK反射API中java.lang.Class, java.lang,reflect.Method,java.lang.reflect.Method.Field相同的操作</p><p>创建一个类</p><pre><code>public class JavassistTest {      public static void main(String[] args) throws Exception {          ClassPool pool = ClassPool.getDefault();          CtClass cc = pool.makeClass(&quot;bean.User&quot;);          //创建属性          CtField field01 = CtField.make(&quot;private int id;&quot;,cc);          CtField field02 = CtField.make(&quot;private String name;&quot;, cc);          cc.addField(field01);          cc.addField(field02);          //创建方法          CtMethod method01 = CtMethod.make(&quot;public String getName(){return name;}&quot;, cc);          CtMethod method02 = CtMethod.make(&quot;public void setName(String name){this.name = name;}&quot;, cc);          cc.addMethod(method01);          cc.addMethod(method02);          //添加有参构造器          CtConstructor constructor = new CtConstructor(new CtClass[]{CtClass.intType,pool.get(&quot;java.lang.String&quot;)},cc);          constructor.setBody(&quot;{this.id=id;this.name=name;}&quot;);          cc.addConstructor(constructor);          //无参构造器          CtConstructor cons = new CtConstructor(null,cc);          cons.setBody(&quot;{}&quot;);          cc.addConstructor(cons);          cc.writeFile(&quot;E:/workspace/TestCompiler/src&quot;);      }  } </code></pre><p>方法操作</p><p>修改已有的方法体（插入代码到已有方法体）<br>新增方法<br>删除方法</p><p>$0 $1 $2          $0代表是this, $1代表方法参数的第一个参数，$2代表方法参数的第二个参数，以此类推，$N代表方法参数的第N个<br>$args             The type of $args is OBject[]. $args(0)对应的是$1，不是$0<br>$$                 一个方法调用的深度<br>$r                 方法返回值的类型<br>$_                 方法返回值。(修改方法体时不支持)<br>addCatch()         方法中加入try catch块  $e代表 异常对象<br>$class             this的类型(Class)。也就是$0的类型<br>$sig             方法参数的类型(Class)数组，数组的顺序。</p><p>构造方法操作</p><p>getConstructors()</p><p>注解操作</p><pre><code>public @interface Author{String name();int year();}@Author(name=&quot;over&quot;,year=2012)public class Point{int x,int y;}CtClass cc=ClassPool.getDefault().get(&quot;Point&quot;);Object[] all = cc.getAnnotations();Author a =(Author)all[0];String name = a.name();int year = a.year();System.out.println(name+&quot;:&quot;+year);</code></pre><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p>JDK5.0新语法不支持(包括泛型，枚举)，不支持注解修改，但可以通过底层的javassist类来解决，具体参考：javassist,bytecode.annotation<br>不支持数组的初始化，如String[]{“a”,”b”},除非只有数组的容量为1<br>不支持内部类和匿名类<br>不支持continue和break 表达式<br>对于继承关系，有些不支持 。例如</p><pre><code>class A{}class B extends A{}Class C extends B{}</code></pre><p>查资料： javassist与反射的性能比较</p><pre><code>public class Demo01 {      //获取类的简单信息      public static void test01() throws Exception{          ClassPool pool = ClassPool.getDefault();          CtClass cc = pool.get(&quot;bean.User&quot;);          //得到字节码          byte[] bytes = cc.toBytecode();          System.out.println(Arrays.toString(bytes));          System.out.println(cc.getName());//获取类名          System.out.println(cc.getSimpleName());//获取简要类名          System.out.println(cc.getSuperclass());//获取父类          System.out.println(cc.getInterfaces());//获取接口          System.out.println(cc.getMethods());//获取      }      //新生成一个方法      public static void test02() throws Exception{          ClassPool pool = ClassPool.getDefault();          CtClass cc = pool.get(&quot;bean.User&quot;);          //第一种          //CtMethod cm = CtMethod.make(&quot;public String getName(){return name;}&quot;, cc);          //第二种          //参数：返回值类型，方法名，参数，对象          CtMethod cm = new CtMethod(CtClass.intType,&quot;add&quot;,new CtClass[]{CtClass.intType,CtClass.intType},cc);          cm.setModifiers(Modifier.PUBLIC);//访问范围          cm.setBody(&quot;{return $1+$2;}&quot;);          //cc.removeMethod(m) 删除一个方法          cc.addMethod(cm);          //通过反射调用方法          Class clazz = cc.toClass();          Object obj = clazz.newInstance();//通过调用无参构造器，生成新的对象          Method m = clazz.getDeclaredMethod(&quot;add&quot;, int.class,int.class);          Object result = m.invoke(obj, 2,3);          System.out.println(result);      }      //修改已有的方法      public static void test03() throws Exception{          ClassPool pool  = ClassPool.getDefault();          CtClass cc = pool.get(&quot;bean.User&quot;);          CtMethod cm = cc.getDeclaredMethod(&quot;hello&quot;,new CtClass[]{pool.get(&quot;java.lang.String&quot;)});          cm.insertBefore(&quot;System.out.println(\&quot;调用前\&quot;);&quot;);//调用前          cm.insertAt(29, &quot;System.out.println(\&quot;29\&quot;);&quot;);//行号          cm.insertAfter(&quot;System.out.println(\&quot;调用后\&quot;);&quot;);//调用后          //通过反射调用方法          Class clazz = cc.toClass();          Object obj = clazz.newInstance();          Method m = clazz.getDeclaredMethod(&quot;hello&quot;, String.class);          Object result = m.invoke(obj, &quot;张三&quot;);          System.out.println(result);           }      //修改已有属性      public static void test04() throws Exception{          ClassPool pool  = ClassPool.getDefault();          CtClass cc = pool.get(&quot;bean.User&quot;);          //属性          CtField cf = new CtField(CtClass.intType,&quot;age&quot;,cc);          cf.setModifiers(Modifier.PRIVATE);          cc.addField(cf);          //增加响应的get set方法          cc.addMethod(CtNewMethod.getter(&quot;getAge&quot;,cf));          cc.addMethod(CtNewMethod.setter(&quot;setAge&quot;,cf));          //访问属性          Class clazz = cc.toClass();          Object obj = clazz.newInstance();                 Field field = clazz.getDeclaredField(&quot;age&quot;);          System.out.println(field);          Method m = clazz.getDeclaredMethod(&quot;setAge&quot;, int.class);          m.invoke(obj, 16);          Method m2 = clazz.getDeclaredMethod(&quot;getAge&quot;, null);          Object resutl = m2.invoke(obj,null);                  System.out.println(resutl);      }      //操作构造方法      public static void test05() throws Exception{          ClassPool pool = ClassPool.getDefault();          CtClass cc = pool.get(&quot;bean.User&quot;);          CtConstructor[] cons = cc.getConstructors();          for(CtConstructor con:cons){              System.out.println(con);          }      }      public static void main(String[] args) throws Exception {          //test01();          //test02();          //test03();          //test04();          test05();      }  }  </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;也许你写了无数行的代码，也许你能非常溜的使用高级语言，但是你未必了解那些高级语言的执行过程。例如大行其道的Java。&lt;/p&gt;
&lt;p&gt;Java号称是一门“一次编译到处运行”的语言，但是我们对这句话的理解深度又有多少呢？从我们写的java文件到通过编译器编译成java字节码文件（也就是.class文件），这个过程是java编译过程；而我们的java虚拟机执行的就是字节码文件。不论该字节码文件来自何方，由哪种编译器编译，甚至是手写字节码文件，只要符合java虚拟机的规范，那么它就能够执行该字节码文件。那么本文主要讲讲java字节码文件相关知识。接下来我们通过具体的Demo来深入理解：&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="java类库" scheme="http://yoursite.com/tags/java%E7%B1%BB%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JAVA开发常用类库--常用类库</title>
    <link href="http://yoursite.com/2018/03/14/java-api06/"/>
    <id>http://yoursite.com/2018/03/14/java-api06/</id>
    <published>2018-03-14T04:09:18.000Z</published>
    <updated>2018-03-14T10:20:06.965Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Java 类库概念：</strong><br>Java 的应用程序接口 (API) 以包的形式来组织，每个包提供了大量的相关类、接口和异常处理类，这些包的集合就是 Java 的类库</p><p>包名以 Java 开始的包是 Java 核心包 (Java Core Package) ；</p><p>包名以 Javax 开始的包是 Java 扩展包 (Java Extension Package) ，例如 javax.swing 包；</p><a id="more"></a><p>常用的 Java 核心包 (Java Core Package)</p><ol><li><p><strong>java.lang</strong>      Java 编程语言的基本类库</p></li><li><p>java.applet     创建 applet 需要的所有类</p></li><li><p>java.awt       创建用户界面以及绘制和管理图形、图像的类</p></li><li><p>java.io        通过数据流、对象序列以及文件系统实现的系统输入、输出</p></li><li><p>java.net       用于实现网络通讯应用的所有类</p></li><li><p><strong>java.util</strong>       集合类、时间处理模式、日期时间工具等各类常用工具包</p></li></ol><p>其它还有</p><ol><li><p>java.sql        访问和处理来自于 Java 标准数据源数据的类</p></li><li><p>java.test       以一种独立于自然语言的方式处理文本、日期、数字和消息的类和接口</p></li><li><p>java.security    设计网络安全方案需要的一些类</p></li><li><p>java.beans     开发 Java Beans 需要的所有类</p></li><li><p>java.math      简明的整数算术以及十进制算术的基本函数</p></li><li><p>java.rmi       与远程方法调用相关的所有类，rmi即Remote Method Invoke远程方法调用</p></li></ol><p>常用的 Java 扩展包 (Java Extension Package)</p><ol><li><p>javax.accessibility  定义了用户界面组件之间相互访问的一种机制</p></li><li><p>javax.naming.*     为命名服务提供了一系列类和接口</p></li><li><p>javax.swing.*       提供了一系列轻量级的用户界面组件，是目前 Java 用户界面常用的包</p></li></ol><p>注 1 ：最重要且常用的是 1 和 6 ，已用黑体标出的为，需重点掌握</p><p>注 2 ：在使用 Java 时，除了 java.lang 外，其他的包都需要 import 语句引入之后才能使用。</p><p>重点讲解内容：java.lang和java.util。具体各方法在开发文档里写的很清楚</p><p>java.lang 包</p><p>这个包称为 java 语言包，是由编译器自动引入的。程序中不必用 import 语句就可以使用。它所包含的类和接口对所有实际的 Java 程序都是必要的。</p><ol><li><p>object 类</p></li><li><p>数学类 (Math)</p></li><li><p>数据类型类</p></li><li><p>线程类</p></li><li><p>字符串类 (String 类和 StringBuffer 类 )</p></li><li><p>系统及运行类 (System 类和 Runtime 类 )</p></li><li><p>错误和异常处理类 (Throwable 、 Exception 、 Error)</p></li><li><p>过程类 (process)</p></li></ol><p>java.util 包</p><ol><li><p>日期类、日历类（ Data 、 Calendar 、 GregorianCalendar ）</p></li><li><p>随机数类（ Random ）</p></li><li><p>位运算类（ BitSet ）</p></li><li><p>矢量类（ Vector ）</p></li><li><p>数据结构类（ Stack ）</p></li><li><p>散列表类（ Hashtable ）</p></li><li><p>StringTokenizer类</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Java 类库概念：&lt;/strong&gt;&lt;br&gt;Java 的应用程序接口 (API) 以包的形式来组织，每个包提供了大量的相关类、接口和异常处理类，这些包的集合就是 Java 的类库&lt;/p&gt;
&lt;p&gt;包名以 Java 开始的包是 Java 核心包 (Java Core Package) ；&lt;/p&gt;
&lt;p&gt;包名以 Javax 开始的包是 Java 扩展包 (Java Extension Package) ，例如 javax.swing 包；&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="java类库" scheme="http://yoursite.com/tags/java%E7%B1%BB%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JAVA开发常用类库--日期和时间库</title>
    <link href="http://yoursite.com/2018/03/13/java-api05/"/>
    <id>http://yoursite.com/2018/03/13/java-api05/</id>
    <published>2018-03-13T11:08:58.000Z</published>
    <updated>2018-03-13T12:28:59.864Z</updated>
    
    <content type="html"><![CDATA[<p>在Java之前，JDK的日期和时间库一直被人们所诟病，比如其非线程安全的、不可变的、容易出错等。很多开发人员会选择更好用的 JodaTime 类库。<br>但是在Java8推出之后，我们就可以彻底放弃JodaTime了，因为Java 8提供了其所有功能。但是，如果你的代码运行在一个低版本的JDK中，那么JodaTime还是值得使用的。</p><a id="more"></a><p>Java 8 新特性：</p><h1 id="Java-类库的新特性之日期时间API-Date-Time-API"><a href="#Java-类库的新特性之日期时间API-Date-Time-API" class="headerlink" title="Java 类库的新特性之日期时间API (Date/Time API )"></a>Java 类库的新特性之日期时间API (Date/Time API )</h1><p>文章来自：<br><a href="http://blog.csdn.net/sun_promise/article/details/51383618" target="_blank" rel="noopener">http://blog.csdn.net/sun_promise/article/details/51383618</a></p><h2 id="Java8之前java-util-Date和Calendar类的弊端"><a href="#Java8之前java-util-Date和Calendar类的弊端" class="headerlink" title="Java8之前java.util.Date和Calendar类的弊端"></a>Java8之前java.util.Date和Calendar类的弊端</h2><p>1）最开始的时候，Date既要承载日期信息，又要做日期之间的转换，还要做不同日期格式的显示，职责较繁杂（不遵守单一职责）。</p><p>后来从JDK 1.1 开始，这三项职责分开了：</p><p>使用Calendar类实现日期和时间字段之间转换；<br>使用DateFormat类来格式化和分析日期字符串；<br>Date只用来承载日期和时间信息。<br>现在原有Date中的相应方法已废弃。无论是Date，还是Calendar，都使用着太不方便，这是API没有设计好的地方。</p><p>2）令人无语的year和month（month是从0开始的）</p><p>eg：</p><pre><code>[java] view plain copyDate date = new Date(2016,1,1);     System.out.println(date);   </code></pre><p>输出结果：Tue Feb 01 00:00:00 CST 3916<br>这样得到的结果year为2012+1900，而month明明给定的参数是1，却输出的是二月。<br>设置日期可以用java.util.Calendar</p><pre><code>[java] view plain copyCalendar calendar = Calendar.getInstance();     calendar.set(2016, 5, 2);  </code></pre><p>虽然Calendar年份的传值不需要减去1900，但Calendar的month也是从0开始的，表达5月份应该用4这个数字。<br>3）java.util.Date与java.util.Calendar中的所有属性都是可变的，且线程不安全。</p><pre><code>eg：[java] view plain copypublic class Test {      public static void main(String[] args) {          Calendar birth = Calendar.getInstance();          birth.set(1975, Calendar.MAY, 26);          Calendar now = Calendar.getInstance();          System.out.println(daysBetween(birth, now)); // 输出结果为14963，值不固定          System.out.println(daysBetween(birth, now)); // 输出结果 显示 0？      }  }      public static long daysBetween(Calendar begin, Calendar end) {              long daysBetween = 0;              while(begin.before(end)) {                  begin.add(Calendar.DAY_OF_MONTH, 1);                  daysBetween++;             }             return daysBetween;         }   }  </code></pre><p>Note:daysBetween有点问题，如果连续计算两个Date实例的话，第二次会取得0，因为Calendar状态是可变的，考虑到重复计算的场合，最好复制一个新的Calendar。修改代码如下<br>    [java] view plain copy<br>    public static long daysBetween(Calendar begin, Calendar end) {<br>        Calendar calendar = (Calendar) begin.clone(); // 复制<br>            long daysBetween = 0;<br>            while(calendar.before(end)) {<br>                calendar.add(Calendar.DAY_OF_MONTH, 1);<br>                daysBetween++;<br>            }<br>            return daysBetween;<br>    } </p><h2 id="新的日期时间API"><a href="#新的日期时间API" class="headerlink" title="新的日期时间API"></a>新的日期时间API</h2><p>Java 的日期与时间 API 问题由来已久，Java 8 之前的版本中关于时间、日期及其他时间日期格式化类由于线程安全、重量级、序列化成本高等问题而饱受批评。Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的 API。新的 java.time 中包含了所有关于时钟（Clock），本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）和持续时间（Duration）的类。历史悠久的 Date 类新增了 toInstant() 方法，用于把 Date 转换成新的表示形式。这些新增的本地化时间日期 API 大大简化了了日期时间和本地化的管理。</p><p>目前Java8新增了java.time包定义的类表示日期-时间概念的规则，很方便使用；最重要的一点是值不可变，且线程安全。</p><p>下图是java.time包下的一些主要的类的日期时间 值的格式，方便理解使用：</p><p><img src="/2018/03/13/java-api05/main.png" alt="logo"> </p><p>Note：不过尽管有了新的API，但仍有一个严重的问题——大量的旧代码和库仍然在使用老的API。现在，Java 8解决了这个问题，它给Date类增加了一个新的方法toInstant()，可以将Date转化成新的实例。这样就可以切换到新的API。</p><p>对于新API：</p><p>非常有用的值类型：<br>Instant —– 与java.util.Date相似<br>ZonedDateTime —– ZoneId -时区很重要的时候使用<br>OffsetDateTime —– OffsetTime, ZoneOffset -对UTC的偏移处理<br>Duration, Period —– 但如果你想找到两个日期之间的时间量，你可能会寻找ChronoUnit代替（详情见下文）<br>其他有用的类型：<br>DateTimeFormatter —– 将日期类型转换成字符串类型<br>ChronoUnit —– 计算出两点之间的时间量，例如ChronoUnit.DAYS.between(t1, t2)<br>TemporalAdjuster —– 例如date.with(TemporalAdjuster.firstDayOfMonth())<br>Note：大多数情况下，新的值类型由JDBC提供支持。有一小部分异常，eg：ZonedDateTime在SQL中没有对应的（类型）。</p><h2 id="Java-新旧日期API的区别"><a href="#Java-新旧日期API的区别" class="headerlink" title="Java 新旧日期API的区别"></a>Java 新旧日期API的区别</h2><p><img src="/2018/03/13/java-api05/pp.png" alt="logo"></p><h2 id="java-time包下的类"><a href="#java-time包下的类" class="headerlink" title="java.time包下的类"></a>java.time包下的类</h2><p>Clock类</p><p>Clock类提供了访问当前日期和时间的方法。Clock使用时区来访问当前的instant, date和time。Clock类可以替换 System.currentTimeMillis() 和 TimeZone.getDefault()。</p><pre><code>eg：[java] view plain copy//Clock 时钟              Clock clock1 = Clock.systemDefaultZone();//获取系统默认时区 (当前瞬时时间 )              System.out.println( &quot;系统时间日期：&quot;+clock1.instant() );              System.out.println( &quot;时间毫秒：&quot;+clock1.millis() );              final Clock clock = Clock.systemUTC();//获取系统时钟，并将其转换成使用UTC时区的日期和时间              System.out.println( &quot;时间日期：&quot;+clock.instant() );              System.out.println( &quot;时间毫秒值：&quot;+clock.millis() );  </code></pre><p>输出结果：<br>系统时间日期：2016-05-12T07:42:37.883Z<br>时间毫秒：1463038957894<br>时间日期：2016-05-12T07:42:37.894Z</p><p>时间毫秒值：1463038957894</p><p>某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。</p><pre><code>eg：[java] view plain copyInstant instant = clock1.instant();              Date javadate = Date.from(instant);               System.out.println( &quot;date：&quot;+javadate);  </code></pre><p>输出结果：</p><p>date：Thu May 12 15:47:00 CST 2016</p><p>ZoneId（时区）</p><p>在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of()来获取到。时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。</p><pre><code>eg:[java] view plain copy// 输出所有可见的时区ID，eg：Asia/Aden, America/Cuiaba, Etc/GMT+9等  System.out.println(ZoneId.getAvailableZoneIds());  ZoneId zone1 = ZoneId.of(&quot;Europe/Berlin&quot;);  ZoneId zone2 = ZoneId.of(&quot;Brazil/East&quot;);  System.out.println(zone1.getRules());  System.out.println(zone2.getRules());  //输出结果： ZoneRules[currentStandardOffset=+01:00]  //输出结果： ZoneRules[currentStandardOffset=-03:00]  </code></pre><p>LocalTime（本地时间）</p><p>LocalTime 定义了一个没有时区信息的时间。</p><p>eg：</p><p>1）获取现在的本地时间</p><pre><code>[java] view plain copy// Get the local date and local time              final LocalTime time = LocalTime.now();              final LocalTime timeFromClock = LocalTime.now( clock );              System.out.println( time );              System.out.println( timeFromClock );  </code></pre><p>输出结果：<br>16:03:23.212<br>08:03:23.212</p><p>2）按时区显示时间</p><pre><code>[java] view plain copyZoneId zone1 = ZoneId.of(&quot;Europe/Berlin&quot;);          ZoneId zone2 = ZoneId.of(&quot;Brazil/East&quot;);          LocalTime now1 = LocalTime.now(zone1);          LocalTime now2 = LocalTime.now(zone2);          System.out.println(&quot;时区：Europe/Berlin---&quot;+now1);           System.out.println(&quot;时区：Brazil/East---&quot;+now2);   </code></pre><p>输出结果：</p><p>时区：Europe/Berlin—10:03:23.217<br>时区：Brazil/East—05:03:23.217</p><p>LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串。</p><pre><code>eg：[java] view plain copyLocalTime late = LocalTime.of(22, 12, 18);//时分秒          System.out.println(late); // 输出结果：22:12:18          DateTimeFormatter germanFormatter = DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT)                  .withLocale(Locale.GERMAN);          LocalTime leetTime = LocalTime.parse(&quot;15:39&quot;, germanFormatter);          System.out.println(leetTime); // 输出结果： 15:39  </code></pre><p>LocalDate(本地日期)</p><p>LocalDate 表示了一个确切的日期（eg： 2014-03-11）。该对象值是不可变的，使用方式和LocalTime基本一致。</p><pre><code>eg:[java] view plain copyClock clock = Clock.systemDefaultZone();// 获取系统默认时区 (当前瞬时时间 )          // Get the local date and local time          final LocalDate date = LocalDate.now();          final LocalDate dateFromClock = LocalDate.now(clock);          System.out.println(date);          System.out.println(dateFromClock);  </code></pre><p>输出结果:<br>2016-05-12<br>2016-05-12</p><p>从字符串解析一个LocalDate类型和解析LocalTime一样简单.</p><pre><code>eg：[java] view plain copyDateTimeFormatter germanFormatter = DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM)          .withLocale(Locale.GERMAN);  LocalDate xmas = LocalDate.parse(&quot;25.10.2016&quot;, germanFormatter);  System.out.println(xmas);  </code></pre><p>输出结果：<br>2016-10-25</p><p>LocalDateTime（本地日期时间）</p><p>表示了具体时间和日期。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。</p><pre><code>eg：1）[java] view plain copyClock clock = Clock.systemDefaultZone();// 获取系统默认时区 (当前瞬时时间 )          // Get the local date/time          final LocalDateTime datetime = LocalDateTime.now();          final LocalDateTime datetimeFromClock = LocalDateTime.now(clock);          System.out.println(datetime);          System.out.println(datetimeFromClock);  </code></pre><p>输出结果：<br>2016-05-12T16:33:17.546<br>2016-05-12T16:33:17.546</p><pre><code>2）[java] view plain copyLocalDateTime sylvester = LocalDateTime.of(2016, Month.DECEMBER, 31, 23, 59, 59);      DayOfWeek dayOfWeek = sylvester.getDayOfWeek();      System.out.println(dayOfWeek);            Month month = sylvester.getMonth();      System.out.println(month);              long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);      System.out.println(minuteOfDay);    </code></pre><p>输出结果：</p><p>SATURDAY<br>DECEMBER<br>1439</p><p>只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date。<br>    eg：</p><pre><code>[java] view plain copyLocalDateTime sylvester = LocalDateTime.of(2016, Month.DECEMBER, 31, 23, 59, 59);          Instant instant = sylvester                  .atZone(ZoneId.systemDefault())                  .toInstant();          Date legacyDate = Date.from(instant);          System.out.println(legacyDate);  </code></pre><p>输出结果：</p><p>Sat Dec 31 23:59:59 CST 2016</p><p>格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我也可以自定义格式。</p><pre><code>eg:[java] view plain copyDateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;MM dd, yyyy - HH:mm&quot;);      LocalDateTime parsed = LocalDateTime.parse(&quot;05 03, 2016 - 07:13&quot;, formatter);      String string = formatter.format(parsed);      System.out.println(string);  </code></pre><p>输出结果：<br>05 03, 2016 - 07:13</p><p>Note:和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。</p><p>ZonedDateTime（日期时间和时区信息）</p><p>使用ZonedDateTime，它保存有ISO-8601日期系统的日期和时间，而且有时区信息。</p><pre><code>eg：[java] view plain copyClock clock = Clock.systemDefaultZone();// 获取系统默认时区 (当前瞬时时间 )  // Get the zoned date/time  final ZonedDateTime zonedDatetime = ZonedDateTime.now();  final ZonedDateTime zonedDatetimeFromClock = ZonedDateTime.now(clock);  final ZonedDateTime zonedDatetimeFromZone = ZonedDateTime.now(ZoneId.of(&quot;America/Los_Angeles&quot;));  System.out.println(zonedDatetime);  System.out.println(zonedDatetimeFromClock);  System.out.println(zonedDatetimeFromZone);  </code></pre><p>输出结果：</p><p>2016-05-12T16:59:55.779+08:00[Asia/Shanghai]<br>2016-05-12T16:59:55.779+08:00[Asia/Shanghai]<br>2016-05-12T01:59:55.781-07:00[America/Los_Angeles]</p><p>Duration类</p><p>Duration持有的时间精确到纳秒。很容易计算两个日期中间的差异。</p><pre><code>eg：求时间差[java] view plain copy              // Get duration between two dates  final LocalDateTime from = LocalDateTime.of(2014, Month.APRIL, 16, 0, 0, 0);//年月日时分秒  final LocalDateTime to = LocalDateTime.of(2015, Month.APRIL, 16, 23, 59, 59);  final Duration duration = Duration.between(from, to);  System.out.println(&quot;Duration in days: &quot; + duration.toDays());  System.out.println(&quot;Duration in hours: &quot; + duration.toHours());</code></pre><h2 id="新日期时间API示例"><a href="#新日期时间API示例" class="headerlink" title="新日期时间API示例"></a>新日期时间API示例</h2><pre><code>import java.time.Clock;  import java.time.Duration;  import java.time.Instant;  import java.time.LocalDateTime;  import java.time.ZoneId;  import java.time.ZonedDateTime;  import java.time.chrono.ChronoLocalDateTime;  import java.time.chrono.Chronology;  import java.time.chrono.HijrahChronology;  import java.time.format.DateTimeFormatter;  import java.time.temporal.IsoFields;  import java.util.Date;  public class TimeTest {      public static void main(String[] args) throws InterruptedException {          testClock();  //      testInstant();  //      testLocalDateTime();  //      testZonedDateTime();  //      testDuration();  //      testChronology();  //      testNewOldDateConversion();      }      public static void testClock() throws InterruptedException {          // 时钟提供给我们用于访问某个特定 时区的 瞬时时间、日期 和 时间的。             Clock c1 = Clock.systemUTC(); // 系统默认UTC时钟（当前瞬时时间           System.out.println(c1.millis()); // 每次调用将返回当前瞬时时间（UTC）          //相当于System.currentTimeMillis()）          Clock c2 = Clock.systemDefaultZone(); // 系统默认时区时钟（当前瞬时时间）          Clock c31 = Clock.system(ZoneId.of(&quot;Europe/Paris&quot;)); // 巴黎时区          System.out.println(c31.instant()); // 每次调用将返回当前瞬时时间（UTC）          Clock c32 = Clock.system(ZoneId.of(&quot;Asia/Shanghai&quot;));// 上海时区          System.out.println(c32.instant());// 每次调用将返回当前瞬时时间（UTC）          Clock c4 = Clock.fixed(Instant.now(), ZoneId.of(&quot;Asia/Shanghai&quot;));// 固定上海时区时钟          System.out.println(c4.millis());          Thread.sleep(1000);          System.out.println(c4.millis()); // 不变 即时钟时钟在那一个点不动          Clock c5 = Clock.offset(c1, Duration.ofSeconds(2)); // 相对于系统默认时钟两秒的时钟          System.out.println(c1.millis());          System.out.println(c5.millis());      }      public static void testInstant() {          // 瞬时时间 相当于以前的System.currentTimeMillis()          Instant instant1 = Instant.now();          System.out.println(instant1.getEpochSecond());// 精确到秒 得到相对于1970-01-01                                                          // 00:00:00 UTC的一个时间          System.out.println(instant1.toEpochMilli()); // 精确到毫秒          Clock clock1 = Clock.systemUTC(); // 获取系统UTC默认时钟          Instant instant2 = Instant.now(clock1);// 得到时钟的瞬时时间          System.out.println(instant2.toEpochMilli());          Clock clock2 = Clock.fixed(instant1, ZoneId.systemDefault()); // 固定瞬时时间时钟          Instant instant3 = Instant.now(clock2);// 得到时钟的瞬时时间          System.out.println(instant3.toEpochMilli());// equals instant1      }      public static void testLocalDateTime() {          // 使用默认时区时钟瞬时时间创建 Clock.systemDefaultZone() --&gt;即相对于          // ZoneId.systemDefault()默认时区          LocalDateTime now = LocalDateTime.now();          System.out.println(now);          // 自定义时区          LocalDateTime now2 = LocalDateTime.now(ZoneId.of(&quot;Europe/Paris&quot;));          System.out.println(now2);// 会以相应的时区显示日期          // 自定义时钟          Clock clock = Clock.system(ZoneId.of(&quot;Asia/Dhaka&quot;));          LocalDateTime now3 = LocalDateTime.now(clock);          System.out.println(now3);// 会以相应的时区显示日期          // 不需要写什么相对时间 如java.util.Date 年是相对于1900 月是从0开始          // 2013-12-31 23:59          LocalDateTime d1 = LocalDateTime.of(2013, 12, 31, 23, 59);          // 年月日 时分秒 纳秒          LocalDateTime d2 = LocalDateTime.of(2013, 12, 31, 23, 59, 59, 11);          // 使用瞬时时间 + 时区          Instant instant = Instant.now();          LocalDateTime d3 = LocalDateTime.ofInstant(Instant.now(), ZoneId.systemDefault());          System.out.println(d3);          // 解析String---&gt;LocalDateTime          LocalDateTime d4 = LocalDateTime.parse(&quot;2013-12-31T23:59&quot;);          System.out.println(d4);          LocalDateTime d5 = LocalDateTime.parse(&quot;2013-12-31T23:59:59.999&quot;);// 999毫秒                                                                              // 等价于999000000纳秒          System.out.println(d5);          // 使用DateTimeFormatter API 解析 和 格式化          DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy/MM/dd HH:mm:ss&quot;);          LocalDateTime d6 = LocalDateTime.parse(&quot;2013/12/31 23:59:59&quot;, formatter);          System.out.println(formatter.format(d6));          // 时间获取          System.out.println(d6.getYear());          System.out.println(d6.getMonth());          System.out.println(d6.getDayOfYear());          System.out.println(d6.getDayOfMonth());          System.out.println(d6.getDayOfWeek());          System.out.println(d6.getHour());          System.out.println(d6.getMinute());          System.out.println(d6.getSecond());          System.out.println(d6.getNano());          // 时间增减          LocalDateTime d7 = d6.minusDays(1);          LocalDateTime d8 = d7.plus(1, IsoFields.QUARTER_YEARS);          // LocalDate 即年月日 无时分秒          // LocalTime即时分秒 无年月日          // API和LocalDateTime类似就不演示了      }      public static void testZonedDateTime() {          // 即带有时区的date-time 存储纳秒、时区和时差（避免与本地date-time歧义）。          // API和LocalDateTime类似，只是多了时差(如2013-12-20T10:35:50.711+08:00[Asia/Shanghai])          ZonedDateTime now = ZonedDateTime.now();          System.out.println(now);          ZonedDateTime now2 = ZonedDateTime.now(ZoneId.of(&quot;Europe/Paris&quot;));          System.out.println(now2);          // 其他的用法也是类似的 就不介绍了          ZonedDateTime z1 = ZonedDateTime.parse(&quot;2013-12-31T23:59:59Z[Europe/Paris]&quot;);          System.out.println(z1);      }      public static void testDuration() {          // 表示两个瞬时时间的时间段          Duration d1 = Duration.between(Instant.ofEpochMilli(System.currentTimeMillis() - 12323123), Instant.now());          // 得到相应的时差          System.out.println(d1.toDays());          System.out.println(d1.toHours());          System.out.println(d1.toMinutes());          System.out.println(d1.toMillis());          System.out.println(d1.toNanos());          // 1天时差 类似的还有如ofHours()          Duration d2 = Duration.ofDays(1);          System.out.println(d2.toDays());      }      public static void testChronology() {          // 提供对java.util.Calendar的替换，提供对年历系统的支持          Chronology c = HijrahChronology.INSTANCE;          ChronoLocalDateTime d = c.localDateTime(LocalDateTime.now());          System.out.println(d);      }      /**      * 新旧日期转换      */      public static void testNewOldDateConversion() {          Instant instant = new Date().toInstant();          Date date = Date.from(instant);          System.out.println(instant);          System.out.println(date);      }  }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java之前，JDK的日期和时间库一直被人们所诟病，比如其非线程安全的、不可变的、容易出错等。很多开发人员会选择更好用的 JodaTime 类库。&lt;br&gt;但是在Java8推出之后，我们就可以彻底放弃JodaTime了，因为Java 8提供了其所有功能。但是，如果你的代码运行在一个低版本的JDK中，那么JodaTime还是值得使用的。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="java类库" scheme="http://yoursite.com/tags/java%E7%B1%BB%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JAVA开发常用类库--PDF处理库</title>
    <link href="http://yoursite.com/2018/03/13/java-api04/"/>
    <id>http://yoursite.com/2018/03/13/java-api04/</id>
    <published>2018-03-13T10:45:08.000Z</published>
    <updated>2018-03-13T11:08:31.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iText"><a href="#iText" class="headerlink" title="iText"></a>iText</h1><p>iText是一个能够快速产生PDF文件的java类库。iText的java类对于那些要产生包含文本，表格，图形的只读文档是很有用的。它的类库尤其与java Servlet有很好的给合。使用iText与PDF能够使你正确的控制Servlet的输出。<br>该项目主页:<a href="http://www.lowagie.com/iText/" target="_blank" rel="noopener">http://www.lowagie.com/iText/</a></p><p>iText是著名的开放项目，是用于生成PDF文档的一个java类库。通过iText不仅可以生成PDF或rtf的文档，而且可以将XML、Html文件转化为PDF文件。</p><p>Harness the power of PDF with iText</p><p>Easy PDF generation and manipulation for Java and .NET developers</p><a id="more"></a><h2 id="生成一个PDF"><a href="#生成一个PDF" class="headerlink" title="生成一个PDF"></a>生成一个PDF</h2><pre><code>//Step 1—Create a Document.  Document document = new Document();  //Step 2—Get a PdfWriter instance.  PdfWriter.getInstance(document, new FileOutputStream(FILE_DIR + &quot;createSamplePDF.pdf&quot;));  //Step 3—Open the Document.  document.open();  //Step 4—Add content.  document.add(new Paragraph(&quot;Hello World&quot;));  //Step 5—Close the Document.  document.close(); </code></pre><h2 id="页面大小-页面背景色-页边空白-Title-Author-Subject-Keywords"><a href="#页面大小-页面背景色-页边空白-Title-Author-Subject-Keywords" class="headerlink" title="页面大小,页面背景色,页边空白,Title,Author,Subject,Keywords"></a>页面大小,页面背景色,页边空白,Title,Author,Subject,Keywords</h2><pre><code>//页面大小  Rectangle rect = new Rectangle(PageSize.B5.rotate());  //页面背景色  rect.setBackgroundColor(BaseColor.ORANGE);  Document doc = new Document(rect);  PdfWriter writer = PdfWriter.getInstance(doc, out);  //PDF版本(默认1.4)  writer.setPdfVersion(PdfWriter.PDF_VERSION_1_2);  //文档属性  doc.addTitle(&quot;Title@sample&quot;);  doc.addAuthor(&quot;Author@rensanning&quot;);  doc.addSubject(&quot;Subject@iText sample&quot;);  doc.addKeywords(&quot;Keywords@iText&quot;);  doc.addCreator(&quot;Creator@iText&quot;);  //页边空白  doc.setMargins(10, 20, 30, 40);  doc.open();  doc.add(new Paragraph(&quot;Hello World&quot;)); </code></pre><h2 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h2><pre><code>PdfWriter writer = PdfWriter.getInstance(doc, out);  // 设置密码为：&quot;World&quot;  writer.setEncryption(&quot;Hello&quot;.getBytes(), &quot;World&quot;.getBytes(),          PdfWriter.ALLOW_SCREENREADERS,          PdfWriter.STANDARD_ENCRYPTION_128);  doc.open();  doc.add(new Paragraph(&quot;Hello World&quot;));</code></pre><h2 id="添加Page"><a href="#添加Page" class="headerlink" title="添加Page"></a>添加Page</h2><pre><code>document.open();  document.add(new Paragraph(&quot;First page&quot;));  document.add(new Paragraph(Document.getVersion()));  document.newPage();  writer.setPageEmpty(false);  document.newPage();  document.add(new Paragraph(&quot;New page&quot;));</code></pre><h2 id="添加水印-背景图"><a href="#添加水印-背景图" class="headerlink" title="添加水印(背景图)"></a>添加水印(背景图)</h2><pre><code>//图片水印  PdfReader reader = new PdfReader(FILE_DIR + &quot;setWatermark.pdf&quot;);  PdfStamper stamp = new PdfStamper(reader, new FileOutputStream(FILE_DIR          + &quot;setWatermark2.pdf&quot;));  Image img = Image.getInstance(&quot;resource/watermark.jpg&quot;);  img.setAbsolutePosition(200, 400);  PdfContentByte under = stamp.getUnderContent(1);  under.addImage(img);  //文字水印  PdfContentByte over = stamp.getOverContent(2);  over.beginText();  BaseFont bf = BaseFont.createFont(BaseFont.HELVETICA, BaseFont.WINANSI,          BaseFont.EMBEDDED);  over.setFontAndSize(bf, 18);  over.setTextMatrix(30, 30);  over.showTextAligned(Element.ALIGN_LEFT, &quot;DUPLICATE&quot;, 230, 430, 45);  over.endText();  //背景图  Image img2 = Image.getInstance(&quot;resource/test.jpg&quot;);  img2.setAbsolutePosition(0, 0);  PdfContentByte under2 = stamp.getUnderContent(3);  under2.addImage(img2);  stamp.close();  reader.close();</code></pre><h2 id="插入Chunk-Phrase-Paragraph-List"><a href="#插入Chunk-Phrase-Paragraph-List" class="headerlink" title="插入Chunk, Phrase, Paragraph, List"></a>插入Chunk, Phrase, Paragraph, List</h2><pre><code>//Chunk对象: a String, a Font, and some attributes  document.add(new Chunk(&quot;China&quot;));  document.add(new Chunk(&quot; &quot;));  Font font = new Font(Font.FontFamily.HELVETICA, 6, Font.BOLD, BaseColor.WHITE);  Chunk id = new Chunk(&quot;chinese&quot;, font);  id.setBackground(BaseColor.BLACK, 1f, 0.5f, 1f, 1.5f);  id.setTextRise(6);  document.add(id);  document.add(Chunk.NEWLINE);  document.add(new Chunk(&quot;Japan&quot;));  document.add(new Chunk(&quot; &quot;));  Font font2 = new Font(Font.FontFamily.HELVETICA, 6, Font.BOLD, BaseColor.WHITE);  Chunk id2 = new Chunk(&quot;japanese&quot;, font2);  id2.setBackground(BaseColor.BLACK, 1f, 0.5f, 1f, 1.5f);  id2.setTextRise(6);  id2.setUnderline(0.2f, -2f);  document.add(id2);  document.add(Chunk.NEWLINE);  //Phrase对象: a List of Chunks with leading  document.newPage();  document.add(new Phrase(&quot;Phrase page&quot;));  Phrase director = new Phrase();  Chunk name = new Chunk(&quot;China&quot;);  name.setUnderline(0.2f, -2f);  director.add(name);  director.add(new Chunk(&quot;,&quot;));  director.add(new Chunk(&quot; &quot;));  director.add(new Chunk(&quot;chinese&quot;));  director.setLeading(24);  document.add(director);  Phrase director2 = new Phrase();  Chunk name2 = new Chunk(&quot;Japan&quot;);  name2.setUnderline(0.2f, -2f);  director2.add(name2);  director2.add(new Chunk(&quot;,&quot;));  director2.add(new Chunk(&quot; &quot;));  director2.add(new Chunk(&quot;japanese&quot;));  director2.setLeading(24);  document.add(director2);  //Paragraph对象: a Phrase with extra properties and a newline  document.newPage();  document.add(new Paragraph(&quot;Paragraph page&quot;));  Paragraph info = new Paragraph();  info.add(new Chunk(&quot;China &quot;));  info.add(new Chunk(&quot;chinese&quot;));  info.add(Chunk.NEWLINE);  info.add(new Phrase(&quot;Japan &quot;));  info.add(new Phrase(&quot;japanese&quot;));  document.add(info);  //List对象: a sequence of Paragraphs called ListItem  document.newPage();  List list = new List(List.ORDERED);  for (int i = 0; i &lt; 10; i++) {      ListItem item = new ListItem(String.format(&quot;%s: %d movies&quot;,              &quot;country&quot; + (i + 1), (i + 1) * 100), new Font(              Font.FontFamily.HELVETICA, 6, Font.BOLD, BaseColor.WHITE));      List movielist = new List(List.ORDERED, List.ALPHABETICAL);      movielist.setLowercase(List.LOWERCASE);      for (int j = 0; j &lt; 5; j++) {          ListItem movieitem = new ListItem(&quot;Title&quot; + (j + 1));          List directorlist = new List(List.UNORDERED);          for (int k = 0; k &lt; 3; k++) {              directorlist.add(String.format(&quot;%s, %s&quot;, &quot;Name1&quot; + (k + 1),                      &quot;Name2&quot; + (k + 1)));          }          movieitem.add(directorlist);          movielist.add(movieitem);      }      item.add(movielist);      list.add(item);  }  document.add(list);</code></pre><h2 id="插入Anchor-Image-Chapter-Section"><a href="#插入Anchor-Image-Chapter-Section" class="headerlink" title="插入Anchor, Image, Chapter, Section"></a>插入Anchor, Image, Chapter, Section</h2><pre><code>//Anchor对象: internal and external links  Paragraph country = new Paragraph();  Anchor dest = new Anchor(&quot;china&quot;, new Font(Font.FontFamily.HELVETICA, 14, Font.BOLD, BaseColor.BLUE));  dest.setName(&quot;CN&quot;);  dest.setReference(&quot;http://www.china.com&quot;);//external  country.add(dest);  country.add(String.format(&quot;: %d sites&quot;, 10000));  document.add(country);  document.newPage();  Anchor toUS = new Anchor(&quot;Go to first page.&quot;, new Font(Font.FontFamily.HELVETICA, 14, Font.BOLD, BaseColor.BLUE));  toUS.setReference(&quot;#CN&quot;);//internal  document.add(toUS);  //Image对象  document.newPage();  Image img = Image.getInstance(&quot;resource/test.jpg&quot;);  img.setAlignment(Image.LEFT | Image.TEXTWRAP);  img.setBorder(Image.BOX);  img.setBorderWidth(10);  img.setBorderColor(BaseColor.WHITE);  img.scaleToFit(1000, 72);//大小  img.setRotationDegrees(-30);//旋转  document.add(img);  //Chapter, Section对象（目录）  document.newPage();  Paragraph title = new Paragraph(&quot;Title&quot;);  Chapter chapter = new Chapter(title, 1);  title = new Paragraph(&quot;Section A&quot;);  Section section = chapter.addSection(title);  section.setBookmarkTitle(&quot;bmk&quot;);  section.setIndentation(30);  section.setBookmarkOpen(false);  section.setNumberStyle(  Section.NUMBERSTYLE_DOTTED_WITHOUT_FINAL_DOT);  Section subsection = section.addSection(new Paragraph(&quot;Sub Section A&quot;));  subsection.setIndentationLeft(20);  subsection.setNumberDepth(1);  document.add(chapter);  </code></pre><h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><pre><code>//左右箭头  document.add(new VerticalPositionMark() {      public void draw(PdfContentByte canvas, float llx, float lly,              float urx, float ury, float y) {          canvas.beginText();          BaseFont bf = null;          try {              bf = BaseFont.createFont(BaseFont.ZAPFDINGBATS, &quot;&quot;, BaseFont.EMBEDDED);          } catch (Exception e) {              e.printStackTrace();          }          canvas.setFontAndSize(bf, 12);          // LEFT          canvas.showTextAligned(Element.ALIGN_CENTER, String.valueOf((char) 220), llx - 10, y, 0);          // RIGHT          canvas.showTextAligned(Element.ALIGN_CENTER, String.valueOf((char) 220), urx + 10, y + 8, 180);          canvas.endText();      }  });  //直线  Paragraph p1 = new Paragraph(&quot;LEFT&quot;);  p1.add(new Chunk(new LineSeparator()));  p1.add(&quot;R&quot;);  document.add(p1);  //点线  Paragraph p2 = new Paragraph(&quot;LEFT&quot;);  p2.add(new Chunk(new DottedLineSeparator()));  p2.add(&quot;R&quot;);  document.add(p2);  //下滑线  LineSeparator UNDERLINE = new LineSeparator(1, 100, null, Element.ALIGN_CENTER, -2);  Paragraph p3 = new Paragraph(&quot;NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN&quot;);  p3.add(UNDERLINE);  document.add(p3);  </code></pre><h2 id="设置段落"><a href="#设置段落" class="headerlink" title="设置段落"></a>设置段落</h2><pre><code>Paragraph p = new Paragraph(&quot;In the previous example, you added a header and footer with the showTextAligned() method. This example demonstrates that it’s sometimes more interesting to use PdfPTable and writeSelectedRows(). You can define a bottom border for each cell so that the header is underlined. This is the most elegant way to add headers and footers, because the table mechanism allows you to position and align lines, images, and text.&quot;);  //默认  p.setAlignment(Element.ALIGN_JUSTIFIED);  document.add(p);  document.newPage();  p.setAlignment(Element.ALIGN_JUSTIFIED);  p.setIndentationLeft(1 * 15f);  p.setIndentationRight((5 - 1) * 15f);  document.add(p);  //居右  document.newPage();  p.setAlignment(Element.ALIGN_RIGHT);  p.setSpacingAfter(15f);  document.add(p);  //居左  document.newPage();  p.setAlignment(Element.ALIGN_LEFT);  p.setSpacingBefore(15f);  document.add(p);  //居中  document.newPage();  p.setAlignment(Element.ALIGN_CENTER);  p.setSpacingAfter(15f);  p.setSpacingBefore(15f);  document.add(p);  </code></pre><h2 id="删除Page"><a href="#删除Page" class="headerlink" title="删除Page"></a>删除Page</h2><pre><code>FileOutputStream out = new FileOutputStream(FILE_DIR + &quot;deletePage.pdf&quot;);  Document document = new Document();  PdfWriter writer = PdfWriter.getInstance(document, out);  document.open();  document.add(new Paragraph(&quot;First page&quot;));  document.add(new Paragraph(Document.getVersion()));  document.newPage();  writer.setPageEmpty(false);  document.newPage();  document.add(new Paragraph(&quot;New page&quot;));  document.close();  PdfReader reader = new PdfReader(FILE_DIR + &quot;deletePage.pdf&quot;);  reader.selectPages(&quot;1,3&quot;);  PdfStamper stamp = new PdfStamper(reader, new FileOutputStream(FILE_DIR          + &quot;deletePage2.pdf&quot;));  stamp.close();  reader.close();  </code></pre><h2 id="插入Page"><a href="#插入Page" class="headerlink" title="插入Page"></a>插入Page</h2><pre><code>FileOutputStream out = new FileOutputStream(FILE_DIR + &quot;insertPage.pdf&quot;);  Document document = new Document();  PdfWriter.getInstance(document, out);  document.open();  document.add(new Paragraph(&quot;1 page&quot;));  document.newPage();  document.add(new Paragraph(&quot;2 page&quot;));  document.newPage();  document.add(new Paragraph(&quot;3 page&quot;));  document.close();  PdfReader reader = new PdfReader(FILE_DIR + &quot;insertPage.pdf&quot;);  PdfStamper stamp = new PdfStamper(reader, new FileOutputStream(FILE_DIR          + &quot;insertPage2.pdf&quot;));  stamp.insertPage(2, reader.getPageSize(1));  ColumnText ct = new ColumnText(null);  ct.addElement(new Paragraph(24, new Chunk(&quot;INSERT PAGE&quot;)));  ct.setCanvas(stamp.getOverContent(2));  ct.setSimpleColumn(36, 36, 559, 770);  stamp.close();  reader.close();  </code></pre><h2 id="排序page"><a href="#排序page" class="headerlink" title="排序page"></a>排序page</h2><pre><code>PdfWriter writer = PdfWriter.getInstance(doc, out);  writer.setLinearPageMode();  doc.open();  doc.add(new Paragraph(&quot;1 page&quot;));  doc.newPage();  doc.add(new Paragraph(&quot;2 page&quot;));  doc.newPage();  doc.add(new Paragraph(&quot;3 page&quot;));  doc.newPage();  doc.add(new Paragraph(&quot;4 page&quot;));  doc.newPage();  doc.add(new Paragraph(&quot;5 page&quot;));  int[] order = {4,3,2,1};  writer.reorderPages(order);  </code></pre><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><pre><code>// Code 1  document.add(new Chunk(&quot;Chapter 1&quot;).setLocalDestination(&quot;1&quot;));  document.newPage();  document.add(new Chunk(&quot;Chapter 2&quot;).setLocalDestination(&quot;2&quot;));  document.add(new Paragraph(new Chunk(&quot;Sub 2.1&quot;).setLocalDestination(&quot;2.1&quot;)));  document.add(new Paragraph(new Chunk(&quot;Sub 2.2&quot;).setLocalDestination(&quot;2.2&quot;)));  document.newPage();  document.add(new Chunk(&quot;Chapter 3&quot;).setLocalDestination(&quot;3&quot;));  // Code 2  PdfContentByte cb = writer.getDirectContent();  PdfOutline root = cb.getRootOutline();  // Code 3  @SuppressWarnings(&quot;unused&quot;)  PdfOutline oline1 = new PdfOutline(root, PdfAction.gotoLocalPage(&quot;1&quot;, false), &quot;Chapter 1&quot;);  PdfOutline oline2 = new PdfOutline(root, PdfAction.gotoLocalPage(&quot;2&quot;, false), &quot;Chapter 2&quot;);  oline2.setOpen(false);  @SuppressWarnings(&quot;unused&quot;)  PdfOutline oline2_1 = new PdfOutline(oline2, PdfAction.gotoLocalPage(&quot;2.1&quot;, false), &quot;Sub 2.1&quot;);  @SuppressWarnings(&quot;unused&quot;)  PdfOutline oline2_2 = new PdfOutline(oline2, PdfAction.gotoLocalPage(&quot;2.2&quot;, false), &quot;Sub 2.2&quot;);  @SuppressWarnings(&quot;unused&quot;)  PdfOutline oline3 = new PdfOutline(root, PdfAction.gotoLocalPage(&quot;3&quot;, false), &quot;Chapter 3&quot;);  </code></pre><h2 id="Header-Footer"><a href="#Header-Footer" class="headerlink" title="Header, Footer"></a>Header, Footer</h2><pre><code>PdfWriter writer = PdfWriter.getInstance(doc, new FileOutputStream(FILE_DIR + &quot;setHeaderFooter.pdf&quot;));  writer.setPageEvent(new PdfPageEventHelper() {      public void onEndPage(PdfWriter writer, Document document) {          PdfContentByte cb = writer.getDirectContent();          cb.saveState();          cb.beginText();          BaseFont bf = null;          try {              bf = BaseFont.createFont(BaseFont.HELVETICA, BaseFont.WINANSI, BaseFont.EMBEDDED);          } catch (Exception e) {              e.printStackTrace();          }          cb.setFontAndSize(bf, 10);          //Header          float x = document.top(-20);          //左          cb.showTextAligned(PdfContentByte.ALIGN_LEFT,                             &quot;H-Left&quot;,                             document.left(), x, 0);          //中          cb.showTextAligned(PdfContentByte.ALIGN_CENTER,                              writer.getPageNumber()+ &quot; page&quot;,                             (document.right() + document.left())/2,                             x, 0);          //右          cb.showTextAligned(PdfContentByte.ALIGN_RIGHT,                             &quot;H-Right&quot;,                             document.right(), x, 0);          //Footer          float y = document.bottom(-20);          //左          cb.showTextAligned(PdfContentByte.ALIGN_LEFT,                             &quot;F-Left&quot;,                             document.left(), y, 0);          //中          cb.showTextAligned(PdfContentByte.ALIGN_CENTER,                              writer.getPageNumber()+&quot; page&quot;,                             (document.right() + document.left())/2,                             y, 0);          //右          cb.showTextAligned(PdfContentByte.ALIGN_RIGHT,                             &quot;F-Right&quot;,                             document.right(), y, 0);          cb.endText();          cb.restoreState();      }  });  doc.open();  doc.add(new Paragraph(&quot;1 page&quot;));          doc.newPage();  doc.add(new Paragraph(&quot;2 page&quot;));          doc.newPage();  doc.add(new Paragraph(&quot;3 page&quot;));          doc.newPage();  doc.add(new Paragraph(&quot;4 page&quot;));  </code></pre><h2 id="左右文字"><a href="#左右文字" class="headerlink" title="左右文字"></a>左右文字</h2><pre><code>PdfWriter writer = PdfWriter.getInstance(document, out);  document.open();  PdfContentByte canvas = writer.getDirectContent();  Phrase phrase1 = new Phrase(&quot;This is a test!left&quot;);  Phrase phrase2 = new Phrase(&quot;This is a test!right&quot;);  Phrase phrase3 = new Phrase(&quot;This is a test!center&quot;);  ColumnText.showTextAligned(canvas, Element.ALIGN_LEFT, phrase1, 10, 500, 0);  ColumnText.showTextAligned(canvas, Element.ALIGN_RIGHT, phrase2, 10, 536, 0);  ColumnText.showTextAligned(canvas, Element.ALIGN_CENTER, phrase3, 10, 572, 0);  </code></pre><h2 id="幻灯片放映"><a href="#幻灯片放映" class="headerlink" title="幻灯片放映"></a>幻灯片放映</h2><pre><code>PdfWriter writer = PdfWriter.getInstance(doc, out);  writer.setPdfVersion(PdfWriter.VERSION_1_5);  writer.setViewerPreferences(PdfWriter.PageModeFullScreen);//全屏  writer.setPageEvent(new PdfPageEventHelper() {      public void onStartPage(PdfWriter writer, Document document) {          writer.setTransition(new PdfTransition(PdfTransition.DISSOLVE, 3));          writer.setDuration(5);//间隔时间      }  });  doc.open();  doc.add(new Paragraph(&quot;1 page&quot;));  doc.newPage();  doc.add(new Paragraph(&quot;2 page&quot;));  doc.newPage();  doc.add(new Paragraph(&quot;3 page&quot;));  doc.newPage();  doc.add(new Paragraph(&quot;4 page&quot;));  doc.newPage();  doc.add(new Paragraph(&quot;5 page&quot;));  </code></pre><h2 id="压缩PDF到Zip"><a href="#压缩PDF到Zip" class="headerlink" title="压缩PDF到Zip"></a>压缩PDF到Zip</h2><pre><code>ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(FILE_DIR + &quot;zipPDF.zip&quot;));  for (int i = 1; i &lt;= 3; i++) {      ZipEntry entry = new ZipEntry(&quot;hello_&quot; + i + &quot;.pdf&quot;);      zip.putNextEntry(entry);      Document document = new Document();      PdfWriter writer = PdfWriter.getInstance(document, zip);      writer.setCloseStream(false);      document.open();      document.add(new Paragraph(&quot;Hello &quot; + i));      document.close();      zip.closeEntry();  }  zip.close();  </code></pre><h2 id="分割PDF"><a href="#分割PDF" class="headerlink" title="分割PDF"></a>分割PDF</h2><pre><code>FileOutputStream out = new FileOutputStream(FILE_DIR + &quot;splitPDF.pdf&quot;);  Document document = new Document();  PdfWriter.getInstance(document, out);  document.open();  document.add(new Paragraph(&quot;1 page&quot;));  document.newPage();  document.add(new Paragraph(&quot;2 page&quot;));  document.newPage();  document.add(new Paragraph(&quot;3 page&quot;));  document.newPage();  document.add(new Paragraph(&quot;4 page&quot;));  document.close();  PdfReader reader = new PdfReader(FILE_DIR + &quot;splitPDF.pdf&quot;);  Document dd = new Document();  PdfWriter writer = PdfWriter.getInstance(dd, new FileOutputStream(FILE_DIR + &quot;splitPDF1.pdf&quot;));  dd.open();  PdfContentByte cb = writer.getDirectContent();  dd.newPage();  cb.addTemplate(writer.getImportedPage(reader, 1), 0, 0);  dd.newPage();  cb.addTemplate(writer.getImportedPage(reader, 2), 0, 0);  dd.close();  writer.close();  Document dd2 = new Document();  PdfWriter writer2 = PdfWriter.getInstance(dd2, new FileOutputStream(FILE_DIR + &quot;splitPDF2.pdf&quot;));  dd2.open();  PdfContentByte cb2 = writer2.getDirectContent();  dd2.newPage();  cb2.addTemplate(writer2.getImportedPage(reader, 3), 0, 0);  dd2.newPage();  cb2.addTemplate(writer2.getImportedPage(reader, 4), 0, 0);  dd2.close();  writer2.close();  </code></pre><h2 id="合并PDF"><a href="#合并PDF" class="headerlink" title="合并PDF"></a>合并PDF</h2><pre><code>PdfReader reader1 = new PdfReader(FILE_DIR + &quot;splitPDF1.pdf&quot;);  PdfReader reader2 = new PdfReader(FILE_DIR + &quot;splitPDF2.pdf&quot;);  FileOutputStream out = new FileOutputStream(FILE_DIR + &quot;mergePDF.pdf&quot;);  Document document = new Document();  PdfWriter writer = PdfWriter.getInstance(document, out);  document.open();  PdfContentByte cb = writer.getDirectContent();  int totalPages = 0;  totalPages += reader1.getNumberOfPages();  totalPages += reader2.getNumberOfPages();  java.util.List&lt;PdfReader&gt; readers = new ArrayList&lt;PdfReader&gt;();  readers.add(reader1);  readers.add(reader2);  int pageOfCurrentReaderPDF = 0;  Iterator&lt;PdfReader&gt; iteratorPDFReader = readers.iterator();  // Loop through the PDF files and add to the output.  while (iteratorPDFReader.hasNext()) {      PdfReader pdfReader = iteratorPDFReader.next();      // Create a new page in the target for each source page.      while (pageOfCurrentReaderPDF &lt; pdfReader.getNumberOfPages()) {          document.newPage();          pageOfCurrentReaderPDF++;          PdfImportedPage page = writer.getImportedPage(pdfReader, pageOfCurrentReaderPDF);          cb.addTemplate(page, 0, 0);      }      pageOfCurrentReaderPDF = 0;  }  out.flush();  document.close();  out.close();  </code></pre><h2 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h2><pre><code>PdfWriter writer = PdfWriter.getInstance(doc, out);  writer.setLinearPageMode();  doc.open();  doc.add(new Paragraph(&quot;1 page&quot;));  doc.add(new Annotation(&quot;Title&quot;, &quot;This is a annotation!&quot;));  doc.newPage();  doc.add(new Paragraph(&quot;2 page&quot;));  Chunk chunk = new Chunk(&quot;\u00a0&quot;);  chunk.setAnnotation(PdfAnnotation.createText(writer, null, &quot;Title&quot;, &quot;This is a another annotation!&quot;, false, &quot;Comment&quot;));  doc.add(chunk);  //添加附件  doc.newPage();  doc.add(new Paragraph(&quot;3 page&quot;));  Chunk chunk2 = new Chunk(&quot;\u00a0\u00a0&quot;);  PdfAnnotation annotation = PdfAnnotation.createFileAttachment(          writer, null, &quot;Title&quot;, null,          &quot;resource/test2.jpg&quot;,          &quot;img.jpg&quot;);  annotation.put(PdfName.NAME,          new PdfString(&quot;Paperclip&quot;));  chunk2.setAnnotation(annotation);  doc.add(chunk2);  </code></pre><h2 id="插入一个Table"><a href="#插入一个Table" class="headerlink" title="插入一个Table"></a>插入一个Table</h2><pre><code>PdfPTable table = new PdfPTable(3);  PdfPCell cell;  cell = new PdfPCell(new Phrase(&quot;Cell with colspan 3&quot;));  cell.setColspan(3);  table.addCell(cell);  cell = new PdfPCell(new Phrase(&quot;Cell with rowspan 2&quot;));  cell.setRowspan(2);  table.addCell(cell);  table.addCell(&quot;row 1; cell 1&quot;);  table.addCell(&quot;row 1; cell 2&quot;);  table.addCell(&quot;row 2; cell 1&quot;);  table.addCell(&quot;row 2; cell 2&quot;);  document.add(table);  </code></pre><h2 id="表格嵌套"><a href="#表格嵌套" class="headerlink" title="表格嵌套"></a>表格嵌套</h2><pre><code>PdfPTable table = new PdfPTable(4);  //1行2列  PdfPTable nested1 = new PdfPTable(2);  nested1.addCell(&quot;1.1&quot;);  nested1.addCell(&quot;1.2&quot;);  //2行1列  PdfPTable nested2 = new PdfPTable(1);  nested2.addCell(&quot;2.1&quot;);  nested2.addCell(&quot;2.2&quot;);  //将表格插入到指定位置  for (int k = 0; k &lt; 24; ++k) {      if (k == 1) {          table.addCell(nested1);      } else if (k == 20) {          table.addCell(nested2);      } else {          table.addCell(&quot;cell &quot; + k);      }  }  document.add(table);  </code></pre><h2 id="设置表格宽度"><a href="#设置表格宽度" class="headerlink" title="设置表格宽度"></a>设置表格宽度</h2><pre><code>PdfPTable table = new PdfPTable(3);  PdfPCell cell;  cell = new PdfPCell(new Phrase(&quot;Cell with colspan 3&quot;));  cell.setColspan(3);  table.addCell(cell);  cell = new PdfPCell(new Phrase(&quot;Cell with rowspan 2&quot;));  cell.setRowspan(2);  table.addCell(cell);  table.addCell(&quot;row 1; cell 1&quot;);  table.addCell(&quot;row 1; cell 2&quot;);  table.addCell(&quot;row 2; cell 1&quot;);  table.addCell(&quot;row 2; cell 2&quot;);  //100%  table.setWidthPercentage(100);  document.add(table);          document.add(new Paragraph(&quot;\n\n&quot;));  //宽度50% 居左  table.setHorizontalAlignment(Element.ALIGN_LEFT);  document.add(table);  document.add(new Paragraph(&quot;\n\n&quot;));  //宽度50% 居中  table.setHorizontalAlignment(Element.ALIGN_CENTER);  document.add(table);  document.add(new Paragraph(&quot;\n\n&quot;));  //宽度50% 居右  table.setWidthPercentage(50);  table.setHorizontalAlignment(Element.ALIGN_RIGHT);  document.add(table);  document.add(new Paragraph(&quot;\n\n&quot;));  //固定宽度  table.setTotalWidth(300);  table.setLockedWidth(true);  document.add(table);  </code></pre><h2 id="设置表格前后间隔"><a href="#设置表格前后间隔" class="headerlink" title="设置表格前后间隔"></a>设置表格前后间隔</h2><pre><code>PdfPTable table = new PdfPTable(3);  PdfPCell cell = new PdfPCell(new Paragraph(&quot;合并3个单元格&quot;,fontZH));  cell.setColspan(3);  table.addCell(cell);  table.addCell(&quot;1.1&quot;);  table.addCell(&quot;2.1&quot;);  table.addCell(&quot;3.1&quot;);  table.addCell(&quot;1.2&quot;);  table.addCell(&quot;2.2&quot;);  table.addCell(&quot;3.2&quot;);  cell = new PdfPCell(new Paragraph(&quot;红色边框&quot;,fontZH));  cell.setBorderColor(new BaseColor(255, 0, 0));  table.addCell(cell);  cell = new PdfPCell(new Paragraph(&quot;合并单2个元格&quot;,fontZH));  cell.setColspan(2);  cell.setBackgroundColor(new BaseColor(0xC0, 0xC0, 0xC0));  table.addCell(cell);  table.setWidthPercentage(50);  document.add(new Paragraph(&quot;追加2个表格&quot;,fontZH));  document.add(table);  document.add(table);  document.newPage();  document.add(new Paragraph(&quot;使用&apos;SpacingBefore&apos;和&apos;setSpacingAfter&apos;&quot;,fontZH));  table.setSpacingBefore(15f);  document.add(table);  document.add(table);  document.add(new Paragraph(&quot;这里没有间隔&quot;,fontZH));  table.setSpacingAfter(15f);  </code></pre><h2 id="设置单元格宽度"><a href="#设置单元格宽度" class="headerlink" title="设置单元格宽度"></a>设置单元格宽度</h2><pre><code>//按比例设置单元格宽度  float[] widths = {0.1f, 0.1f, 0.05f, 0.75f};  PdfPTable table = new PdfPTable(widths);  table.addCell(&quot;10%&quot;);  table.addCell(&quot;10%&quot;);  table.addCell(&quot;5%&quot;);  table.addCell(&quot;75%&quot;);  table.addCell(&quot;aa&quot;);  table.addCell(&quot;aa&quot;);  table.addCell(&quot;a&quot;);  table.addCell(&quot;aaaaaaaaaaaaaaa&quot;);  table.addCell(&quot;bb&quot;);  table.addCell(&quot;bb&quot;);  table.addCell(&quot;b&quot;);  table.addCell(&quot;bbbbbbbbbbbbbbb&quot;);  table.addCell(&quot;cc&quot;);  table.addCell(&quot;cc&quot;);  table.addCell(&quot;c&quot;);  table.addCell(&quot;ccccccccccccccc&quot;);  document.add(table);  document.add(new Paragraph(&quot;\n\n&quot;));  //调整比例  widths[0] = 20f;  widths[1] = 20f;  widths[2] = 10f;  widths[3] = 50f;  table.setWidths(widths);  document.add(table);  //按绝对值设置单元格宽度  widths[0] = 40f;  widths[1] = 40f;  widths[2] = 20f;  widths[3] = 300f;  Rectangle r = new Rectangle(PageSize.A4.getRight(72), PageSize.A4.getTop(72));  table.setWidthPercentage(widths, r);  document.add(new Paragraph(&quot;\n\n&quot;));  document.add(table);  </code></pre><h2 id="设置单元格高度"><a href="#设置单元格高度" class="headerlink" title="设置单元格高度"></a>设置单元格高度</h2><pre><code>PdfPTable table = new PdfPTable(2);  PdfPCell cell;  //折行  table.addCell(new PdfPCell(new Paragraph(&quot;折行&quot;, fontZH)));  cell = new PdfPCell(new Paragraph(&quot;blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah&quot;));  cell.setNoWrap(false);  table.addCell(cell);  //不折行  table.addCell(new PdfPCell(new Paragraph(&quot;不折行&quot;, fontZH)));  cell.setNoWrap(true);  table.addCell(cell);  //设置高度  table.addCell(new PdfPCell(new Paragraph(&quot;任意高度&quot;,fontZH)));  cell = new PdfPCell(new Paragraph(&quot;1. blah blah\n2. blah blah blah\n3. blah blah\n4. blah blah blah\n5. blah blah\n6. blah blah blah\n7. blah blah\n8. blah blah blah&quot;));  table.addCell(cell);  //固定高度  table.addCell(new PdfPCell(new Paragraph(&quot;固定高度&quot;,fontZH)));  cell.setFixedHeight(50f);  table.addCell(cell);  //最小高度  table.addCell(new PdfPCell(new Paragraph(&quot;最小高度&quot;,fontZH)));  cell = new PdfPCell(new Paragraph(&quot;最小高度：50&quot;,fontZH));  cell.setMinimumHeight(50f);  table.addCell(cell);  //最后一行拉长到page底部  table.setExtendLastRow(true);  table.addCell(new PdfPCell(new Paragraph(&quot;拉长最后一行&quot;,fontZH)));  cell = new PdfPCell(new Paragraph(&quot;最后一行拉长到page底部&quot;,fontZH));  table.addCell(cell);  document.add(table);  </code></pre><h2 id="设置单元格颜色"><a href="#设置单元格颜色" class="headerlink" title="设置单元格颜色"></a>设置单元格颜色</h2><pre><code>PdfPTable table = new PdfPTable(4);  PdfPCell cell;  cell = new PdfPCell(new Paragraph(&quot;颜色测试&quot;,fontZH));  table.addCell(cell);  //红色背景，无边框  cell = new PdfPCell(new Paragraph(&quot;红色背景，无边框&quot;,fontZH));  cell.setBorder(Rectangle.NO_BORDER);  cell.setBackgroundColor(BaseColor.RED);  table.addCell(cell);  //绿色背景，下边框  cell = new PdfPCell(new Paragraph(&quot;绿色背景，下边框&quot;,fontZH));  cell.setBorder(Rectangle.BOTTOM);  cell.setBorderColorBottom(BaseColor.MAGENTA);  cell.setBorderWidthBottom(5f);  cell.setBackgroundColor(BaseColor.GREEN);  table.addCell(cell);  //蓝色背景，上边框  cell = new PdfPCell(new Paragraph(&quot;蓝色背景，上边框&quot;,fontZH));  cell.setBorder(Rectangle.TOP);  cell.setUseBorderPadding(true);  cell.setBorderWidthTop(5f);  cell.setBorderColorTop(BaseColor.CYAN);  cell.setBackgroundColor(BaseColor.BLUE);  table.addCell(cell);  cell = new PdfPCell(new Paragraph(&quot;背景灰色度&quot;,fontZH));  table.addCell(cell);  cell = new PdfPCell(new Paragraph(&quot;0.25&quot;));  cell.setBorder(Rectangle.NO_BORDER);  cell.setGrayFill(0.25f);  table.addCell(cell);  cell = new PdfPCell(new Paragraph(&quot;0.5&quot;));  cell.setBorder(Rectangle.NO_BORDER);  cell.setGrayFill(0.5f);  table.addCell(cell);  cell = new PdfPCell(new Paragraph(&quot;0.75&quot;));  cell.setBorder(Rectangle.NO_BORDER);  cell.setGrayFill(0.75f);  table.addCell(cell);  document.add(table);  </code></pre><h2 id="插入图像"><a href="#插入图像" class="headerlink" title="插入图像"></a>插入图像</h2><pre><code>Image image = Image.getInstance(&quot;resource/test2.jpg&quot;);  float[] widths = { 1f, 4f };  PdfPTable table = new PdfPTable(widths);  //插入图片  table.addCell(new PdfPCell(new Paragraph(&quot;图片测试&quot;, fontZH)));  table.addCell(image);  //调整图片大小  table.addCell(&quot;This two&quot;);  table.addCell(new PdfPCell(image, true));  //不调整  table.addCell(&quot;This three&quot;);  table.addCell(new PdfPCell(image, false));  document.add(table);  </code></pre><h2 id="设置表头"><a href="#设置表头" class="headerlink" title="设置表头"></a>设置表头</h2><pre><code>String[] bogusData = { &quot;M0065920&quot;, &quot;SL&quot;, &quot;FR86000P&quot;, &quot;PCGOLD&quot;,          &quot;119000&quot;, &quot;96 06&quot;, &quot;2001-08-13&quot;, &quot;4350&quot;, &quot;6011648299&quot;,          &quot;FLFLMTGP&quot;, &quot;153&quot;, &quot;119000.00&quot; };  int NumColumns = 12;  // 12  PdfPTable datatable = new PdfPTable(NumColumns);  int headerwidths[] = { 9, 4, 8, 10, 8, 11, 9, 7, 9, 10, 4, 10 }; // percentage  datatable.setWidths(headerwidths);  datatable.setWidthPercentage(100);  datatable.getDefaultCell().setPadding(3);  datatable.getDefaultCell().setBorderWidth(2);  datatable.getDefaultCell().setHorizontalAlignment(Element.ALIGN_CENTER);  datatable.addCell(&quot;Clock #&quot;);  datatable.addCell(&quot;Trans Type&quot;);  datatable.addCell(&quot;Cusip&quot;);  datatable.addCell(&quot;Long Name&quot;);  datatable.addCell(&quot;Quantity&quot;);  datatable.addCell(&quot;Fraction Price&quot;);  datatable.addCell(&quot;Settle Date&quot;);  datatable.addCell(&quot;Portfolio&quot;);  datatable.addCell(&quot;ADP Number&quot;);  datatable.addCell(&quot;Account ID&quot;);  datatable.addCell(&quot;Reg Rep ID&quot;);  datatable.addCell(&quot;Amt To Go &quot;);  datatable.setHeaderRows(1);  //边框  datatable.getDefaultCell().setBorderWidth(1);  //背景色  for (int i = 1; i &lt; 1000; i++) {      for (int x = 0; x &lt; NumColumns; x++) {          datatable.addCell(bogusData[x]);      }  }  document.add(datatable);  </code></pre><h2 id="分割表格"><a href="#分割表格" class="headerlink" title="分割表格"></a>分割表格</h2><pre><code>//横向分割  PdfContentByte cb = writer.getDirectContent();  PdfPTable table = new PdfPTable(10);  for (int k = 1; k &lt;= 100; ++k) {      table.addCell(&quot;The number &quot; + k);  }  table.setTotalWidth(400);  table.writeSelectedRows(0, 5, 0, -1, 5, 700, cb);  table.writeSelectedRows(5, -1, 0, -1, 210, 700, cb);  </code></pre><h2 id="设置单元格留白"><a href="#设置单元格留白" class="headerlink" title="设置单元格留白"></a>设置单元格留白</h2><pre><code>PdfPTable table = new PdfPTable(2);  PdfPCell cell;  Paragraph p = new Paragraph(&quot;Quick brown fox jumps over the lazy dog. Quick brown fox jumps over the lazy dog.&quot;);  table.addCell(new PdfPCell(new Paragraph(&quot;默认&quot;,fontZH)));  table.addCell(p);  table.addCell(new PdfPCell(new Paragraph(&quot;Padding：10&quot;,fontZH)));  cell = new PdfPCell(p);  cell.setPadding(10f);  table.addCell(cell);  table.addCell(new PdfPCell(new Paragraph(&quot;Padding：0&quot;,fontZH)));  cell = new PdfPCell(p);  cell.setPadding(0f);  table.addCell(cell);  table.addCell(new PdfPCell(new Paragraph(&quot;上Padding：0 左Padding：20&quot;,fontZH)));  cell = new PdfPCell(p);  cell.setPaddingTop(0f);  cell.setPaddingLeft(20f);  table.addCell(cell);  document.add(table);  document.newPage();  table = new PdfPTable(2);  table.addCell(new PdfPCell(new Paragraph(&quot;没有Leading&quot;,fontZH)));  table.getDefaultCell().setLeading(0f, 0f);  table.addCell(&quot;blah blah\nblah blah blah\nblah blah\nblah blah blah\nblah blah\nblah blah blah\nblah blah\nblah blah blah\n&quot;);  table.getDefaultCell().setLeading(14f, 0f);  table.addCell(new PdfPCell(new Paragraph(&quot;固定Leading：14pt&quot;,fontZH)));  table.addCell(&quot;blah blah\nblah blah blah\nblah blah\nblah blah blah\nblah blah\nblah blah blah\nblah blah\nblah blah blah\n&quot;);  table.addCell(new PdfPCell(new Paragraph(&quot;相对于字体&quot;,fontZH)));  table.getDefaultCell().setLeading(0f, 1.0f);  table.addCell(&quot;blah blah\nblah blah blah\nblah blah\nblah blah blah\nblah blah\nblah blah blah\nblah blah\nblah blah blah\n&quot;);  document.add(table);  设置单元格边框 //没有边框  PdfPTable table1 = new PdfPTable(3);    table1.getDefaultCell().setBorder(PdfPCell.NO_BORDER);    table1.addCell(new Paragraph(&quot;Cell 1&quot;));   table1.addCell(new Paragraph(&quot;Cell 2&quot;));   table1.addCell(new Paragraph(&quot;Cell 3&quot;));   document.add(table1);  //边框粗细颜色  document.newPage();  Rectangle b1 = new Rectangle(0f, 0f);  b1.setBorderWidthLeft(6f);  b1.setBorderWidthBottom(5f);  b1.setBorderWidthRight(4f);  b1.setBorderWidthTop(2f);  b1.setBorderColorLeft(BaseColor.RED);  b1.setBorderColorBottom(BaseColor.ORANGE);  b1.setBorderColorRight(BaseColor.YELLOW);  b1.setBorderColorTop(BaseColor.GREEN);  PdfPTable table2 = new PdfPTable(1);  PdfPCell cell =  new PdfPCell(new Paragraph(&quot;Cell 1&quot;));  cell.cloneNonPositionParameters(b1);  table2.addCell(cell);  document.add(table2);  </code></pre><h2 id="生成Barcode-QRCode"><a href="#生成Barcode-QRCode" class="headerlink" title="生成Barcode QRCode"></a>生成Barcode QRCode</h2><pre><code>String myString = &quot;http://www.google.com&quot;;  Barcode128 code128 = new Barcode128();  code128.setCode(myString.trim());  code128.setCodeType(Barcode128.CODE128);  Image code128Image = code128.createImageWithBarcode(cb, null, null);  code128Image.setAbsolutePosition(10,700);  code128Image.scalePercent(125);  doc.add(code128Image);  BarcodeQRCode qrcode = new BarcodeQRCode(myString.trim(), 1, 1, null);  Image qrcodeImage = qrcode.getImage();  qrcodeImage.setAbsolutePosition(10,600);  qrcodeImage.scalePercent(200);  doc.add(qrcodeImage);  </code></pre><h2 id="HTML-to-PDF"><a href="#HTML-to-PDF" class="headerlink" title="HTML to PDF"></a>HTML to PDF</h2><pre><code>Document document = new Document(PageSize.LETTER);  PdfWriter.getInstance(document, new FileOutputStream(&quot;c://testpdf1.pdf&quot;));  document.open();  HTMLWorker htmlWorker = new HTMLWorker(document);  htmlWorker.parse(new StringReader(&quot;&lt;h1&gt;This is a test!&lt;/h1&gt;&quot;));  document.close();        </code></pre><h1 id="JFreeReport"><a href="#JFreeReport" class="headerlink" title="JFreeReport"></a>JFreeReport</h1><p>JFreeReport的数据继承自Swing组件的TableModel接口。JFreeReport生成的报表可以分页预览、打印或者保存为多种格式的文件包括pdf、Excel、html等。<br>该项目主页:<a href="http://www.jfree.org/jfreereport/" target="_blank" rel="noopener">http://www.jfree.org/jfreereport/</a></p><h1 id="PJX"><a href="#PJX" class="headerlink" title="PJX"></a>PJX</h1><p>PJX支持读取，组合，处理，和生成PDF文档（注意：PJX需要 J2SE 1.4.0 或更高版本）。<br>该项目主页:<a href="http://www.etymon.com/epub.html" target="_blank" rel="noopener">http://www.etymon.com/epub.html</a></p><h1 id="Apache-FOP"><a href="#Apache-FOP" class="headerlink" title="Apache FOP"></a>Apache FOP</h1><p>FOP是由James Tauber发起的一个开源项目，原先的版本是利用xsl-fo将xml文件转换成pdf文件。但最新的版本它可以将xml文件转换成pdf，mif，pcl，txt等多种格式以及直接输出到打印机，并且支持使用SVG描述图形。<br>该项目主页:<a href="http://xml.apache.org/fop/" target="_blank" rel="noopener">http://xml.apache.org/fop/</a></p><h1 id="gnujpdf"><a href="#gnujpdf" class="headerlink" title="gnujpdf"></a>gnujpdf</h1><p>gnujpdf是一个java类包(gnu.jpdf.*),它提供了一个简单的API来创建与打印PDF文件。遵循LGPL开源协议。<br>该项目主页:<a href="http://gnujpdf.sourceforge.net/" target="_blank" rel="noopener">http://gnujpdf.sourceforge.net/</a></p><h1 id="PDF-Box"><a href="#PDF-Box" class="headerlink" title="PDF Box"></a>PDF Box</h1><p>PDFBox是一个开源的可以操作PDF文档的Java PDF类库。它可以创建一个新PDF文档,操作现有PDF文档并提取文档中的内容。<br>它具有以下特性:<br>1.将一个PDF文档转换输出为一个文本文件。<br>2.可以从文本文件创建一个PDF文档。<br>3.加密/解密PDF文档。<br>4.向已有PDF文档中追加内容。<br>5.可以从PDF文档生成一张图片。<br>6.可以与Jakarta Lucene搜索引擎的整合。<br>该项目主页:<a href="http://www.pdfbox.org/" target="_blank" rel="noopener">http://www.pdfbox.org/</a></p><h1 id="Connla"><a href="#Connla" class="headerlink" title="Connla"></a>Connla</h1><p>Connla是一个Java包用于创建可导成TXT,CSV,HTML,XHTML,XML,PDF和XLS等格式的数据集。<br>该项目主页:<a href="http://connla.sourceforge.net/" target="_blank" rel="noopener">http://connla.sourceforge.net/</a></p><h1 id="PDF-Split-amp-Merge"><a href="#PDF-Split-amp-Merge" class="headerlink" title="PDF Split &amp; Merge"></a>PDF Split &amp; Merge</h1><p>PDF Split&amp;Merge是一款实用基于GPL许可协议发布的PDF文件分割与合并工具。您可以指定页码范围将一个PDF文件分割为若干PDF 文件(支持单页和多页混合)，或将多个PDF文件按指定顺序合并成一个PDF文件。其转换速度非常快。它采用Java Swing开发,运用到的第三方组件包括：iText,jcmdline和JGoodies界面包。<br>该项目主页:<a href="http://pdfsam.sourceforge.net/" target="_blank" rel="noopener">http://pdfsam.sourceforge.net/</a></p><h1 id="PDF-Clown-for-Java"><a href="#PDF-Clown-for-Java" class="headerlink" title="PDF Clown for Java"></a>PDF Clown for Java</h1><p>PDF Clown for Java是一个基于Java1.5用于读，写和操作PDF文档的Java类包。它提供多个抽象层来满足不同的编程风格：从底层(PDF对象模型)到高级(PDF文档结构和内容流)。<br>该项目主页:<a href="http://www.stefanochizzolini.it/en/projects/clown/" target="_blank" rel="noopener">http://www.stefanochizzolini.it/en/projects/clown/</a></p><h1 id="iText-toolbox"><a href="#iText-toolbox" class="headerlink" title="iText toolbox"></a>iText toolbox</h1><p>iText toolbox是一个Java Swing应用程序,其起初是iText类库的一部分。iText toolbox既可以作为一个可执行的Jar，也可作为Java Webstart应用程序运行。对于完成各种类型的PDF相关文件操作，iText toolbox是一个非常有用的工具比如：把一个目录下的所有图片转换成一个PDF文档，合并现有PDF文档等。此外开发人员可以把它当成一个学习iText类库各项功能的工具。<br>该项目主页:<a href="http://itexttoolbox.sourceforge.net/" target="_blank" rel="noopener">http://itexttoolbox.sourceforge.net/</a></p><h1 id="PDFjet"><a href="#PDFjet" class="headerlink" title="PDFjet"></a>PDFjet</h1><p>PDFjet是一个用于动态生成PDF文档的Java类库。支持绘制点、线、方框、圆、贝塞尔曲线(Bezier Curves) 、多边形、星形、复杂路径和形状。支持unicode，文本间距调整，嵌入超链接等。<br>该项目主页:<a href="http://pdfjet.com/os/edition.html" target="_blank" rel="noopener">http://pdfjet.com/os/edition.html</a></p><h1 id="ICEpdf"><a href="#ICEpdf" class="headerlink" title="ICEpdf"></a>ICEpdf</h1><p>ICEpdf是一个开源Java PDF引擎，用于展示/查看PDF文档，转换和抽取PDF文档的内容。可以集成到Java桌面应用程序或Web服务器中使用。<br>该项目主页:<a href="http://www.icepdf.org/" target="_blank" rel="noopener">http://www.icepdf.org/</a></p><h1 id="JSignPdf"><a href="#JSignPdf" class="headerlink" title="JSignPdf"></a>JSignPdf</h1><p>JSignPdf是一个用于为PDF文档添加数字签名的Java应用程序。它既可以单独使用，也可以作为OpenOffice.org的插件使用。支持设置验证级别，PDF加密和设置权限，添加签名图标，批量转换（通过命令行参数控制）。<br>该项目主页:<a href="http://jsignpdf.sourceforge.net/" target="_blank" rel="noopener">http://jsignpdf.sourceforge.net/</a></p><h1 id="PDF-Renderer"><a href="#PDF-Renderer" class="headerlink" title="PDF Renderer"></a>PDF Renderer</h1><p>PDF Renderer是一个采用纯Java实现的PDF阅读器和渲染器。 可以利用它实现在你的应用中查看PDF文件；在导出PDF文件之前进行预览；在服务器端Web应用中将PDF转成PNGs图片；在一个3D场景中查看PDF。<br>该项目主页:<a href="https://pdf-renderer.dev.java.net/" target="_blank" rel="noopener">https://pdf-renderer.dev.java.net/</a></p><p>文章来自 <a href="http://blog.csdn.net/rongbo_j/article/details/50196909" target="_blank" rel="noopener">http://blog.csdn.net/rongbo_j/article/details/50196909</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;iText&quot;&gt;&lt;a href=&quot;#iText&quot; class=&quot;headerlink&quot; title=&quot;iText&quot;&gt;&lt;/a&gt;iText&lt;/h1&gt;&lt;p&gt;iText是一个能够快速产生PDF文件的java类库。iText的java类对于那些要产生包含文本，表格，图形的只读文档是很有用的。它的类库尤其与java Servlet有很好的给合。使用iText与PDF能够使你正确的控制Servlet的输出。&lt;br&gt;该项目主页:&lt;a href=&quot;http://www.lowagie.com/iText/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.lowagie.com/iText/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;iText是著名的开放项目，是用于生成PDF文档的一个java类库。通过iText不仅可以生成PDF或rtf的文档，而且可以将XML、Html文件转化为PDF文件。&lt;/p&gt;
&lt;p&gt;Harness the power of PDF with iText&lt;/p&gt;
&lt;p&gt;Easy PDF generation and manipulation for Java and .NET developers&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="java类库" scheme="http://yoursite.com/tags/java%E7%B1%BB%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JAVA开发常用类库--Excel读写库</title>
    <link href="http://yoursite.com/2018/03/13/java-api03/"/>
    <id>http://yoursite.com/2018/03/13/java-api03/</id>
    <published>2018-03-13T07:39:14.000Z</published>
    <updated>2018-03-13T10:44:46.448Z</updated>
    
    <content type="html"><![CDATA[<p>Excel是我们平时工作中比较常用的用于存储二维表数据的，JAVA也可以直接对Excel进行操作，在这篇博客中将为大家介绍两种操作Excel的方式，分别为：jxl和poi。</p><p>对于两者的区别网上有测试如下：</p><p><img src="/2018/03/13/java-api03/main.png" alt="logo"></p><a id="more"></a><p>在小数据量时jxl快于poi，在大数据量时poi要快于jxl。但差距都不明显。</p><h1 id="jxl"><a href="#jxl" class="headerlink" title="jxl"></a>jxl</h1><p>jxl.jar是通过java操作excel表格的工具类库；</p><p>在开始进行Java读写Excel前，我们需要先下一个jxl的jar包，这个jar包中提供了相关读写Excel的方法，在百度里所搜一下jxl.jar下载就会出现很多下载地址了，这里不再累述。随后我们将jxl.jar放到classpath下或者在工程的buildpath中添加jxl.jar后，便可以开始Java读写Excel的神秘之旅了。</p><p>通过模拟实现创建一个表格，然后模拟添加到表格中数据，实际开发过程中都是通过从数据库导入到表格中的数据:</p><h2 id="写xls-xlsx"><a href="#写xls-xlsx" class="headerlink" title="写xls/xlsx"></a>写xls/xlsx</h2><pre><code>package com.bie;import java.io.File;import java.io.IOException;import jxl.Workbook;import jxl.write.Label;import jxl.write.WritableSheet;import jxl.write.WritableWorkbook;import jxl.write.WriteException;import jxl.write.biff.RowsExceededException;/**  * @author BieHongLi  * @version 创建时间：2017年3月3日 下午4:03:18  * 创建excel表格 */public class CreateExcel {    public static void main(String[] args)             throws IOException, RowsExceededException, WriteException {        //1:创建excel文件        File file=new File(&quot;test.xls&quot;);        file.createNewFile();        //2:创建工作簿        WritableWorkbook workbook=Workbook.createWorkbook(file);        //3:创建sheet,设置第二三四..个sheet，依次类推即可        WritableSheet sheet=workbook.createSheet(&quot;用户管理&quot;, 0);        //4：设置titles        String[] titles={&quot;编号&quot;,&quot;账号&quot;,&quot;密码&quot;};        //5:单元格        Label label=null;        //6:给第一行设置列名        for(int i=0;i&lt;titles.length;i++){            //x,y,第一行的列名            label=new Label(i,0,titles[i]);            //7：添加单元格            sheet.addCell(label);        }        //8：模拟数据库导入数据        for(int i=1;i&lt;10;i++){            //添加编号，第二行第一列            label=new Label(0,i,i+&quot;&quot;);            sheet.addCell(label);            //添加账号            label=new Label(1,i,&quot;10010&quot;+i);            sheet.addCell(label);            //添加密码            label=new Label(2,i,&quot;123456&quot;);            sheet.addCell(label);        }        //写入数据，一定记得写入数据，不然你都开始怀疑世界了，excel里面啥都没有        workbook.write();        //最后一步，关闭工作簿        workbook.close();    }}</code></pre><p>读取excel表格里面的数据，案例如下所示:</p><h2 id="读xls-xlsx"><a href="#读xls-xlsx" class="headerlink" title="读xls/xlsx"></a>读xls/xlsx</h2><pre><code>package com.bie;import java.io.File;import jxl.Cell;import jxl.Sheet;import jxl.Workbook;/**  * @author BieHongLi  * @version 创建时间：2017年3月3日 下午5:28:53  * 读取excel的表格的数据 */public class ReadExcel {    public static void main(String[] args) throws Exception{        //1:创建workbook        Workbook workbook=Workbook.getWorkbook(new File(&quot;test.xls&quot;));         //2:获取第一个工作表sheet        Sheet sheet=workbook.getSheet(0);        //3:获取数据        System.out.println(&quot;行：&quot;+sheet.getRows());        System.out.println(&quot;列：&quot;+sheet.getColumns());        for(int i=0;i&lt;sheet.getRows();i++){            for(int j=0;j&lt;sheet.getColumns();j++){                Cell cell=sheet.getCell(j,i);                System.out.print(cell.getContents()+&quot; &quot;);            }            System.out.println();        }        //最后一步：关闭资源        workbook.close();    }}</code></pre><h1 id="poi"><a href="#poi" class="headerlink" title="poi"></a>poi</h1><p>工作中经常需要对Excel进行读写操作，java操作excel文件比较流行的是apache poi包，excel分为xls（2003）和xlsx（2007）两种格式，操作这两种格式的excel需要不同的poi包。</p><p>注意别弄混</p><h2 id="xls格式"><a href="#xls格式" class="headerlink" title="xls格式"></a>xls格式</h2><pre><code>&lt;dependency&gt;     &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;     &lt;artifactId&gt;poi&lt;/artifactId&gt;     &lt;version&gt;3.11-beta1&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="xlsx格式"><a href="#xlsx格式" class="headerlink" title="xlsx格式"></a>xlsx格式</h2><pre><code>&lt;dependency&gt;      &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;      &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;      &lt;version&gt;3.11-beta1&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="读xls"><a href="#读xls" class="headerlink" title="读xls"></a>读xls</h2><pre><code>File file = new File(&quot;src/test/resources/test.xls&quot;);POIFSFileSystem poifsFileSystem = new POIFSFileSystem(new FileInputStream(file));HSSFWorkbook hssfWorkbook =  new HSSFWorkbook(poifsFileSystem);HSSFSheet hssfSheet = hssfWorkbook.getSheetAt(0);int rowstart = hssfSheet.getFirstRowNum();int rowEnd = hssfSheet.getLastRowNum();for(int i=rowstart;i&lt;=rowEnd;i++){    HSSFRow row = hssfSheet.getRow(i);    if(null == row) continue;    int cellStart = row.getFirstCellNum();    int cellEnd = row.getLastCellNum();    for(int k=cellStart;k&lt;=cellEnd;k++)    {        HSSFCell cell = row.getCell(k);        if(null==cell) continue;        System.out.print(&quot;&quot; + k + &quot;  &quot;);        //System.out.print(&quot;type:&quot;+cell.getCellType());        switch (cell.getCellType())        {            case HSSFCell.CELL_TYPE_NUMERIC: // 数字                            System.out.print(cell.getNumericCellValue()                        + &quot;   &quot;);                break;            case HSSFCell.CELL_TYPE_STRING: // 字符串                System.out.print(cell.getStringCellValue()                        + &quot;   &quot;);                break;            case HSSFCell.CELL_TYPE_BOOLEAN: // Boolean                System.out.println(cell.getBooleanCellValue()                        + &quot;   &quot;);                break;            case HSSFCell.CELL_TYPE_FORMULA: // 公式                System.out.print(cell.getCellFormula() + &quot;   &quot;);                break;            case HSSFCell.CELL_TYPE_BLANK: // 空值                System.out.println(&quot; &quot;);                break;            case HSSFCell.CELL_TYPE_ERROR: // 故障                System.out.println(&quot; &quot;);                break;            default:                System.out.print(&quot;未知类型   &quot;);                break;        }    }    System.out.print(&quot;\n&quot;);}</code></pre><h2 id="读xlsx"><a href="#读xlsx" class="headerlink" title="读xlsx"></a>读xlsx</h2><pre><code>File file = new File(&quot;src/test/resources/test.xlsx&quot;);XSSFWorkbook xssfWorkbook = new XSSFWorkbook(file);XSSFSheet xssfSheet = xssfWorkbook.getSheetAt(0);int rowstart = xssfSheet.getFirstRowNum();int rowEnd = xssfSheet.getLastRowNum();for(int i=rowstart;i&lt;=rowEnd;i++){    XSSFRow row = xssfSheet.getRow(i);    if(null == row) continue;    int cellStart = row.getFirstCellNum();    int cellEnd = row.getLastCellNum();    for(int k=cellStart;k&lt;=cellEnd;k++)    {        XSSFCell cell = row.getCell(k);        if(null==cell) continue;        switch (cell.getCellType())        {            case HSSFCell.CELL_TYPE_NUMERIC: // 数字                System.out.print(cell.getNumericCellValue()                        + &quot;   &quot;);                break;            case HSSFCell.CELL_TYPE_STRING: // 字符串                System.out.print(cell.getStringCellValue()                        + &quot;   &quot;);                break;            case HSSFCell.CELL_TYPE_BOOLEAN: // Boolean                System.out.println(cell.getBooleanCellValue()                        + &quot;   &quot;);                break;            case HSSFCell.CELL_TYPE_FORMULA: // 公式                System.out.print(cell.getCellFormula() + &quot;   &quot;);                break;            case HSSFCell.CELL_TYPE_BLANK: // 空值                System.out.println(&quot; &quot;);                break;            case HSSFCell.CELL_TYPE_ERROR: // 故障                System.out.println(&quot; &quot;);                break;            default:                System.out.print(&quot;未知类型   &quot;);                break;        }    }    System.out.print(&quot;\n&quot;);}</code></pre><h2 id="写xls"><a href="#写xls" class="headerlink" title="写xls"></a>写xls</h2><pre><code>HSSFWorkbook workbook = null;workbook = new HSSFWorkbook();//获取参数个数作为excel列数int columeCount = 6;//获取List size作为excel行数int rowCount = 20;HSSFSheet sheet = workbook.createSheet(&quot;sheet name&quot;);//创建第一栏HSSFRow headRow = sheet.createRow(0);String[] titleArray = {&quot;id&quot;, &quot;name&quot;, &quot;age&quot;, &quot;email&quot;, &quot;address&quot;, &quot;phone&quot;};for(int m=0;m&lt;=columeCount-1;m++){    HSSFCell cell = headRow.createCell(m);    cell.setCellType(HSSFCell.CELL_TYPE_STRING);    sheet.setColumnWidth(m, 6000);    HSSFCellStyle style = workbook.createCellStyle();    HSSFFont font = workbook.createFont();    font.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD);    short color = HSSFColor.RED.index;    font.setColor(color);    style.setFont(font);    //填写数据    cell.setCellStyle(style);    cell.setCellValue(titleArray[m]);}int index = 0;//写入数据for(RowEntity entity : pRowEntityList){    //logger.info(&quot;写入一行&quot;);    HSSFRow row = sheet.createRow(index+1);    for(int n=0;n&lt;=columeCount-1;n++)        row.createCell(n);    row.getCell(0).setCellValue(entity.getId());    row.getCell(1).setCellValue(entity.getName());    row.getCell(2).setCellValue(entity.getAge());    row.getCell(3).setCellValue(entity.getEmail());    row.getCell(4).setCellValue(entity.getAddress());    row.getCell(5).setCellValue(entity.getPhone());    index++;}//写到磁盘上try {    FileOutputStream fileOutputStream = new FileOutputStream(new File(path));    workbook.write(fileOutputStream);    fileOutputStream.close();} catch (FileNotFoundException e) {    e.printStackTrace();} catch (IOException e) {    e.printStackTrace();}</code></pre><h2 id="写xlsx"><a href="#写xlsx" class="headerlink" title="写xlsx"></a>写xlsx</h2><p>和写xls类似，使用2007对应的对象即可。</p><p>参考代码：</p><blockquote><p><a href="http://blog.csdn.net/Augus6/article/details/51463478" target="_blank" rel="noopener">http://blog.csdn.net/Augus6/article/details/51463478</a><br><a href="https://www.cnblogs.com/wangyang108/p/6030420.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangyang108/p/6030420.html</a><br><a href="http://blog.csdn.net/a214919447/article/details/54601237" target="_blank" rel="noopener">http://blog.csdn.net/a214919447/article/details/54601237</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Excel是我们平时工作中比较常用的用于存储二维表数据的，JAVA也可以直接对Excel进行操作，在这篇博客中将为大家介绍两种操作Excel的方式，分别为：jxl和poi。&lt;/p&gt;
&lt;p&gt;对于两者的区别网上有测试如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/03/13/java-api03/main.png&quot; alt=&quot;logo&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="java类库" scheme="http://yoursite.com/tags/java%E7%B1%BB%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JAVA开发常用类库--单元测试库</title>
    <link href="http://yoursite.com/2018/03/13/java-api02/"/>
    <id>http://yoursite.com/2018/03/13/java-api02/</id>
    <published>2018-03-13T05:14:36.000Z</published>
    <updated>2018-03-13T07:49:48.502Z</updated>
    
    <content type="html"><![CDATA[<p>测试是开发的一个非常重要的方面，可以在很大程度上决定一个应用程序的命运。良好的测试可以在早期捕获导致应用程序崩溃的问题，但较差的测试往往总是导致故障和停机。</p><p>三种主要类型的软件测试：单元测试，功能测试和集成测试</p><a id="more"></a><h1 id="软件开发测试的类型"><a href="#软件开发测试的类型" class="headerlink" title="软件开发测试的类型"></a>软件开发测试的类型</h1><p>单元测试用于测试各个代码组件，并确保代码按照预期的方式工作。单元测试由开发人员编写和执行。大多数情况下，使用JUnit或TestNG之类的测试框架。测试用例通常是在方法级别写入并通过自动化执行。</p><p>集成测试检查系统是否作为一个整体而工作。集成测试也由开发人员完成，但不是测试单个组件，而是旨在跨组件测试。系统由许多单独的组件组成，如代码，数据库，Web服务器等。集成测试能够发现如组件布线，网络访问，数据库问题等问题。</p><p>功能测试通过将给定输入的结果与规范进行比较来检查每个功能是否正确实现。通常，这不是在开发人员级别的。功能测试由单独的测试团队执行。测试用例基于规范编写，并且实际结果与预期结果进行比较。有若干工具可用于自动化的功能测试，如Selenium和QTP。</p><p>如前所述，单元测试可帮助开发人员确定代码是否正常工作。在这篇博文中，我将提供在Java中单元测试的有用提示。</p><h1 id="使用框架来用于单元测试"><a href="#使用框架来用于单元测试" class="headerlink" title="使用框架来用于单元测试"></a>使用框架来用于单元测试</h1><p>Java提供了若干用于单元测试的框架。TestNG和JUnit是最流行的测试框架。JUnit和TestNG的一些重要功能：</p><ul><li>易于设置和运行。</li><li>支持注释。</li><li>允许忽略或分组并一起执行某些测试。</li><li>支持参数化测试，即通过在运行时指定不同的值来运行单元测试。</li><li>通过与构建工具，如Ant，Maven和Gradle集成来支持自动化的测试执行。</li><li>EasyMock是一个模拟框架，是单元测试框架，如JUnit和TestNG的补充。EasyMock本身不是一个完整的框架。它只是添加了创建模拟对象以便于测试的能力。例如，我们想要测试的一个方法可以调用从数据库获取数据的DAO类。在这种情况下，EasyMock可用于创建返回硬编码数据的MockDAO。这使我们能够轻松地测试我们意向的方法，而不必担心数据库访问。</li></ul><h1 id="谨慎使用测试驱动开发！"><a href="#谨慎使用测试驱动开发！" class="headerlink" title="谨慎使用测试驱动开发！"></a>谨慎使用测试驱动开发！</h1><p>测试驱动开发（TDD）是一个软件开发过程，在这过程中，在开始任何编码之前，我们基于需求来编写测试。由于还没有编码，测试最初会失败。然后写入最小量的代码以通过测试。然后重构代码，直到被优化。</p><p>目标是编写覆盖所有需求的测试，而不是一开始就写代码，却可能甚至都不能满足需求。TDD是伟大的，因为它导致简单的模块化代码，且易于维护。总体开发速度加快，容易发现缺陷。此外，单元测试被创建作为TDD方法的副产品。</p><p>然而，TDD可能不适合所有的情况。在设计复杂的项目中，专注于最简单的设计以便于通过测试用例，而不提前思考可能会导致巨大的代码更改。此外，TDD方法难以用于与遗留系统，GUI应用程序或与数据库一起工作的应用程序交互的系统。另外，测试需要随着代码的改变而更新。</p><p>因此，在决定采用TDD方法之前，应考虑上述因素，并应根据项目的性质采取措施。</p><h1 id="测量代码覆盖率"><a href="#测量代码覆盖率" class="headerlink" title="测量代码覆盖率"></a>测量代码覆盖率</h1><p>代码覆盖率衡量（以百分比表示）了在运行单元测试时执行的代码量。通常，高覆盖率的代码包含未检测到的错误的几率要低，因为其更多的源代码在测试过程中被执行。测量代码覆盖率的一些最佳做法包括：</p><p>使用代码覆盖工具，如Clover，Corbetura，JaCoCo或Sonar。使用工具可以提高测试质量，因为这些工具可以指出未经测试的代码区域，让你能够开发开发额外的测试来覆盖这些领域。<br>每当写入新功能时，立即写新的测试覆盖。<br>确保有测试用例覆盖代码的所有分支，即if / else语句。<br>高代码覆盖不能保证测试是完美的，所以要小心！</p><p>下面的 concat 方法接受布尔值作为输入，并且仅当布尔值为true时附加传递两个字符串：</p><pre><code>stringUtil类的方法public String concat(boolean append, String a,String b) {        String result = null;        If (append) {            result = a + b;                            }        return result.toLowerCase();}</code></pre><p>以下是上述方法的测试用例：<br>    @Test<br>    public void testStringUtil() {<br>         String result = stringUtil.concat(true, “Hello “, “World”);<br>         System.out.println(“Result is “+result);<br>    }</p><p>在这种情况下，执行测试的值为true。当测试执行时，它将通过。当代码覆盖率工具运行时，它将显示100%的代码覆盖率，因为 concat 方法中的所有代码都被执行。但是，如果测试执行的值为false，则将抛出 NullPointerException 。所以100%的代码覆盖率并不真正表明测试覆盖了所有场景，也不能说明测试良好。</p><h1 id="尽可能将测试数据外部化"><a href="#尽可能将测试数据外部化" class="headerlink" title="尽可能将测试数据外部化"></a>尽可能将测试数据外部化</h1><p>在JUnit4之前，测试用例要运行的数据必须硬编码到测试用例中。这导致了限制，为了使用不同的数据运行测试，测试用例代码必须修改。但是，JUnit4以及TestNG支持外部化测试数据，以便可以针对不同的数据集运行测试用例，而无需更改源代码。</p><p>下面的 MathChecker 类有方法可以检查一个数字是否是奇数：</p><pre><code>public class MathChecker {    public Boolean isOdd(int n) {        if (n%2 != 0) {            return true;        } else {            return false;        }    }}</code></pre><p>以下是MathChecker类的TestNG测试用例：</p><pre><code>public class MathCheckerTest {    private MathChecker checker;    @BeforeMethod    public void beforeMethod() {      checker = new MathChecker();    }    @Test    @Parameters(&quot;num&quot;)    public void isOdd(int num) {       System.out.println(&quot;Running test for &quot;+num);      Boolean result = checker.isOdd(num);      Assert.assertEquals(result, new Boolean(true));    }}</code></pre><p>以下是testng.xml（用于TestNG的配置文件），它具有要为其执行测试的数据：</p><pre><code>&lt; class=&quot;hljs xml&quot;&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;suite name=&quot;ParameterExampleSuite&quot; parallel=&quot;false&quot;&gt;&lt;test name=&quot;MathCheckerTest&quot;&gt;&lt;classes&gt;  &lt;parameter name=&quot;num&quot; value=&quot;3&quot;&gt;&lt;/parameter&gt;  &lt;class name=&quot;com.stormpath.demo.MathCheckerTest&quot;/&gt;&lt;/classes&gt; &lt;/test&gt; &lt;test name=&quot;MathCheckerTest1&quot;&gt;&lt;classes&gt;  &lt;parameter name=&quot;num&quot; value=&quot;7&quot;&gt;&lt;/parameter&gt;  &lt;class name=&quot;com.stormpath.demo.MathCheckerTest&quot;/&gt;&lt;/classes&gt; &lt;/test&gt;&lt;/suite&gt;</code></pre><p>可以看出，在这种情况下，测试将执行两次，值3和7各一次。除了通过XML配置文件指定测试数据之外，还可以通过DataProvider注释在类中提供测试数据。</p><p>与TestNG类似，测试数据也可以外部化用于JUnit。以下是与上述相同MathChecker类的JUnit测试用例：<br>        @RunWith(Parameterized.class)<br>        public class MathCheckerTest {<br>         private int inputNumber;<br>         private Boolean expected;<br>         private MathChecker mathChecker;<br>         @Before<br>         public void setup(){<br>             mathChecker = new MathChecker();<br>         }<br>            // Inject via constructor<br>            public MathCheckerTest(int inputNumber, Boolean expected) {<br>                this.inputNumber = inputNumber;<br>                this.expected = expected;<br>            }<br>            @Parameterized.Parameters<br>            public static Collection&lt;Object[]&gt; getTestData() {<br>                return Arrays.asList(new Object[][]{<br>                        {1, true},<br>                        {2, false},<br>                        {3, true},<br>                        {4, false},<br>                        {5, true}<br>                });<br>            }<br>            @Test<br>            public void testisOdd() {<br>                System.out.println(“Running test for:”+inputNumber);<br>                assertEquals(mathChecker.isOdd(inputNumber), expected);<br>            }<br>        }</p><p>可以看出，要对其执行测试的测试数据由getTestData（）方法指定。此方法可以轻松地修改为从外部文件读取数据，而不是硬编码数据。<br>这样避免了重复写测试框架的麻烦,只需要外部文件中读取测试数据即可.</p><h1 id="使用断言而不是Print语句"><a href="#使用断言而不是Print语句" class="headerlink" title="使用断言而不是Print语句"></a>使用断言而不是Print语句</h1><p>许多新手开发人员习惯于在每行代码之后编写System.out.println语句来验证代码是否正确执行。这种做法常常扩展到单元测试，从而导致测试代码变得杂乱。除了混乱，这需要开发人员手动干预去验证控制台上打印的输出，以检查测试是否成功运行。更好的方法是使用自动指示测试结果的断言。</p><p>下面的 StringUti 类是一个简单类，有一个连接两个输入字符串并返回结果的方法：<br>        public class StringUtil {<br>            public String concat(String a,String b) {<br>                return a + b;<br>            }<br>        }</p><p>以下是上述方法的两个单元测试：</p><pre><code>@Testpublic void testStringUtil_Bad() {     String result = stringUtil.concat(&quot;Hello &quot;, &quot;World&quot;);     System.out.println(&quot;Result is &quot;+result);}@Testpublic void testStringUtil_Good() {     String result = stringUtil.concat(&quot;Hello &quot;, &quot;World&quot;);     assertEquals(&quot;Hello World&quot;, result);}</code></pre><p>testStringUtil_Bad将始终传递，因为它没有断言。开发人员需要手动地在控制台验证测试的输出。如果方法返回错误的结果并且不需要开发人员干预，则testStringUtil_Good将失败。</p><p>一开始，是通过输出结果判断输出结果是否正确来判断，console虽然输出是true，false 和预期的是一样，但是junit显示都是成功的，并没有出现报错，达不到使用junit测试的效果。</p><p>junit 出现failures 和 errors 的情况：</p><p>Failure指的是由于预期的结果与实际运行的测试的结果不同而导致的，例如当使用assertEquals()或其它assertXXX()方法断言失败时，就会报出Failure，如果发现Faulure，你就要去检查你的测试方法或者是被测试方法中编写的逻辑是否有误。</p><p>Error指的是编写程序时没有考虑到的问题。在执行测试的断言之前，程序就因为某种类型的意外而停止，比喻说我们在操作数组的时候，因为存取超出索引会引发ArrayIndexOutOfBoundsException，这个时候程序就会报出Error，程序将无法运行下去，提前结束，这个时候你要检查被测试方法中是不是有欠缺考虑到地方。</p><p>Junit的断言方法：</p><p>assertEquals 和 assertTrue 区别</p><p>相同之处：都能判断两个值是否相等<br>assertTrue 如果为true，则运行success，反之Failure<br>assertEquals 如果预期值与真实值相等，则运行success，反之Failure</p><p>不同之处：<br>assertEquals 运行Failure会有错误提示，提示预期值是xxx，而实际值是xxx。容易调式<br>assertTrue 没有错误提示</p><p>两种方法都可以判断，一般建议使用assertEquals 容易调试</p><h1 id="构建具有确定性结果的测试"><a href="#构建具有确定性结果的测试" class="headerlink" title="构建具有确定性结果的测试"></a>构建具有确定性结果的测试</h1><p>一些方法不具有确定性结果，即该方法的输出不是预先知道的，并且每一次都可以改变。例如，考虑以下代码，它有一个复杂的函数和一个计算执行复杂函数所需时间（以毫秒为单位）的方法：</p><pre><code>public class DemoLogic {private void veryComplexFunction(){    //This is a complex function that has a lot of database access and is time consuming    //To demo this method, I am going to add a Thread.sleep for a random number of milliseconds    try {        int time = (int) (Math.random()*100);        Thread.sleep(time);    } catch (InterruptedException e) {        // TODO Auto-generated catch block        e.printStackTrace();    }}public long calculateTime(){    long time = 0;    long before = System.currentTimeMillis();    veryComplexFunction();    long after = System.currentTimeMillis();    time = after - before;    return time;}}</code></pre><p>在这种情况下，每次执行 calculateTime 方法时，它将返回一个不同的值。为该方法编写测试用例不会有任何用处，因为该方法的输出是可变的。因此，测试方法将不能验证任何特定执行的输出。</p><p>除了正面情景外，还要测试负面情景和边缘情况</p><p>通常，开发人员会花费大量的时间和精力编写测试用例，以确保应用程序按预期工作。然而，测试负面测试用例也很重要。负面测试用例指的是测试系统是否可以处理无效数据的测试用例。例如，考虑一个简单的函数，它能读取长度为8的字母数字值，由用户键入。除了字母数字值，应测试以下负面测试用例：</p><p>用户指定非字母数字值，如特殊字符。<br>用户指定空值。<br>用户指定大于或小于8个字符的值。<br>类似地，边界测试用例测试系统是否适用于极端值。例如，如果用户希望输入从1到100的数字值，则1和100是边界值，对这些值进行测试系统是非常重要的。</p><p>本文转载自：<a href="http://www.linuxprobe.com/write-java-test.html" target="_blank" rel="noopener">http://www.linuxprobe.com/write-java-test.html</a></p><p>JUnit是由 Erich Gamma 和 Kent Beck 编写的一个回归测试框架（regression testing framework）。Junit测试是程序员测试，即所谓白盒测试，因为程序员知道被测试的软件如何（How）完成功能和完成什么样（What）的功能。Junit是一套框架，继承TestCase类，就可以用Junit进行自动测试了。</p><p>推荐这个文章  <a href="http://hao.jobbole.com/junit/" target="_blank" rel="noopener">http://hao.jobbole.com/junit/</a></p><p>官方手册： <a href="https://junit.org/junit4/cookbook.html" target="_blank" rel="noopener">https://junit.org/junit4/cookbook.html</a></p><p>API手册： <a href="https://junit.org/junit4/javadoc/latest/" target="_blank" rel="noopener">https://junit.org/junit4/javadoc/latest/</a></p><p>新手指南： <a href="https://github.com/junit-team/junit4/wiki/Getting-started" target="_blank" rel="noopener">https://github.com/junit-team/junit4/wiki/Getting-started</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;测试是开发的一个非常重要的方面，可以在很大程度上决定一个应用程序的命运。良好的测试可以在早期捕获导致应用程序崩溃的问题，但较差的测试往往总是导致故障和停机。&lt;/p&gt;
&lt;p&gt;三种主要类型的软件测试：单元测试，功能测试和集成测试&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="java类库" scheme="http://yoursite.com/tags/java%E7%B1%BB%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>大数据--VMware搭建虚拟机集群</title>
    <link href="http://yoursite.com/2018/03/11/bigdata01/"/>
    <id>http://yoursite.com/2018/03/11/bigdata01/</id>
    <published>2018-03-11T15:55:40.000Z</published>
    <updated>2018-03-12T17:32:21.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是IP地址？"><a href="#什么是IP地址？" class="headerlink" title="什么是IP地址？"></a>什么是IP地址？</h1><p>这个问题，首先你要了解一下什么是IP地址：<br>人们为了通信方便给每一台计算机都事先分配一个类似电话号码一样的标识地址，即IP地址。<br>根据TCP/IP协议，IP地址由32位二进制数组成，而且在INTERNET范围内是唯一的。<br>如：某IP地址为11000000 10101000 00001010 00000010<br>为了方便记忆，人们把32位的IP地址分成四段，每段8位，中间用小数点“.”隔开，然后再将每8位二进制换成十进制，<br>例如：192.168.0.0 就是由每8位二进制转换而成的<br>IP地址又分为：固定IP和动态IP<br>固定IP地址是长期分配给一台计算机或网络设备使用的IP地址。一般来说，采用专线上网的计算机才拥有固定的IP地址。<br>动态IP地址:当您拨号（或以其他方式）连接互联网时，通常您会从您的ISP（互联网服务商）分配到一个动态的IP地址。这意味着您每次连接互联网时得到的IP地址是不同的。尽管这不影响您访问互联网，但是您的朋友、商业伙伴（他们可能这时也在互联网上）却不能访问到您。因为，他们不知道您的计算机在哪里。这就像每个人都有一部电话，但电话号码每天都在改变。</p><p><img src="/2018/03/11/bigdata01/timg.jpg" alt="logo"></p><a id="more"></a><h2 id="我们常用的电信信号光纤是属于哪种呢？"><a href="#我们常用的电信信号光纤是属于哪种呢？" class="headerlink" title="我们常用的电信信号光纤是属于哪种呢？"></a>我们常用的电信信号光纤是属于哪种呢？</h2><p>静态IP也叫固定IP，一般运营商用来作为专线宽带提供给企业用户。价格较高。是从用户处直接光纤到运营商机房，用户专享开通的带宽，带宽不受周围用户的影响。静态IP地址一般都用在专线网络上，比如网吧所用的网线。电信公司通常会给网吧分配固定的IP地址，永远都不会变化的，像这种网络就要在路由器上输IP地址来连接。价格和质量也是不一样的哦，要不然怎么能带几十台甚至是上百台电脑。</p><p>动态IP是普通用户常用的方式，光纤入户接光猫，通过光猫拨号上网。例如家庭用户开通的10M宽带，是从用户家到运营商机房交换机开通的是10M，交换机上联的端口是小区用户共享，如果小区内其他用户很少，那你这10M是和专线一样的。但如果小区内用户多了，大家共用交换机总出口带宽，可能实际就达不到10M带宽了。<br>当你从邻居家路由器那里连一条线过来，然后自己又想再用一个路由器分几台电脑，上头的路由器用的是DHCP分配IP地址的，那下头的路由器就要用动态IP，让路由器自动获取IP地址。不用输入任何东西。<br>设置动态IP连接有一点要非常非常注意的地方。就是要更改LAN接口的IP地址。更改成除192.168.1.1所在的网段之外的其它网段，如192.168.2.1或者172.16.0.1都行。因为现在大部分路由器厂商设置的LAN接口的IP地址都是192.168.1.1，下头路由器WAN接口从上头路由器那里获取的IP地址一般都是192.168.1.1所在的网段，这会和下头LAN接口的网段冲突，获取不到IP地址的，也就是上不了网。说简单点就是一个路由器的WAN外网接口和LAN内网接口不能是同一个网段。</p><h2 id="通过cmd命令也可以知道自己的宽带是属于哪种？"><a href="#通过cmd命令也可以知道自己的宽带是属于哪种？" class="headerlink" title="通过cmd命令也可以知道自己的宽带是属于哪种？"></a>通过cmd命令也可以知道自己的宽带是属于哪种？</h2><ul><li>单击开始，在运行中输入cmd。</li><li>然后在命令提示符输入‘ipconfig空格/all’查看本地连接‘dhcp Enable’这项（如下图）</li><li>如果为NO则是静态的，如果为yes则是动态的。</li></ul><h1 id="VMware"><a href="#VMware" class="headerlink" title="VMware"></a>VMware</h1><p>VMware,Inc. (Virtual Machine ware）是一个“虚拟PC”软件公司，提供服务器、桌面虚拟化的解决方案。其虚拟化平台的产品包括播放器；它能使个人用台式电脑运行虚拟机器，融合器，它是用户基于英特尔结构苹果机的桌面虚拟化产品，工作站的软件开发商和企业的资讯科技专才，能使虚拟分区的服务器，ESX服务器（一种能直接在硬件上运行的企业级的虚拟平台），虚拟的SMP让一个虚拟机同时使用四个物理处理器，和VMFS使多个ESX服务器分享块存储器。<br>该公司还提供一个虚拟中心来控制和管理虚拟化的IT环境；VMotion 让用户可以移动虚拟机器；DRS从物理处理器创造资源工具；HA 提供从硬件故障自动回复功能；综合备份可使LAN-free自动备份虚拟机器；VMotion存储器可允许虚拟机磁盘自由移动；更新管理器自动更新修补程序和更新管理；能力规划能使VMware的服务供应商执行能力评估；转换器把本地和远程物理仪器转换到虚拟机器；实验室管理可自动化安装，捕捉，存储和共享，多机软件配置；ACE允许桌面系统管理包括公司资源以防止不可控台式电脑带来的风险。<br>虚拟桌面基础设施可主导个人台式电脑在虚拟机运行的中央管理器；虚拟桌面管理，它是联系用户到数据库中的虚拟电脑的桌面管理服务器；VMware 生命管理周期可通过虚拟环境提供控制权，实现计算机的多性能。该公司成立于1998，总部在加州的Palo Alto。<br>它的产品可以使你在一台机器上同时运行二个或更多Windows、DOS、LINUX系统。与“多启动”系统相比，VMWare采用了完全不同的概念。多启动系统在一个时刻只能运行一个系统，在系统切换时需要重新启动机器。<br>VMWare是真正“同时”运行，多个操作系统在主系统的平台上，就象标准Windows应用程序那样切换。而且每个操作系统你都可以进行虚拟的分区、配置而不影响真实硬盘的数据，你甚至可以通过网卡将几台虚拟机用网卡连接为一个局域网，极其方便。安装在VMware操作系统性能上比直接安装在硬盘上的系统低不少，因此，比较适合学习和测试。</p><h1 id="如何使用VMware虚拟机软件搭建伪机集群？"><a href="#如何使用VMware虚拟机软件搭建伪机集群？" class="headerlink" title="如何使用VMware虚拟机软件搭建伪机集群？"></a>如何使用VMware虚拟机软件搭建伪机集群？</h1><p>因为要用到大数据的Hadoop框架进行学习，我们要利用VMware来搭建3台伪机(Linux系统)以供学习<br>Hadoop的虚拟机环境分为apache版本和CDH版本的<br>apache版本的比较不吃硬件设备，可以通过伪机群来实现大数据框架，而CDH版本则吃硬件，需要实机搭建。</p><h2 id="搭建三台Linux系统伪机"><a href="#搭建三台Linux系统伪机" class="headerlink" title="搭建三台Linux系统伪机"></a>搭建三台Linux系统伪机</h2><h3 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h3><p>CentOS（Community Enterprise Operating System，中文意思是：社区企业操作系统）是Linux发行版之一，它是来自于Red Hat Enterprise Linux依照开放源代码规定释出的源代码所编译而成。由于出自同样的源代码，因此有些要求高度稳定性的服务器以CentOS替代商业版的Red Hat Enterprise Linux使用。两者的不同，在于CentOS并不包含封闭源代码软件。<br>CentOS 是一个基于Red Hat Linux 提供的可自由使用源代码的企业级Linux发行版本。每个版本的 CentOS都会获得十年的支持（通过安全更新方式）。新版本的 CentOS 大约每两年发行一次，而每个版本的 CentOS 会定期（大概每六个月）更新一次，以便支持新的硬件。这样，建立一个安全、低维护、稳定、高预测性、高重复性的 Linux 环境。[1]  CentOS是Community Enterprise Operating System的缩写。<br>CentOS 是RHEL（Red Hat Enterprise Linux）源代码再编译的产物，而且在RHEL的基础上修正了不少已知的 Bug ，相对于其他 Linux 发行版，其稳定性值得信赖。</p><p>除了CentOS是Linux的发行版之一<br>发行版为许多不同的目的而制作, 包括对不同计算机结构的支持, 对一个具体区域或语言的本地化，实时应用，和嵌入式系统，甚至许多版本故意地只加入免费软件。已经有超过三百个发行版被积极的开发，最普遍被使用的发行版有大约十二个。</p><ul><li>Fedora Core<br>Fedora Core（自第七版直接更名为Fedora）是众多 Linux 发行版之一。它是一套从Red Hat Linux发展出来的免费Linux系统。Fedora Core 的前身就是Red Hat Linux。Fedora是一个开放的、创新的、前瞻性的操作系统和平台，基于Linux。它允许任何人自由地使用、修改和重发布，无论现在还是将来。它由一个强大的社群开发，这个社群的成员以自己的不懈努力，提供并维护自由、开放源码的软件和开放的标准。Fedora 项目由 Fedora 基金会管理和控制，得到了 Red Hat, Inc. 的支持。Fedora 是一个独立的操作系统，是Linux的一个发行版，可运行的体系结构包括 x86(即i386-i686), x86_64 和 PowerPC。</li><li>Debian<br>Debian Project诞生于1993年8月13日，它的目标是提供一个稳定容错的Linux版本。支持Debian的不是某家公司，而是许多在其改进过程中投入了大量时间的开发人员，这种改进吸取了早期Linux的经验。<br>Debian以其稳定性著称，虽然它的早期版本Slink有一些问题，但是它的现有版本Potato已经相当稳定了。这个版本更多的使用了 pluggable authentication modules (PAM)，综合了一些更易于处理的需要认证的软件（如winbind for Samba）。<br>Debian的安装完全是基于文本的，对于其本身来说这不是一件坏事。但对于初级用户来说却并非这样。因为它仅仅使用fdisk 作为分区工具而没有自动分区功能，所以它的磁盘分区过程令人十分讨厌。磁盘设置完毕后，软件工具包的选择通过一个名为dselect的工具实现，但它不向用户提供安装基本工具组（如开发工具）的简易设置步骤。最后需要使用anXious工具配置X Windows，这个过程与其他版本的X Windows配置过程类似。完成这些配置后，Debian就可以使用了。<br>Debian主要通过基于Web的论坛和邮件列表来提供技术支持。作为服务器平台，Debian提供一个稳定的环境。为了保证它的稳定性，开发者不会在其中随意添加新技术，而是通过多次测试之后才选定合适的技术加入。当前最新正式版本是Debian 6，采用的内核是Linux 2.6.32。Debian 6 第一次 包含了一个100%开源的Linux内核，这个内核中不再包含任何闭源的硬件驱动。所有的闭源软件都被隔离成单独的软件包，放到Debian软件源的 “non-free” 部分。由此，Debian用户便可以自由地选择是使用一个完全开源的系统还是添加一些闭源驱动。[1] </li><li>Mandrake<br>MandrakeSoft，Linux Mandrake的发行商，在1998年由一个推崇Linux的小组创立，它的目标是尽量让工作变得更简单。最终，Mandrake给人们提供了一个优秀的图形安装界面，它的最新版本还包含了许多Linux软件包。<br>作为Red Hat Linux的一个分支，Mandrake将自己定位在桌面市场的最佳Linux版本上。但该公司还是支持服务器上的安装，而且成绩并不坏。Mandrake的安装非常简单明了，为初级用户设置了简单的安装选项。它完全使用GUI界面，还为磁盘分区制作了一个适合各类用户的简单GUI界面。软件包的选择非常标准，另外还有对软件组和单个工具包的选项。安装完毕后，用户只需重启系统并登录进入即可。<br>Mandrake主要通过邮件列表和Mandrak 自己的Web论坛提供技术支持。Mandrak对桌面用户来说是一个非常不错的选择，它还可作为一款优秀的服务器系统，尤其适合Linux新手使用。它使用最新版本的内核，拥有许多用户需要在Linux服务器环境中使用的软件——数据库和Web服务器。<br>Mandrak没有重大的软件缺陷，只是它更加关注桌面市场，较少关注服务器市场。</li><li>Ubuntu<br>Ubuntu是一个以桌面应用为主的Linux操作系统，其名称来自非洲南部祖鲁语或豪萨语的“ubuntu”一词（译为吾帮托或乌班图），意思是“人性”、“我的存在是因为大家的存在”，是非洲传统的一种价值观，类似华人社会的“仁爱”思想。Ubuntu基于Debian发行版和unity桌面环境，与Debian的不同在于它每6个月会发布一个新版本。Ubuntu的目标在于为一般用户提供一个最新的、同时又相当稳定的主要由自由软件构建而成的操作系统。Ubuntu具有庞大的社区力量，用户可以方便地从社区获得帮助。随着云计算的流行，ubuntu推出了一个云计算环境搭建的解决方案，可以在其官方网站找到相关信息。于2012年4月26日发布最终版ubuntu 12.04，ubuntu 12.04是长期支持的版本。</li><li>Red Hat Linux<br>可能这是最著名的Linux版本了，Red Hat Linux已经创造了自己的品牌，越来越多的人听说过它。Red Hat在1994年创业，当时聘用了全世界500多名员工，他们都致力于开放的源代码体系。<br>Red Hat Linux是公共环境中表现上佳的服务器。它拥有自己的公司，能向用户提供一套完整的服务，这使得它特别适合在公共网络中使用。这个版本的Linux也使用最新的内核，还拥有大多数人都需要使用的主体软件包。<br>Red Hat Linux的安装过程也十分简单明了。它的图形安装过程提供简易设置服务器的全部信息。磁盘分区过程可以自动完成，还可以选择GUI工具完成，即使对于 Linux新手来说这些都非常简单。选择软件包的过程也与其他版本类似；用户可以选择软件包种类或特殊的软件包。系统运行起来后，用户可以从Web站点和 Red Hat那里得到充分的技术支持。我发现Red Hat是一个符合大众需求的最优版本。在服务器和桌面系统中它都工作得很好。Red Hat的唯一缺陷是带有一些不标准的内核补丁，这使得它难于按用户的需求进行定制。 Red Hat通过论坛和邮件列表提供广泛的技术支持，它还有自己公司的电话技术支持，后者对要求更高技术支持水平的集团客户更有吸引力。</li><li>SuSE<br>总部设在德国的SuSE AG在商界已经奋斗了8年多，它一直致力于创建一个连接数据库的最佳Linux版本。为了实现这一目的，SuSE与Oracle 和IBM合作，以使他们的产品能稳定地工作。SuSE还开发了SuSE Linux eMail Server III，一个非常稳定的电子邮件群组应用。<br>基于2.4.10内核的SuSE 7.3，在原有版本的基础上提高了易用性。安装过程通过GUI完成，磁盘分区过程也非常简单，但它没有为用户提供更多的控制和选择。<br>在SuSE 操作系统下，可以非常方便地访问Windows磁盘，这使得两种平台之间的切换，以及使用双系统启动变得更容易。SuSE的硬件检测非常优秀，该版本在服务器和工作站上都用得很好。<br>SuSE拥有界面友好的安装过程，还有图形管理工具，可方便地访问Windows磁盘，对于终端用户和管理员来说使用它同样方便，这使它成为了一个强大的服务器平台。 SuSE也通过基于Web的论坛提供技术支持，另外我还发现它有电话技术支持。</li><li>Linux Mint<br>Linux Mint是一份基于Ubuntu的发行版，其目标是提供一种更完整的即刻可用体验，这包括提供浏览器插件、多媒体编解码器、对DVD播放的支持、Java和其他组件。它与Ubuntu软件仓库兼容。Linux Mint 是一个为pc和X86电脑设计的操作系统。<br>因此，一个可以跑得动Windows的电脑也可以使用Linux Mint来代替Windows，或者两个都跑。既有Windows又有Linux的系统就是传说中的“双系统”。同样，MAC，BSD或者其他的Linux版本也可以和Linux Mint 共存。一台装有多系统的电脑在开机的时候会出现一个供你选择操作系统的菜单。Linux Mint可以很好的在一个单系统的电脑上运行，但是它也可以自动检测其他操作系统并与其互动，例如，如果你安装Linux Mint在一个安装了Windows版本的（xp，vista或者其他版本），它会自动检测并建立双启动以供您在开机的时候选择启动哪个系统。并且你可以在Linux Mint下访问Windows分区。Linux是更安全，更稳定，更有效并且日益易于操作的甚至可以和Windows相媲美的系统，它越来越让人感到难以抉择了。</li><li>Gentoo<br>Gentoo是Linux世界最年轻的发行版本，正因为年轻，所以能吸取在她之前的所有发行版本的优点。Gentoo最初由Daniel Robbins（FreeBSD的开发者之一）创建，首个稳定版本发布于2002年。由于开发者对FreeBSD的熟识，所以Gentoo拥有媲美FreeBSD的广受美誉的ports系统 ——Portage包管理系统。</li><li>centos<br>CentOS（Community ENTerprise Operating System）是Linux发行版之一，它是来自于Red Hat Enterprise Linux依照开放源代码规定释出的源代码所编译而成。由于出自同样的源代码，因此有些要求高度稳定性的服务器以CentOS替代商业版的Red Hat Enterprise Linux使用。两者的不同，在于CentOS并不包含封闭源代码软件,CentOS 是一个基于Red Hat Linux 提供的可自由使用源代码的企业级Linux发行版本。每个版本的 CentOS都会获得十年的支持（通过安全更新方式）。新版本的 CentOS 大约每两年发行一次，而每个版本的 CentOS 会定期（大概每六个月）更新一次，以便支持新的硬件。这样，建立一个安全、低维护、稳定、高预测性、高重复性的 Linux 环境。CentOS是Community Enterprise Operating System的缩写。<br>CentOS 是RHEL（Red Hat Enterprise Linux）源代码再编译的产物，而且在RHEL的基础上修正了不少已知的 Bug ，相对于其他 Linux 发行版，其稳定性值得信赖。<br>RHEL 在发行的时候，有两种方式。一种是二进制的发行方式，另外一种是源代码的发行方式。</li></ul><p>CentOS在2014初，宣布加入Red Hat。</p><h3 id="Red-Hat"><a href="#Red-Hat" class="headerlink" title="Red Hat"></a>Red Hat</h3><p>Red Hat（红帽）公司（NYSE：RHT）是一家开源解决方案供应商，也是标准普尔500指数成员。总部位于美国北卡罗来纳州的罗利市，截止2015年3月3日，共有80多个分公司。红帽公司为诸多重要IT技术如操作系统、存储、中间件、虚拟化和云计算提供关键任务的软件与服务。红帽的开放源码模式提供跨物理、虚拟和云端环境的企业运算解决方案，以帮助企业降低成本并提升效能、稳定性与安全性。红帽公司同时也为全球客户或通过领先合作伙伴为客户提供技术支持、培训和咨询服务。<br>红帽的商业模式，简单的说就是红帽将开源社区项目产品化，使普通企业客户更容易消费<br>开源创新技术的一种方法。 从用户角度来看，不同的投资预算与研发能力的企业都可以通过红帽获得开源软件的价值。</p><p>红帽产品涉及5大技术领域：云计算、存储、虚拟化、中间件、操作系统。</p><p>云计算<br>（1）红帽企业Linux OpenStack平台<br>（2）红帽OpenShift（PASS 产品）<br>（3）红帽CloudForms （混合云管理平台）<br>（4）红帽云基础架构（Cloud Infrastructure）<br>存储<br>（1）红帽Inktank Ceph Enterprise为部署公有云或私有云的企业（包括许多OpenStack的早期采用者）提供了对象和数据块存储软件。<br>（2）红帽存储服务器（Red Hat Storage Server）的先进性能可充分适应数据密集型企业的任务负载，满足包括大数据、运营分析、企业文件共享与协同等在内的数据处理。<br>虚拟化<br>红帽企业虚拟化产品提供了先进的开源企业虚拟化功能，使客户能够优化传统的虚拟化任务负载，为通过OpenStack实现云部署提供一个入口。红帽企业虚拟化帮助企业客户实现传统虚拟化基础架构的流线化和优化，同时为私有云能力奠定了基础。<br>中间件<br>红帽JBoss中间件通过提供快速构建将人员、流程和信息连接在一起的系统所需的工具，来帮助组织发展其中间件基础架构。红帽JBoss中间件主要产品有红帽JBoss企业应用平台、JBoss Web服务器、JBoss 数据网格、JBoss 开发人员工作室、JBoss门户、JBoss运营网络，JBoss Fuse （企业服务总线-ESB)，JBoss A-MQ（消息中间件）、JBoss数据虚拟化、JBoss Fuse Service Works、JBoss BRMS，JBoss BPM套件等。<br>操作系统<br>（1）红帽企业Linux<br>红帽在2014年6月发布了最新旗舰版企业操作系统——红帽企业Linux 7。基于红帽企业Linux 7操作系统，企业可整合裸机服务器、 虚拟机、基础设施即服务(IaaS)和平台即服务(PaaS)，以构建一个强大稳健的数据中心环境，满足不断变化的业务需求。<br>（2）红帽卫星<br>红帽卫星是一个综合性解决方案，它通过配置软件分发、补丁和配置管理，以及物理、虚拟和云环境的订阅管理为红帽系统提供完整的生命周期管理，为管理构建、部署、运行和淘汰系统所需的工具提供了单独的管理控制台和方法论。</p><p>在经过严格的基于表现的考试后，经过认证的红帽专业人员保证了企业从其红帽解决方案中获得最大的回报。<br>（1）红帽认证架构师（RHCA）<br>（2）红帽认证系统管理员 (RHCSA)<br>（3）红帽认证工程师（RHCE）</p><p>如果你使用Red Hat软件包管理器来管理Linux软件，应该详细了解Red Hat软件仓库的原理，这有助于使用Linux命令将让你更容易管理Red Hat软件。<br>Linux软件包管理使用的Red Hat软件库，Red Hat提供了软件包的安装源。Red Hat管理器会自动查找库和安装包的依赖关系。如果没有Red Hat软件库管理系统，要解决这些Red Hat软件包的依赖关系是一种烦恼。<br>按目前的Linux分布情况，主要是的软件库管理系统是Red Hat的软件库管理系统，主要用在Red Hat Enterprise Linux（RHEL）和其他Red Hat Linux的衍生系统上，如Fedora、CentOS。Red Hat软件库管理系统使用默认的Red Hat软件包格式。Red Hat用.rpm，这些Red Hat软件包是将软件和元数据压缩和档案。Red Hat元数据提供了有关Red Hat软件的版本信息，以及Red Hat软件包的依赖关系。<br>但Red Hat软件包的数据库与软件库很容易混淆。虽然通过Red Hat软件库管理使这些软件包可以让工作更简单，但这些Red Hat软件包同时有另一个数据库。这意味着Red Hat软件包的信息来源可以有多个：包数据库和软件库数据库。<br>使用Red Hat包数据库工作<br>Red Hat包数据库是软件安装了什么在Linux系统里最重要的信息来源。Red Hat包数据库从服务器上检索当前安装的软件，Red Hat包文件通常是一个丰富的文档和软件使用的信息源，这对于Linux系统Red Hat软件包之间的依赖关系非常有用。<br>在基于Red Hat软件包的Linux服务器，使用Red Hat的rpm命令从数据库里获取信息<br>使用Red Hat软件仓库工作<br>在安装新的Red Hat软件或进行软件升级，系统管理员通常使用Red Hat软件仓库。尤其是更新Red Hat服务器补丁的时候，Red Hat软件仓库会更方便：Red Hat软件包管理器只需要更新新的软件包，使Red Hat自动可用，库用户便可以使用Red Hat，这过程完全是透明的。<br>在基于Red Hat软件仓库的系统，使用Red Hat的yum命令请求包的信息和执行任务，如Red Hat更新和安装软件。Red Hat的yum可以周期性的自动下载和更新软件仓库的索引文件。<br>Red Hat系统会自动比较了软件仓库的Red Hat安装包和安装在本地系统的Red Hat软件包列表，以确定一个Red Hat包已经安装，或者是否有可用的更新。<br>Red Hat软件仓库管理系统在处理软件包依赖关系非常好用：目前所有的Linux都提供了丰富的Red Hat资料库，并提供必要的Red Hat依赖，这意味着Linux管理员对Red Hat软件包的依赖恐惧大大减少了。<br>Red Hat软件仓库中没有的包<br>Red Hat软件仓库中没有的软件，意味着Red Hat安装起来比较困难。管理员可以创建自己的Red Hat软件库和复制本地的软件包。这也让管理员从库安装自定义Red Hat软件包的时候，进一步减少Red Hat依赖问题。</p><h3 id="利用VMware搭建centOS环境"><a href="#利用VMware搭建centOS环境" class="headerlink" title="利用VMware搭建centOS环境"></a>利用VMware搭建centOS环境</h3><p>VMware下安装Linux系统，以CentOS为例</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是IP地址？&quot;&gt;&lt;a href=&quot;#什么是IP地址？&quot; class=&quot;headerlink&quot; title=&quot;什么是IP地址？&quot;&gt;&lt;/a&gt;什么是IP地址？&lt;/h1&gt;&lt;p&gt;这个问题，首先你要了解一下什么是IP地址：&lt;br&gt;人们为了通信方便给每一台计算机都事先分配一个类似电话号码一样的标识地址，即IP地址。&lt;br&gt;根据TCP/IP协议，IP地址由32位二进制数组成，而且在INTERNET范围内是唯一的。&lt;br&gt;如：某IP地址为11000000 10101000 00001010 00000010&lt;br&gt;为了方便记忆，人们把32位的IP地址分成四段，每段8位，中间用小数点“.”隔开，然后再将每8位二进制换成十进制，&lt;br&gt;例如：192.168.0.0 就是由每8位二进制转换而成的&lt;br&gt;IP地址又分为：固定IP和动态IP&lt;br&gt;固定IP地址是长期分配给一台计算机或网络设备使用的IP地址。一般来说，采用专线上网的计算机才拥有固定的IP地址。&lt;br&gt;动态IP地址:当您拨号（或以其他方式）连接互联网时，通常您会从您的ISP（互联网服务商）分配到一个动态的IP地址。这意味着您每次连接互联网时得到的IP地址是不同的。尽管这不影响您访问互联网，但是您的朋友、商业伙伴（他们可能这时也在互联网上）却不能访问到您。因为，他们不知道您的计算机在哪里。这就像每个人都有一部电话，但电话号码每天都在改变。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/03/11/bigdata01/timg.jpg&quot; alt=&quot;logo&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="计算机硬件基础" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA开发常用类库--JSON解析库</title>
    <link href="http://yoursite.com/2018/03/07/JAVA-api/"/>
    <id>http://yoursite.com/2018/03/07/JAVA-api/</id>
    <published>2018-03-07T13:40:43.000Z</published>
    <updated>2018-03-13T05:02:40.158Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JSON是什么？"><a href="#JSON是什么？" class="headerlink" title="JSON是什么？"></a>JSON是什么？</h1><p>尽管有许多宣传关于 XML 如何拥有跨平台，跨语言的优势，然而，除非应用于 Web Services，否则，在普通的 Web 应用中，开发者经常为 XML 的解析伤透了脑筋，无论是服务器端生成或处理 XML，还是客户端用 JavaScript 解析 XML，都常常导致复杂的代码，极低的开发效率。实际上，对于大多数 Web 应用来说，他们根本不需要复杂的 XML 来传输数据，XML 的扩展性很少具有优势，许多 AJAX 应用甚至直接返回 HTML 片段来构建动态 Web 页面。和返回 XML 并解析它相比，返回 HTML 片段大大降低了系统的复杂性，但同时缺少了一定的灵活性。</p><p>现在， JSON 为 Web 应用开发者提供了另一种数据交换格式。让我们来看看 JSON 到底是什么，同 XML 或 HTML 片段相比，JSON 提供了更好的简单性和灵活性。</p><a id="more"></a><h1 id="JSON的数据格式是怎么样的？"><a href="#JSON的数据格式是怎么样的？" class="headerlink" title="JSON的数据格式是怎么样的？"></a>JSON的数据格式是怎么样的？</h1><p>和 XML 一样，JSON 也是基于纯文本的数据格式。由于 JSON 天生是为 JavaScript 准备的，因此，JSON 的数据格式非常简单，您可以用 JSON 传输一个简单的 String，Number，Boolean，也可以传输一个数组，或者一个复杂的 Object 对象。</p><p>String，Number 和 Boolean 用 JSON 表示非常简单。例如，用 JSON 表示一个简单的 String “ abc ”，其格式为：<br>    “abc”<br>除了字符 “，\，/ 和一些控制符（\b，\f，\n，\r，\t）需要编码外，其他 Unicode 字符可以直接输出。</p><p>下图是一个 String 的完整表示结构：<br><img src="/2018/03/07/JAVA-api/fig001.jpg" alt="logo"></p><p>一个 Number 可以根据整型或浮点数表示如下：<br><img src="/2018/03/07/JAVA-api/fig002.jpg" alt="logo"></p><p>这与绝大多数编程语言的表示方法一致，例如：<br>     12345（整数）<br>     -3.9e10（浮点数）</p><p>Boolean 类型表示为 true 或 false 。此外，JavaScript 中的 null 被表示为 null，注意，true、false 和 null 都没有双引号，否则将被视为一个 String 。<br>JSON 还可以表示一个数组对象，使用 [] 包含所有元素，每个元素用逗号分隔，元素可以是任意的 Value，例如，以下数组包含了一个 String，Number，Boolean 和一个 null：</p><pre><code>[&quot;abc&quot;,12345,false,null]</code></pre><p>Object 对象在 JSON 中是用 {} 包含一系列无序的 Key-Value 键值对表示的，实际上此处的 Object 相当于 Java 中的 Map&lt;String, Object&gt;，而不是 Java 的 Class 。注意 Key 只能用 String 表示。<br>例如，一个 Address 对象包含如下 Key-Value：</p><pre><code>city:Beijing street:Chaoyang Road postcode:100025（整数）</code></pre><p>用 JSON 表示如下：</p><pre><code>{&quot;city&quot;:&quot;Beijing&quot;,&quot;street&quot;:&quot; Chaoyang Road &quot;,&quot;postcode&quot;:100025}</code></pre><p>其中 Value 也可以是另一个 Object 或者数组，因此，复杂的 Object 可以嵌套表示，例如，一个 Person 对象包含 name 和 address 对象，可以表示如下：</p><pre><code>{&quot;name&quot;:&quot;Michael&quot;,&quot;address&quot;:    {&quot;city&quot;:&quot;Beijing&quot;,&quot;street&quot;:&quot; Chaoyang Road &quot;,&quot;postcode&quot;:100025}}</code></pre><p>#JavaScript 处理 JSON 数据<br>上面介绍了如何用 JSON 表示数据，接下来，我们还要解决如何在服务器端生成 JSON 格式的数据以便发送到客户端，以及客户端如何使用 JavaScript 处理 JSON 格式的数据。<br>我们先讨论如何在 Web 页面中用 JavaScript 处理 JSON 数据。我们通过一个简单的 JavaScript 方法就能看到客户端如何将 JSON 数据表示给用户：</p><pre><code>&apos;function handleJson() {    var j={&quot;name&quot;:&quot;Michael&quot;,&quot;address&quot;:      {&quot;city&quot;:&quot;Beijing&quot;,&quot;street&quot;:&quot; Chaoyang Road &quot;,&quot;postcode&quot;:100025}};    document.write(j.name);    document.write(j.address.city); }&apos;</code></pre><p> 假定服务器返回的 JSON 数据是上文的：<br>    ‘{“name”:”Michael”,”address”:<br>        {“city”:”Beijing”,”street”:” Chaoyang Road “,”postcode”:100025}<br>     }’</p><p> 只需将其赋值给一个 JavaScript 变量，就可以立刻使用该变量并更新页面中的信息了，相比 XML 需要从 DOM 中读取各种节点而言，JSON 的使用非常容易。我们需要做的仅仅是发送一个 Ajax 请求，然后将服务器返回的 JSON 数据赋值给一个变量即可。有许多 Ajax 框架早已包含了处理 JSON 数据的能力，例如 Prototype（一个流行的 JavaScript 库：<a href="http://prototypejs.org）提供了" target="_blank" rel="noopener">http://prototypejs.org）提供了</a> evalJSON() 方法，能直接将服务器返回的 JSON 文本变成一个 JavaScript 变量：</p><pre><code> new Ajax.Request(&quot;http://url&quot;, {    method: &quot;get&quot;,    onSuccess: function(transport) {    var json = transport.responseText.evalJSON();    // TODO: document.write(json.xxx);  } });</code></pre><p> #服务器端输出 JSON 格式数据<br> 讲完客户端的JSON处理，接下来到服务端的处理<br> 下面我们讨论如何在服务器端输出 JSON 格式的数据。以 Java 为例，我们将演示将一个 Java 对象编码为 JSON 格式的文本。<br>将 String 对象编码为 JSON 格式时，只需处理好特殊字符即可。另外，必须用 (“) 而非 (‘) 表示字符串：</p><pre><code>static String string2Json(String s) {   StringBuilder sb = new StringBuilder(s.length()+20);   sb.append(&apos;\&quot;&apos;);   for (int i=0; i&lt;s.length(); i++) {    char c = s.charAt(i);    switch (c) {    case &apos;\&quot;&apos;:        sb.append(&quot;\\\&quot;&quot;);        break;    case &apos;\\&apos;:        sb.append(&quot;\\\\&quot;);        break;    case &apos;/&apos;:        sb.append(&quot;\\/&quot;);        break;    case &apos;\b&apos;:        sb.append(&quot;\\b&quot;);        break;    case &apos;\f&apos;:        sb.append(&quot;\\f&quot;);        break;    case &apos;\n&apos;:        sb.append(&quot;\\n&quot;);        break;    case &apos;\r&apos;:        sb.append(&quot;\\r&quot;);        break;    case &apos;\t&apos;:        sb.append(&quot;\\t&quot;);        break;    default:        sb.append(c);    }   }   sb.append(&apos;\&quot;&apos;);   return sb.toString(); }</code></pre><p>将 Number 表示为 JSON 就容易得多，利用 Java 的多态，我们可以处理 Integer，Long，Float 等多种 Number 格式：</p><pre><code>static String number2Json(Number number) {     return number.toString(); }</code></pre><p>Boolean 类型也可以直接通过 toString() 方法得到 JSON 的表示：</p><pre><code>static String boolean2Json(Boolean bool) {     return bool.toString(); }</code></pre><p>要将数组编码为 JSON 格式，可以通过循环将每一个元素编码出来：</p><pre><code>static String array2Json(Object[] array) {   if (array.length==0)     return &quot;[]&quot;;   StringBuilder sb = new StringBuilder(array.length &lt;&lt; 4);   sb.append(&apos;[&apos;);   for (Object o : array) {     sb.append(toJson(o));     sb.append(&apos;,&apos;);   }   // 将最后添加的 &apos;,&apos; 变为 &apos;]&apos;:   sb.setCharAt(sb.length()-1, &apos;]&apos;);   return sb.toString(); }</code></pre><p>最后，我们需要将 Map&lt;String, Object&gt; 编码为 JSON 格式，因为 JavaScript 的 Object 实际上对应的是 Java 的 Map&lt;String, Object&gt; 。该方法如下：</p><pre><code>static String map2Json(Map&lt;String, Object&gt; map) {    if (map.isEmpty())       return &quot;{}&quot;;    StringBuilder sb = new StringBuilder(map.size() &lt;&lt; 4);    sb.append(&apos;{&apos;);    Set&lt;String&gt; keys = map.keySet();    for (String key : keys) {        Object value = map.get(key);        sb.append(&apos;\&quot;&apos;);        sb.append(key);        sb.append(&apos;\&quot;&apos;);        sb.append(&apos;:&apos;);        sb.append(toJson(value));        sb.append(&apos;,&apos;);    }    // 将最后的 &apos;,&apos; 变为 &apos;}&apos;:    sb.setCharAt(sb.length()-1, &apos;}&apos;);    return sb.toString(); }</code></pre><p>为了统一处理任意的 Java 对象，我们编写一个入口方法 toJson(Object)，能够将任意的 Java 对象编码为 JSON 格式：</p><pre><code>public static String toJson(Object o) {   if (o==null)      return &quot;null&quot;;   if (o instanceof String)      return string2Json((String)o);   if (o instanceof Boolean)      return boolean2Json((Boolean)o);   if (o instanceof Number)      return number2Json((Number)o);   if (o instanceof Map)      return map2Json((Map&lt;String, Object&gt;)o);   if (o instanceof Object[])      return array2Json((Object[])o);   throw new RuntimeException(&quot;Unsupported type: &quot; + o.getClass().getName()); }</code></pre><p>我们并未对 Java 对象作严格的检查。不被支持的对象（例如 List）将直接抛出 RuntimeException 。此外，为了保证输出的 JSON 是有效的，Map&lt;String, Object&gt; 对象的 Key 也不能包含特殊字符。细心的读者可能还会发现循环引用的对象会引发无限递归，例如，精心构造一个循环引用的 Map，就可以检测到 StackOverflowException：</p><pre><code>@Test(expected=StackOverflowError.class) public void testRecurrsiveMap2Json() {    Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();    map.put(&quot;key&quot;, map);    JsonUtil.map2Json(map); }</code></pre><p>好在服务器处理的 JSON 数据最终都应该转化为简单的 JavaScript 对象，因此，递归引用的可能性很小。<br>最后，通过 Servlet 或 MVC 框架输出 JSON 时，需要设置正确的 MIME 类型（application/json）和字符编码。假定服务器使用 UTF-8 编码，则可以使用以下代码输出编码后的 JSON 文本：</p><pre><code>response.setContentType(&quot;application/json;charset=UTF-8&quot;); response.setCharacterEncoding(&quot;UTF-8&quot;); PrintWriter pw = response.getWriter(); pw.write(JsonUtil.toJson(obj)); pw.flush();</code></pre><p>JSON 已经是 JavaScript 标准的一部分。目前，主流的浏览器对 JSON 支持都非常完善。应用 JSON，我们可以从 XML 的解析中摆脱出来，对那些应用 Ajax 的 Web 2.0 网站来说，JSON 确实是目前最灵活的轻量级方案。</p><p>#关于作者#</p><p>关于python的学习，可以借鉴这个作家的网络教程来看<br>廖雪峰，十年软件开发经验，业余产品经理，精通Java/Python/Ruby/Scheme/Objective C等，对开源框架有深入研究，著有《Spring 2.0核心技术与最佳实践》一书，多个业余开源项目托管在GitHub</p><p><a href="https://github.com/michaelliao" target="_blank" rel="noopener">https://github.com/michaelliao</a></p><hr><p>JSON技术的调研报告</p><p>一 、各个JSON技术的简介和优劣<br>1.json-lib<br>json-lib最开始的也是应用最广泛的json解析工具，json-lib 不好的地方确实是依赖于很多第三方包，<br>包括commons-beanutils.jar，commons-collections-3.2.jar，commons-lang-2.6.jar，commons-logging-1.1.1.jar，ezmorph-1.0.6.jar，<br>对于复杂类型的转换，json-lib对于json转换成bean还有缺陷，比如一个类里面会出现另一个类的list或者map集合，json-lib从json到bean的转换就会出现问题。<br>json-lib在功能和性能上面都不能满足现在互联网化的需求。<br>2.开源的Jackson<br>相比json-lib框架，Jackson所依赖的jar包较少，简单易用并且性能也要相对高些。<br>而且Jackson社区相对比较活跃，更新速度也比较快。<br>Jackson对于复杂类型的json转换bean会出现问题，一些集合Map，List的转换出现问题。<br>Jackson对于复杂类型的bean转换Json，转换的json格式不是标准的Json格式<br>3.Google的Gson<br>Gson是目前功能最全的Json解析神器，Gson当初是为因应Google公司内部需求而由Google自行研发而来，<br>但自从在2008年五月公开发布第一版后已被许多公司或用户应用。<br>Gson的应用主要为toJson与fromJson两个转换函数，无依赖，不需要例外额外的jar，能够直接跑在JDK上。<br>而在使用这种对象转换之前需先创建好对象的类型以及其成员才能成功的将JSON字符串成功转换成相对应的对象。<br>类里面只要有get和set方法，Gson完全可以将复杂类型的json到bean或bean到json的转换，是JSON解析的神器。<br>Gson在功能上面无可挑剔，但是性能上面比FastJson有所差距。<br>4.阿里巴巴的FastJson<br>Fastjson是一个Java语言编写的高性能的JSON处理器,由阿里巴巴公司开发。<br>无依赖，不需要例外额外的jar，能够直接跑在JDK上。<br>FastJson在复杂类型的Bean转换Json上会出现一些问题，可能会出现引用的类型，导致Json转换出错，需要制定引用。<br>FastJson采用独创的算法，将parse的速度提升到极致，超过所有json库。</p><p>综上4种Json技术的比较，在项目选型的时候可以使用Google的Gson和阿里巴巴的FastJson两种并行使用，<br>如果只是功能要求，没有性能要求，可以使用google的Gson，<br>如果有性能上面的要求可以使用Gson将bean转换json确保数据的正确，使用FastJson将Json转换Bean<br>二、Google的Gson包的使用简介。<br>Gson类：解析json的最基础的工具类<br>JsonParser类：解析器来解析JSON到JsonElements的解析树<br>JsonElement类：一个类代表的JSON元素<br>JsonObject类：JSON对象类型<br>JsonArray类：JsonObject数组<br>TypeToken类：用于创建type，比如泛型List&lt;?&gt;<br>(1)maven依赖</p><p>com.google.code.gson<br>gson<br>2.2.4</p><p>(2)基础转换类<br>    public class Book{<br>    private String id;<br>    private String name;<br>    public Book() {<br>    super();<br>    }<br>    public String getId() {<br>    return id;<br>    }<br>    public void setId(String id) {<br>    this.id = id;<br>    }<br>    public String getName() {<br>    return name;<br>    }<br>    public void setName(String name) {<br>    this.name = name;<br>    }<br>    }<br>    public class Student{<br>    private String name;<br>    private int age;<br>    private String sex;<br>    private String describe;<br>    private Set books;<br>    public Student() {<br>    super();<br>    }<br>    public String getName() {<br>    return name;<br>    }<br>    public void setName(String name) {<br>    this.name = name;<br>    }<br>    public int getAge() {<br>    return age;<br>    }<br>    public void setAge(int age) {<br>    this.age = age;<br>    }<br>    public String getSex() {<br>    return sex;<br>    }<br>    public void setSex(String sex) {<br>    this.sex = sex;<br>    }<br>    public Set getBooks() {<br>    return books;<br>    }<br>    public void setBooks(Set books) {<br>    this.books = books;<br>    }<br>    public String getDescribe() {<br>    return describe;<br>    }<br>    public void setDescribe(String describe) {<br>    this.describe = describe;<br>    }<br>    }<br>(3)bean转换json<br>    Gson gson = new Gson();<br>    String json = gson.toJson(obj);<br>obj是对象<br>(4)json转换bean<br>    Gson gson = new Gson();<br>    String json = “{\”id\”:\”2\”,\”name\”:\”Json技术\”}”;<br>    Book book = gson.fromJson(json, Book.class);<br>(5)json转换复杂的bean，比如List，Set<br>将json转换成复杂类型的bean,需要使用TypeToken<br>    Gson gson = new Gson();<br>    String json = “[{\”id\”:\”1\”,\”name\”:\”Json技术\”},{\”id\”:\”2\”,\”name\”:\”java技术\”}]”;<br>//将json转换成List<br>    List list = gson.fromJson(json,new TypeToken<list>() {}.getType());<br>//将json转换成Set<br>    Set set = gson.fromJson(json,new TypeToken<set>() {}.getType());<br>(6)通过json对象直接操作json以及一些json的工具<br>a)格式化Json<br>    String json = “[{\”id\”:\”1\”,\”name\”:\”Json技术\”},{\”id\”:\”2\”,\”name\”:\”java技术\”}]”;<br>    Gson gson = new GsonBuilder().setPrettyPrinting().create();<br>    JsonParser jp = new JsonParser();<br>    JsonElement je = jp.parse(json);<br>    json = gson.toJson(je);<br>b)判断字符串是否是json,通过捕捉的异常来判断是否是json<br>    String json = “[{\”id\”:\”1\”,\”name\”:\”Json技术\”},{\”id\”:\”2\”,\”name\”:\”java技术\”}]”;<br>    boolean jsonFlag;<br>    try {<br>    new JsonParser().parse(str).getAsJsonObject();<br>    jsonFlag = true;<br>    } catch (Exception e) {<br>    jsonFlag = false;<br>    }<br>c)从json串中获取属性<br>    String json = “{\”id\”:\”1\”,\”name\”:\”Json技术\”}”;<br>    String propertyName = ‘id’;<br>    String propertyValue = “”;<br>    try {<br>    JsonParser jsonParser = new JsonParser();<br>    JsonElement element = jsonParser.parse(json);<br>    JsonObject jsonObj = element.getAsJsonObject();<br>    propertyValue = jsonObj.get(propertyName).toString();<br>    } catch (Exception e) {<br>    propertyValue = null;<br>    }<br>d)除去json中的某个属性<br>    String json = “{\”id\”:\”1\”,\”name\”:\”Json技术\”}”;<br>    String propertyName = ‘id’;<br>    JsonParser jsonParser = new JsonParser();<br>    JsonElement element = jsonParser.parse(json);<br>    JsonObject jsonObj = element.getAsJsonObject();<br>    jsonObj.remove(propertyName);<br>    json = jsonObj.toString();<br>e)向json中添加属性<br>    String json = “{\”id\”:\”1\”,\”name\”:\”Json技术\”}”;<br>    String propertyName = ‘desc’;<br>    Object propertyValue = “json各种技术的调研”;<br>    JsonParser jsonParser = new JsonParser();<br>    JsonElement element = jsonParser.parse(json);<br>    JsonObject jsonObj = element.getAsJsonObject();<br>    jsonObj.addProperty(propertyName, new Gson().toJson(propertyValue));<br>    json = jsonObj.toString();<br>f)修改json中的属性<br>    String json = “{\”id\”:\”1\”,\”name\”:\”Json技术\”}”;<br>    String propertyName = ‘name’;<br>    Object propertyValue = “json各种技术的调研”;<br>    JsonParser jsonParser = new JsonParser();<br>    JsonElement element = jsonParser.parse(json);<br>    JsonObject jsonObj = element.getAsJsonObject();<br>    jsonObj.remove(propertyName);<br>    jsonObj.addProperty(propertyName, new Gson().toJson(propertyValue));<br>    json = jsonObj.toString();<br>g)判断json中是否有属性<br>    String json = “{\”id\”:\”1\”,\”name\”:\”Json技术\”}”;<br>    String propertyName = ‘name’;<br>    boolean isContains = false ;<br>    JsonParser jsonParser = new JsonParser();<br>    JsonElement element = jsonParser.parse(json);<br>    JsonObject jsonObj = element.getAsJsonObject();<br>    isContains = jsonObj.has(propertyName);<br>h)json中日期格式的处理<br>    GsonBuilder builder = new GsonBuilder();<br>    builder.setDateFormat(“yyyy-MM-dd HH:mm:ss.SSS”);<br>    Gson gson = builder.create();<br>然后使用gson对象进行json的处理，如果出现日期Date类的对象，就会按照设置的格式进行处理<br>i)json中对于Html的转义<br>    Gson gson = new Gson();<br>这种对象默认对Html进行转义，如果不想转义使用下面的方法<br>    GsonBuilder builder = new GsonBuilder();<br>    builder.disableHtmlEscaping();<br>    Gson gson = builder.create();<br>三、阿里巴巴的FastJson包的使用简介。<br>(1)maven依赖</set></list></p><p>com.alibaba<br>fastjson<br>1.1.22</p><p>(2)基础转换类<br>同上<br>(3)bean转换json<br>将对象转换成格式化的json<br>    JSON.toJSONString(obj,true);<br>将对象转换成非格式化的json<br>    JSON.toJSONString(obj,false);<br>obj设计对象<br>对于复杂类型的转换,对于重复的引用在转成json串后在json串中出现引用的字符,比如 $ref”:”$[0].books[1]<br>    Student stu = new Student();<br>    Set books= new HashSet();<br>    Book book = new Book();<br>    books.add(book);<br>    stu.setBooks(books);<br>    List list = new ArrayList();<br>    for(int i=0;i&lt;5;i++)<br>    list.add(stu);<br>    String json = JSON.toJSONString(list,true);<br>(4)json转换bean<br>    String json = “{\”id\”:\”2\”,\”name\”:\”Json技术\”}”;<br>    Book book = JSON.parseObject(json, Book.class);<br>(5)json转换复杂的bean，比如List，Map<br>    String json = “[{\”id\”:\”1\”,\”name\”:\”Json技术\”},{\”id\”:\”2\”,\”name\”:\”java技术\”}]”;<br>//将json转换成List<br>    List list = JSON.parseObject(json,new TypeReference<arraylist>(){});<br>//将json转换成Set<br>    Set set = JSON.parseObject(json,new TypeReference<hashset>(){});<br>(6)通过json对象直接操作json<br>a)从json串中获取属性<br>    String propertyName = ‘id’;<br>    String propertyValue = “”;<br>    String json = “{\”id\”:\”1\”,\”name\”:\”Json技术\”}”;<br>    JSONObject obj = JSON.parseObject(json);<br>    propertyValue = obj.get(propertyName));<br>b)除去json中的某个属性<br>    String propertyName = ‘id’;<br>    String propertyValue = “”;<br>    String json = “{\”id\”:\”1\”,\”name\”:\”Json技术\”}”;<br>    JSONObject obj = JSON.parseObject(json);<br>    Set set = obj.keySet();<br>    propertyValue = set.remove(propertyName);<br>    json = obj.toString();<br>c)向json中添加属性<br>    String propertyName = ‘desc’;<br>    Object propertyValue = “json的玩意儿”;<br>    String json = “{\”id\”:\”1\”,\”name\”:\”Json技术\”}”;<br>    JSONObject obj = JSON.parseObject(json);<br>    obj.put(propertyName, JSON.toJSONString(propertyValue));<br>    json = obj.toString();<br>d)修改json中的属性<br>    String propertyName = ‘name’;<br>    Object propertyValue = “json的玩意儿”;<br>    String json = “{\”id\”:\”1\”,\”name\”:\”Json技术\”}”;<br>    JSONObject obj = JSON.parseObject(json);<br>    Set set = obj.keySet();<br>    if(set.contains(propertyName))<br>    obj.put(propertyName, JSON.toJSONString(propertyValue));<br>    json = obj.toString();<br>e)判断json中是否有属性<br>    String propertyName = ‘name’;<br>    boolean isContain = false;<br>    String json = “{\”id\”:\”1\”,\”name\”:\”Json技术\”}”;<br>    JSONObject obj = JSON.parseObject(json);<br>    Set set = obj.keySet();<br>    isContain = set.contains(propertyName);<br>f)json中日期格式的处理<br>    Object obj = new Date();<br>    String json = JSON.toJSONStringWithDateFormat(obj, “yyyy-MM-dd HH:mm:ss.SSS”);<br>使用JSON.toJSONStringWithDateFormat,该方法可以使用设置的日期格式对日期进行转换</hashset></arraylist></p><p>三、json-lib包的使用简介。<br>(1)maven依赖</p><p>net.sf.json-lib<br>json-lib<br>jdk15<br>2.2.2</p><p>commons-beanutils<br>commons-beanutils<br>1.8.3</p><p>commons-collections<br>commons-collections<br>3.2</p><p>commons-lang<br>commons-lang<br>2.6</p><p>commons-logging<br>commons-logging<br>1.1.1 </p><p>net.sf.ezmorph<br>ezmorph<br>1.0.6</p><p>(2)基础转换类<br>同上<br>(3)bean转换json<br>a)将类转换成Json,obj是普通的对象，不是List，Map的对象<br>    String json = JSONObject.fromObject(obj).toString();<br>b)将List，Map转换成Json<br>    String json = JSONArray.fromObject(list).toString();<br>    String json = JSONArray.fromObject(map).toString();<br>(4)json转换bean<br>    String json = “{\”id\”:\”1\”,\”name\”:\”Json技术\”}”;<br>    JSONObject jsonObj = JSONObject.fromObject(json);<br>    Book book = (Book)JSONObject.toBean(jsonObj,Book.class);<br>(5)json转换List,对于复杂类型的转换会出现问题<br>    String json = “[{\”id\”:\”1\”,\”name\”:\”Json技术\”},{\”id\”:\”2\”,\”name\”:\”Java技术\”}]”;<br>    JSONArray jsonArray = JSONArray.fromObject(json);<br>    JSONObject jsonObject;<br>    T bean;<br>    int size = jsonArray.size();<br>    List list = new ArrayList(size);<br>    for (int i = 0; i &lt; size; i++) {<br>    jsonObject = jsonArray.getJSONObject(i);<br>    bean = (T) JSONObject.toBean(jsonObject, beanClass);<br>    list.add(bean);<br>    }<br>(6)json转换Map<br>    String jsonString = “{\”id\”:\”1\”,\”name\”:\”Json技术\”}”;<br>    JSONObject jsonObject = JSONObject.fromObject(jsonString);<br>    Iterator keyIter = jsonObject.keys();<br>    String key;<br>    Object value;<br>    Map valueMap = new HashMap();<br>    while (keyIter.hasNext()) {<br>    key = (String) keyIter.next();<br>    value = jsonObject.get(key).toString();<br>    valueMap.put(key, value);<br>    }<br>(7)json对于日期的操作比较复杂，需要使用JsonConfig,比Gson和FastJson要麻烦多了<br>创建转换的接口实现类，转换成指定格式的日期<br>    class DateJsonValueProcessor implements JsonValueProcessor{<br>    public static final String DEFAULT_DATE_PATTERN = “yyyy-MM-dd HH:mm:ss.SSS”;<br>    private DateFormat dateFormat;<br>    public DateJsonValueProcessor(String datePattern) {<br>    try {<br>    dateFormat = new SimpleDateFormat(datePattern);<br>    } catch (Exception ex) {<br>    dateFormat = new SimpleDateFormat(DEFAULT_DATE_PATTERN);<br>    }<br>    }<br>    public Object processArrayValue(Object value, JsonConfig jsonConfig) {<br>    return process(value);<br>    }<br>    public Object processObjectValue(String key, Object value,<br>    JsonConfig jsonConfig) {<br>    return process(value);<br>    }<br>    private Object process(Object value) {<br>    return dateFormat.format[1];<br>    Map&lt;STRING,DATE&gt; birthDays = new HashMap&lt;STRING,DATE&gt;();<br>    birthDays.put(“WolfKing”,new Date());<br>    JSONObject jsonObject = JSONObject.fromObject(birthDays, jsonConfig);<br>    String json = jsonObject.toString();<br>    System.out.println(json);<br>    }<br>    }<br>(8)JsonObject 对于json的操作和处理<br>a)从json串中获取属性<br>    String jsonString = “{\”id\”:\”1\”,\”name\”:\”Json技术\”}”;<br>    Object key = “name”;<br>    Object value = null;<br>    JSONObject jsonObject = JSONObject.fromObject(jsonString);<br>    value = jsonObject.get(key);<br>    jsonString = jsonObject.toString();<br>b)除去json中的某个属性<br>    String jsonString = “{\”id\”:\”1\”,\”name\”:\”Json技术\”}”;<br>    Object key = “name”;<br>    Object value = null;<br>    JSONObject jsonObject = JSONObject.fromObject(jsonString);<br>    value = jsonObject.remove(key);<br>    jsonString = jsonObject.toString();<br>c)向json中添加和修改属性，有则修改，无则添加<br>    String jsonString = “{\”id\”:\”1\”,\”name\”:\”Json技术\”}”;<br>    Object key = “desc”;<br>    Object value = “json的好东西”;<br>    JSONObject jsonObject = JSONObject.fromObject(jsonString);<br>    jsonObject.put(key,value);<br>    jsonString = jsonObject.toString();<br>d)判断json中是否有属性<br>    String jsonString = “{\”id\”:\”1\”,\”name\”:\”Json技术\”}”;<br>    boolean containFlag = false;<br>    Object key = “desc”;<br>    JSONObject jsonObject = JSONObject.fromObject(jsonString);<br>    containFlag = jsonObject.containsKey(key);</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JSON是什么？&quot;&gt;&lt;a href=&quot;#JSON是什么？&quot; class=&quot;headerlink&quot; title=&quot;JSON是什么？&quot;&gt;&lt;/a&gt;JSON是什么？&lt;/h1&gt;&lt;p&gt;尽管有许多宣传关于 XML 如何拥有跨平台，跨语言的优势，然而，除非应用于 Web Services，否则，在普通的 Web 应用中，开发者经常为 XML 的解析伤透了脑筋，无论是服务器端生成或处理 XML，还是客户端用 JavaScript 解析 XML，都常常导致复杂的代码，极低的开发效率。实际上，对于大多数 Web 应用来说，他们根本不需要复杂的 XML 来传输数据，XML 的扩展性很少具有优势，许多 AJAX 应用甚至直接返回 HTML 片段来构建动态 Web 页面。和返回 XML 并解析它相比，返回 HTML 片段大大降低了系统的复杂性，但同时缺少了一定的灵活性。&lt;/p&gt;
&lt;p&gt;现在， JSON 为 Web 应用开发者提供了另一种数据交换格式。让我们来看看 JSON 到底是什么，同 XML 或 HTML 片段相比，JSON 提供了更好的简单性和灵活性。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="java类库" scheme="http://yoursite.com/tags/java%E7%B1%BB%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>HEXO技巧分享--markdown语法归纳</title>
    <link href="http://yoursite.com/2018/03/07/hexo-tech3/"/>
    <id>http://yoursite.com/2018/03/07/hexo-tech3/</id>
    <published>2018-03-07T02:30:44.000Z</published>
    <updated>2018-03-07T03:28:16.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-Markdown"><a href="#什么是-Markdown" class="headerlink" title="什么是 Markdown"></a>什么是 Markdown</h1><p><img src="/2018/03/07/hexo-tech3/timg.jpg" alt="logo"></p><a id="more"></a><p>感谢大佬写得非常好的新手指南</p><blockquote><p>引用自简书的<a href="https://www.jianshu.com/p/q81RER" target="_blank" rel="noopener">https://www.jianshu.com/p/q81RER</a></p></blockquote><p>Markdown 是一种「电子邮件」风格的「标记语言」<br>什么是 Markdown？简单地说，它就是一种语法，一门适合用于写作的简单语言。用过 Markdown 的人都知道，它的高效在于能有效避免不规范的行高、行距、首行缩紧等格式要求，以及繁乱复杂的字体，这样用户就能专注于写作本身，抛开杂项带来的烦恼。如果你从来没用过 Markdown，那我可以非常明确地告诉你——学习入门级的 Markdown 用法只需要 10 分钟，就足够了！<br>在此，我们总结 Markdown 的优点如下：</p><ul><li>纯文本，所以兼容性极强，可以用所有文本编辑器打开。</li><li>让你专注于文字而不是排版。</li><li>格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。</li><li>Markdown 的标记语法有极好的可读性。</li></ul><p>要开始 Markdown 的写作，首先要找到一款适合自己的 Markdown 编辑器工具。下面三篇文章详细介绍了各个平台（Win，Mac，iOS，Android）上优秀的 Markdown 编辑器，可以根据自己的喜好和经济能力选择一个或几个：</p><p>在这篇“解决作者们的焦虑：7 款优秀 Markdown 编辑工具推荐”中总结一些使用率高的md编辑工具</p><blockquote><p>传送门 <a href="https://sspai.com/post/27792" target="_blank" rel="noopener">https://sspai.com/post/27792</a></p></blockquote><p>那么 Markdown 是通过什么方法去避免发生这些问题的呢？答案其实也并没有那么复杂，通俗地说就俩字：转码。</p><p>是的，不要单纯地以为只有多媒体文件才能用「转码」形容，在计算机的世界里，任何东西都不是我们肉眼凡胎，直接看到的那个样子。比如说文字，从像素到一个完整的字体库，期间经历的是数不尽的设计、再设计，再加上软件工程及硬件工程的完美协作，最终才能获得一个在计算机中最常见的元素：文字。</p><p>而在文字创作领域，Markdown 的作用就是把一篇纯文本文章转换为 富文本，让读者得到清晰明了的阅读体验。当然，由于各平台对于「格式」的兼容性不同，有时也会发生一些不那么「友善」的事情。比如用 OS X 上的 Chrome 浏览器阅读「两端对齐」格式的文章时，为了符合要求，在遇到中英文交替出现的段落，很有可能导致「大空格」现象的发生，继而在一定程度上影响了读者的阅读体验，但 OS X 的 Safari 和 Windows 的 IE 就可以轻松避免。所以针对这种问题，你既可以理解为这是 Markdown 转码富文本的不够完善，也能看作是浏览器的兼容性问题。总之，在这个越来越多人选择自己写文章的年代，Markdown 语法一定是该群体独一无二的选择。</p><p>有了想法，接下来要做的就是付诸实践，而这其中，最让人头疼的问题就是 Markdown 编辑器的选择，因为有的人喜欢在移动平台上创作文字，比如 iPhone、iPad 等，但更多的人会选择在（便携式）电脑上完成这项工作。说实话，我个人属于电脑撰稿用户，理由很简单：</p><p>第一，就目前而言，虚拟键盘在文字输入的体验上远不及实体键盘来得有效率。<br>第二，支持的格式范围广，保存、导出、备份、发布的方法简单又便捷。<br>第三，大多数人在使用电脑时，周围的场景会是家里、办公室、咖啡厅、图书馆，至少不会是非常吵闹的地方，这样有助于保持专注的思维；而习惯用手机码字的人，很多都是因为受到环境的限制，不得已出此下策，而非「情怀」作祟。<br>或许现在的你有千万种理由可以反驳我，但本文的目的不在于此，只是要分享 7 款我使用过，及正在使用的 Markdown 编辑器，它们有不同的分类、定位、售价，也涵盖了 Mac、iOS、Windows 平台，它们都是让笔者留下深刻印象的选择。所以，为了尽可能避免「独立观点」的干扰，希望大家以技术探讨为优先，相互推荐更多、更有价值的选择。</p><h2 id="Ulysses"><a href="#Ulysses" class="headerlink" title="Ulysses"></a>Ulysses</h2><p>一款由国外开发商 The Soulmen 制作的 Markdown 编辑器。与其它同类应用相比，Ulysses 最大的不同在于，它能根据内置的文件管理器，以及与 iCloud 云服务器的实时同步方案，达到最快捷的文章整理效率。这么说可能不够细致，那我们不妨简单试想一下：当你正在写一篇文章，突然由于外在原因（比如出门），干扰了原本的写作计划，那么很有可能也就同时打断了思路，继而最终影响到文章的完成。对于作者而言，这丝毫不亚于「冬天洗澡没热水」的混蛋事，但你又能怎么办呢？</p><p>所以，云同步的好处在此时就能体现出来了！记得 乔布斯 在刚回归苹果的一次开发者大会演讲上，着重强调了「云」在未来计算机发展领域的重要性。在综合现代环境的因素，我得出了以下结论：</p><p>如果有一天，我们电脑里的数据可以随时保存在云端服务器，并做到随用随取，那么就可以解决当下科技领域几大严重的先天缺陷，第一，设备丢失导致的数据损失；第二，使用内置硬盘带来无法避免的厚度和重量，导致便携式电脑的「便携性」降低；第三，不同的数据转换方式，导致文件结构的分裂，继而影响到操作系统的稳定性和数据相关行为的有效性。</p><p>话虽如此，但要具体的实现，还需要等到全球网络环境的大进步，软硬件水准提升到相当高的阶段才行。不过，在当下数不尽的解决方案面前，我认为 Apple 作了一个不算最好，但合理可行的选择：iCloud。iCloud 是个涉及领域颇广的话题，这里不适合分类讨论，读者请自行联想，但针对 Markdown 编辑器，我认为及时的云同步确实可以部分实现上文提到的目标，即数据找回、随用随取、多平台覆盖等。这就是我推荐 Ulysses 的理由。</p><h2 id="Byword"><a href="#Byword" class="headerlink" title="Byword"></a>Byword</h2><p>一款轻量级的 Markdown 编辑器，人称 Markdown 写作新手的必选，不过我个人不是非常同意这一观点。回想较早面世的几款 Markdown 工具，大多都会加入「实时预览」特性，（笔者推测）这是因为当时的 Markdown 语法还没有形成一个合理规范的体系，这些应用的开发者为了保证用户体验，不得已而加入了这一特性，可在此之后，大多数 Markdown 编辑器则又都反其道而行之（例如本文的介绍对象 Ulysses，Byword 和 Typed），这不禁要引起用户的怀疑：难道「实时预览」不是 Markdown 编辑器应有的功能？当然不是，因为这类应用的目的就是要帮助作者生产出高质量的文章，也就是说，只要你会写，并且能通过 Markdown 来完成自己的工作，这就足够了，与选择 Markdown 编辑器无关，与用户能力的强弱无关！所以我的观点非常简单：能达到目的的应用就是好应用。</p><p>开发商除了制作 Mac 平台的版本，同样也带来了 iOS 客户端。很多人建议已经在使用 Byword for Mac 的人应该首选 Byword for iOS 而不是其它（可能更好的）编辑器，是因为它能经由 OS X 10.10 Handoff 特性实现文档编辑环境的无缝切换，这种畅快淋漓的感觉是无法在不同的应用间体验到的。</p><h2 id="Mou"><a href="#Mou" class="headerlink" title="Mou"></a>Mou</h2><p>一款由国人独立开发者 罗晨 开发的实时预览型 Markdown 编辑器，也因此成为（目前）同类应用中，对汉字兼容性最好的代表作。不信？你一用便知。反过来讲，要论它有多人性化，我有点说不上来，毕竟每个人都有自己的偏好、习惯和审视角度，任何文章作者都不能以偏概全，但有一点是为大众认可的——Mou 是目前最好用的免费 Markdown 编辑器，没有之一！顺便也恭喜下不久前 Mou 1.0 版本开发资金的成功众筹，也衷心希望国内能有更多靠个人实力登上国际舞台的独立开发者。罗晨，好样的！</p><h2 id="Typed"><a href="#Typed" class="headerlink" title="Typed"></a>Typed</h2><p>一款由国外软件开发商 Realmac 制作的 Markdown 编辑器，于 2014 年 12 月份刚刚发布。对于这款应用，笔者的评价是：噱头大于亮点。这么说可能有些刻薄，但我却丝毫没有自己有一张「毒舌」的感觉，因为事实即是如此。在看了其特性列表后，大多数人都认为 Typed 的最大亮点就在于 Zen Mode（姑且解释为「禅模式」），号称能让用户更加专注于写作，而实际体验下来我发现，这一功能倒不如形容为「背景音乐播放」来得直接，因为它只是用来播放一些从自然界采集到的声音（例如鸟鸣、水流、风刮、雨打），但我却丝毫没有从中体会到写作应有的环境氛围。个人认为，码字就是要安安静静，才能更全面地发挥逻辑思维和想象空间，以进一步充实文章的内涵，保证内容的连贯有序，提高可读性。安静，是一个要求相当高的环境，不是所谓的「自然之声」就能做到，或者说弥补得了的。如果您同意笔者的愚见，那么从现在起，我建议读者不要（再）相信任何带有类似「禅模式」功能的写作工具，都是忽悠人的！否则，烦请三思而后行呀。</p><h2 id="Sublime-Text-3"><a href="#Sublime-Text-3" class="headerlink" title="Sublime Text 3"></a>Sublime Text 3</h2><p>一款基于 Vim 开发的跨平台代码编辑器，支持 OS X、Windows、Ubuntu 等 UNIX 及 Linux 操作系统，并由于其功能的多样性而广受好评，在代码工作者圈内相当出名！关于 Vim，《MacTalk 人生元编程》一书的作者 @池建强 是这么评价的：</p><p>操作系统、编程语言和编辑器是程序员永恒的吐槽话题，技术发展了几十年，争论起来依然是「此恨绵绵无绝期」。在本文编辑器领域，Vim 和 Emacs 是永恒的焦点。Vim 号称编辑器之神，Emacs 则是神的编辑器；Vim 编程唯快不破，插件遍天下，Emacs 则宣称自己是伪装成文本编辑器的操作系统。</p><p>既然是「神的编辑器」，那么基于它开发的 Sublime Text 又会有怎样的表现呢？仅目前来看，它原生支持的编程语言就能多达十几种，其中包括大家熟知的 C、C++、C#、Objective-C、AppleScript、HTML、Java、Python 等。通过第三方插件，Sublime Text 还能实现更多语法的支持，这之中的代表就是 Markdown。其实，Sublime Text 在老版本中就已经支持 Markdown 了，但苦于没有像样的「预览」功能，其用户大多只是通过一种叫 Markdown Preview 的插件实现对 Markdown 的预览，而且还必须要有浏览器的支持。所以，笔者不推荐大家首选 Sublime Text 作为 Markdown 编辑器，但如果读者已经是一名代码工作者，并且正在使用它，那么考虑到这部分群体的使用习惯和口味，将就着用也是可以的。</p><h2 id="Editorial"><a href="#Editorial" class="headerlink" title="Editorial"></a>Editorial</h2><p>一款 iOS 平台上支持 Workflow 的纯文本编辑器。论性质，倒确实与 Sublime Text 有那么几分相似，因为它也支持脚本代码的编译，比如说 Python。但这并不属于本文的介绍对象。更让我印象深刻的是它对 Markdown 语法的支持，主题体现在这三方面：界面、键盘和预览模式。</p><p>Editorial 的界面非常简洁，完全是按照 iOS 7 的扁平化风格设计的，可不少人在 App Store 中第一眼看到它的时候，都立刻失去了兴趣，理由竟然是：太单调了！好吧，这让我感到无言以对… 作为一款本文编辑器，尤其是 Markdown 编辑器，应该且必须以文字为核心，其它元素皆为陪衬或补偿，而不是代替前者的价值和意义，所以笔者觉得 Editorial 在用户界面的设计上还是很符合主流需求的。键盘方面，基本的语法符号很全，再配合文字输入辅助应用 TextExpander touch 可以让码字变得更有效率，此外，Editorial 还内置了 Snippets 功能。这是一个相当实用的功能，它可以直接代替 TextExpander touch，实现基于基本语法的输入，举两个简单的例子：[Clipboard] 能提取剪贴板内容，[yyy]-[MM]-[dd] 能提取实时日期等。这方面的例子有很多，这里不做扩展，感兴趣的读者可以自行研究一下。关于「预览」模式，一句话就可以概括：请往左划！</p><h2 id="简书"><a href="#简书" class="headerlink" title="简书"></a>简书</h2><p>不同于上文介绍的对象，简书 是一家由国内初创团队建立的在线文字创作及发布平台，而非客户端，所以相对来说，我更加建议 Windows 用户可以着重考虑一下。仔细想想，其实笔者个人接触它的时间不多，但很快就发现自己已经上瘾了，虽然这其中的因素有很多，可主要还是因为它有两个方面做得非常到位：后台、专题。回顾发展史，简书从一开始就已经支持 Markdown 和富文本编辑，对于像我这样的 Markdown 控而言是绝对的好事！另外，每位作者都可以通过连续撰稿和收集建立自己的专题、文集，甚至是一本看得见也摸得着的纸质作品。所以综合评定下来，它注定就是一个为作者打造的平台。</p><p>摸着良心说，推荐「简书」完全是因为它作为初创团队的成果，能做到如此精良的水准实属不易！就像我喜欢 Mou 一样，只要东西好，无论它来自国人之手，还是「进口」海外，每个人都有选择它的理由。因此我还是那句话，体验过后你就知道了。</p><h1 id="关于MarkDown语法"><a href="#关于MarkDown语法" class="headerlink" title="关于MarkDown语法"></a>关于MarkDown语法</h1><p>点击这里可以看到</p><blockquote><p><a href="https://www.jianshu.com/p/b03a8d7b1719" target="_blank" rel="noopener">https://www.jianshu.com/p/b03a8d7b1719</a><br><a href="https://www.jianshu.com/p/q81RER" target="_blank" rel="noopener">https://www.jianshu.com/p/q81RER</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是-Markdown&quot;&gt;&lt;a href=&quot;#什么是-Markdown&quot; class=&quot;headerlink&quot; title=&quot;什么是 Markdown&quot;&gt;&lt;/a&gt;什么是 Markdown&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2018/03/07/hexo-tech3/timg.jpg&quot; alt=&quot;logo&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo教程" scheme="http://yoursite.com/categories/Hexo%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>区块链技术解读--区块链结构解释</title>
    <link href="http://yoursite.com/2018/03/06/%E5%8C%BA%E5%9D%97%E9%93%BE03/"/>
    <id>http://yoursite.com/2018/03/06/区块链03/</id>
    <published>2018-03-06T14:52:06.000Z</published>
    <updated>2018-03-07T13:30:54.109Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/03/06/区块链03/main.png" alt="logo"></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/03/06/区块链03/main.png&quot; alt=&quot;logo&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="区块链技术" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="数字货币" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81/"/>
    
      <category term="互联网金融" scheme="http://yoursite.com/tags/%E4%BA%92%E8%81%94%E7%BD%91%E9%87%91%E8%9E%8D/"/>
    
  </entry>
  
  <entry>
    <title>区块链技术解读--数字签名</title>
    <link href="http://yoursite.com/2018/03/06/%E5%8C%BA%E5%9D%97%E9%93%BE02/"/>
    <id>http://yoursite.com/2018/03/06/区块链02/</id>
    <published>2018-03-06T09:15:05.000Z</published>
    <updated>2018-03-06T09:36:15.934Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/03/06/区块链02/main.png" alt="logo"></p><a id="more"></a><p>#数字签名#</p><p>数字签名即哈希算法+非对称加密相结合的技术</p><p>百度概念：<br>数字签名（又称公钥数字签名、电子签章）是一种类似写在纸上的普通的物理签名，但是使用了公钥加密领域的技术实现，用于鉴别数字信息的方法。一套数字签名通常定义两种互补的运算，一个用于签名，另一个用于验证。<br>数字签名，就是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。<br>数字签名是非对称密钥加密技术与数字摘要技术的应用。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>数字签名的文件的完整性是很容易验证的（不需要骑缝章，骑缝签名，也不需要笔迹专家），而且数字签名具有不可抵赖性（不需要笔迹专家来验证）。<br>简单地说,所谓数字签名就是附加在数据单元上的一些数据,或是对数据单元所作的密码变换。这种数据或变换允许数据单元的接收者用以确认数据单元的来源和数据单元的完整性并保护数据,防止被人(例如接收者)进行伪造。它是对电子形式的消息进行签名的一种方法,一个签名消息能在一个通信网络中传输。基于公钥密码体制和私钥密码体制都可以获得数字签名,主要是基于公钥密码体制的数字签名。包括普通数字签名和特殊数字签名。普通数字签名算法有RSA、ElGamal、Fiat-Shamir、Guillou- Quisquarter、Schnorr、Ong-Schnorr-Shamir数字签名算法、Des/DSA,椭圆曲线数字签名算法和有限自动机数字签名算法等。特殊数字签名有盲签名、代理签名、群签名、不可否认签名、公平盲签名、门限签名、具有消息恢复功能的签名等,它与具体应用环境密切相关。显然,数字签名的应用涉及到法律问题,美国联邦政府基于有限域上的离散对数问题制定了自己的数字签名标准(DSS)。</p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>保证信息传输的完整性、发送者的身份认证、防止交易中的抵赖发生。<br>数字签名技术是将摘要信息用发送者的私钥加密，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。<br>数字签名是个加密的过程，数字签名验证是个解密的过程。</p><p><img src="/2018/03/06/区块链02/baidu01.png" alt="logo"></p><p>数字签名即哈希算法+非对称加密相结合的技术<br>提到非对称算法就会想到对称算法</p><h2 id="对称算法"><a href="#对称算法" class="headerlink" title="对称算法"></a>对称算法</h2><p>对称密码算法有时又叫传统密码算法，就是加密密钥能够从解密密钥中推算出来，反过来也成立。在大多数对称算法中，加密解密密钥是相同的。这些算法也叫秘密密钥算法或单密钥算法，它要求发送者和接收者在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都能对消息进行加密解密。只要通信需要保密，密钥就必须保密。</p><p>即消息的发送方和接收方都拥有共同的密钥，可以将传递的明文进行解密</p><p><img src="/2018/03/06/区块链02/baidu02.png" alt="logo"></p><h2 id="不对称算法"><a href="#不对称算法" class="headerlink" title="不对称算法"></a>不对称算法</h2><p>不对称加密算法使用两把完全不同但又是完全匹配的一对钥匙—公钥和私钥。在使用不对称加密算法加密文件时，只有使用匹配的一对公钥和私钥，才能完成对明文的加密和解密过程。</p><p>加密明文时采用公钥加密，解密密文时使用私钥才能完成，而且发信方（加密者）知道收信方的公钥，只有收信方（解密者）才是唯一知道自己私钥的人。不对称加密算法的基本原理是，如果发信方想发送只有收信方才能解读的加密信息，发信方必须首先知道收信方的公钥，然后利用收信方的公钥来加密原文；收信方收到加密密文后，使用自己的私钥才能解密密文。显然，采用不对称加密算法，收发信双方在通信之前，收信方必须将自己早已随机生成的公钥送给发信方，而自己保留私钥。由于不对称算法拥有两个密钥，因而特别适用于分布式系统中的数据加密。广泛应用的不对称加密算法有RSA算法和美国国家标准局提出的DSA。</p><h3 id="与对称加密算法的不同"><a href="#与对称加密算法的不同" class="headerlink" title="与对称加密算法的不同"></a>与对称加密算法的不同</h3><p>与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私 有 密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加 密，只有用对应的私有密钥才能解密；因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。 非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。甲方只能用其专用密钥解密由其公用密钥加密后的任何信息。 非对称加密算法的保密性比较好，它消除了最终用户交换密钥的需要，但加密和解密花费时间长、速度慢，它不适合于对文件加密而只适用于对少量数据进行加密。 经典的非对称加密算法如RSA算法等安全性都相当高。<br>对称加密<br>对称加密算法是应用较早的加密算法，技术成熟。在对称加密算法中，数据发信方将明文（原始数据）和加密密钥一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。收信方收到密文后，若想解读原文，则需要使用加密用过的密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密密钥。对称加密算法的特点是算法公开、计算量小、加密速度快、加密效率高。不足之处是，交易双方都使用同样钥匙，安全性得不到保证。此外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的惟一钥匙，这会使得发收信双方所拥有的钥匙数量成几何级数增长。对称加密算法在分布式网络系统上使用较为困难，主要是因为密钥管理困难，使用成本较高。在计算机专网系统中广泛使用的对称加密算法有DES、IDEA和AES。</p><h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h3><p>传统的DES由于只有56位的密钥，因此已经不适应当今分布式开放网络对数据加密安全性的要求。1997年RSA数据安全公司发起了一项“DES挑战赛”的活动，志愿者四次分别用四个月、41天、56个小时和22个小时破解了其用56位密钥DES算法加密的密文。在计算机速度提升后的今天，DES加密算法被认为是不安全的。</p><h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><p>AES是美国联邦政府采用的商业及政府数据加密标准，预计将在未来几十年里代替DES在各个领域中得到广泛应用。AES提供128位密钥，因此，128位AES的加密强度是56位DES加密强度的1021倍还多。假设可以制造一部可以在1秒内破解DES密码的机器，那么使用这台机器破解一个128位AES密码需要大约149亿万年的时间。（更深一步比较而言，宇宙一般被认为存在了还不到200亿年）因此可以预计，美国国家标准局倡导的AES即将作为新标准取代DES。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/03/06/区块链02/main.png&quot; alt=&quot;logo&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="区块链技术" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="数字货币" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81/"/>
    
      <category term="互联网金融" scheme="http://yoursite.com/tags/%E4%BA%92%E8%81%94%E7%BD%91%E9%87%91%E8%9E%8D/"/>
    
  </entry>
  
  <entry>
    <title>区块链技术解读--哈希算法</title>
    <link href="http://yoursite.com/2018/03/06/%E5%8C%BA%E5%9D%97%E9%93%BE01/"/>
    <id>http://yoursite.com/2018/03/06/区块链01/</id>
    <published>2018-03-06T03:05:49.000Z</published>
    <updated>2018-03-06T08:25:17.196Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h1><p><img src="/2018/03/06/区块链01/main.png" alt="logo"></p><a id="more"></a><p>Hash算法是密码学基础，较常用的是MD5系和SHA系的散列算法结构<br>最重要的两条特性为不可逆和无冲突<br>但是这两条特性在数学上是不成立的<br><strong>不可逆</strong>即不可能反向推出哈希码所对应的明文内容，但是既然明文对应密文，非动态，那么就一直可以推出明文，在算法上利用穷举法或者彩虹表可以反解出明文内容因为一个函数必然可逆，且由于HASH函数的值域有限，理论上会有无穷多个不同的原始值，它们的hash值都相同，就是一个密文对应无限明文。<br><strong>无冲突</strong>不算是真的无冲突，密文对应明文，但是密文根据算法的不同，有限制规定的长度，而明文是无限的，所以是有可能发生哈希碰撞的</p><p>MD5和SHA做到的，是求逆和求冲突在计算上不可能，也就是正向计算很容易，而反向计算即使穷尽人类所有的计算资源都做不到。</p><p><img src="/2018/03/06/区块链01/IMG_3237.JPG" alt="logo"></p><p><img src="/2018/03/06/区块链01/IMG_3238.JPG" alt="logo"></p><p>哈希加密算法 MD5,SHA-1,SHA-2,SHA-256,SHA-512,SHA-3,RIPEMD-160等<br>引用自</p><blockquote><p><a href="http://www.atool.org/hash.php" target="_blank" rel="noopener">http://www.atool.org/hash.php</a></p></blockquote><h2 id="MD5算法"><a href="#MD5算法" class="headerlink" title="MD5算法"></a>MD5算法</h2><p>MD5即Message-Digest Algorithm 5（信息-摘要算法 5），用于确保信息传输完整一致。是计算机广泛使用的散列算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。 将数据（如汉字）运算为另一固定长度值，是散列算法的基础原理，MD5的前身有MD2、MD3和MD4。<br>MD5一度被广泛应用于安全领域。但是由于MD5的弱点被不断发现以及计算机能力不断的提升，现在已经可以构造两个具有相同MD5的信息[2]，使本算法不再适合当前的安全环境。目前，MD5计算广泛应用于错误检查。例如在一些BitTorrent下载中，软件通过计算MD5和检验下载到的碎片的完整性。<br>MD5是输入不定长度信息，输出固定长度128-bits的算法。经过程序流程，生成四个32位数据，最后联合起来成为一个128-bits散列。基本方式为，求余、取余、调整长度、与链接变量进行循环运算。得出结果。</p><h2 id="SHA-1哈希加密算法"><a href="#SHA-1哈希加密算法" class="headerlink" title="SHA-1哈希加密算法"></a>SHA-1哈希加密算法</h2><p>SHA-1在许多安全协议中广为使用，包括TLS和SSL、PGP、SSH、S/MIME和IPsec，曾被视为是MD5（更早之前被广为使用的散列函数）的后继者。<br>但SHA-1的安全性如今被密码学家严重质疑。</p><h2 id="SHA-2哈希加密算法"><a href="#SHA-2哈希加密算法" class="headerlink" title="SHA-2哈希加密算法"></a>SHA-2哈希加密算法</h2><p>SHA-224、SHA-256、SHA-384，和SHA-512并称为SHA-2。<br>新的散列函数并没有接受像SHA-1一样的公众密码社区做详细的检验，所以它们的密码安全性还不被大家广泛的信任。<br>虽然至今尚未出现对SHA-2有效的攻击，它的算法跟SHA-1基本上仍然相似；因此有些人开始发展其他替代的散列算法。</p><h2 id="SHA-3哈希加密算法"><a href="#SHA-3哈希加密算法" class="headerlink" title="SHA-3哈希加密算法"></a>SHA-3哈希加密算法</h2><p>SHA-3，之前名为Keccak算法，是一个加密杂凑算法。<br>SHA-3并不是要取代SHA-2，因为SHA-2目前并没有出现明显的弱点。<br>由于对MD5出现成功的破解，以及对SHA-0和SHA-1出现理论上破解的方法，NIST感觉需要一个与之前算法不同的，可替换的加密杂凑算法，也就是现在的SHA-3。</p><h2 id="RIPEMD-160哈希加密算法"><a href="#RIPEMD-160哈希加密算法" class="headerlink" title="RIPEMD-160哈希加密算法"></a>RIPEMD-160哈希加密算法</h2><p>RIPEMD-160 是一个 160 位加密哈希函数。<br>它旨在用于替代 128 位哈希函数 MD4、MD5 和 RIPEMD。<br>RIPEMD 是在 EU 项目 RIPE（RACE Integrity Primitives Evaluation，1988-1992）的框架中开发的。</p><p>引用自新浪微博</p><blockquote><p><a href="http://blog.sina.com.cn/s/blog_1799256a10102x3fh.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_1799256a10102x3fh.html</a></p></blockquote><p>Hash算法将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。哈希值是一段数据唯一且极其紧凑的数值表示形式。如果散列一段明文而且哪怕只更改该段落的一个字母，随后的哈希都将产生不同的值。要找到散列为同一个值的两个不同的输入，在计算上是不可能的，所以数据的哈希值可以检验数据的完整性。一般用于快速查找和加密算法。</p><p>再引入一个hash表概念，计算机数据结构中，给定一个表M，关键字key，存在函数H(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为hash表。</p><p>简单理解hash算法就是这一种单向的加密，一个明文加密称为密文，不可逆推，只有加密过程，没有解密过程。说明了hash函数和hash表的概念，那么目前常用的hash算法有MD5（已被破解），SHA系列算法（比特币中使用sha-256算法）。SHA这里稍微提下（secure hash algorithm）这不是一个算法，这是一个hash函数集，现在有sha-224、sha-256、sha-384、sha-512等算法。在09年中本聪设计比特币的时候，当时sha-256被认为最安全的算法之一，故选择了sha-256，到目前为止还没有被破解。</p><p>解释到这里，可能会联想到，hash算法中key在计算后如果出现了同一位置，冲突的产生，这里简单说下几种冲突处理，如有兴趣可以查看hash算法论文。</p><p>1.拉链法：这种方法可以完全避免冲突，将所有关键字为同义词的结点链接在同一个单链表中。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数组t[0..m-1]。凡是散列地址为i的结点，均插入到以t为头指针的单链表中。t中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于1，但一般均取α≤1。</p><p>2.多哈希法：设计两种以上的hash函数，避免冲突，这个感觉比较不靠谱，但是从概率上来说多种hash函数还是降低了冲突的出现。</p><p>3.开放地址法：开放地址法有一个公式：Hi=(H(key)+di) MOD m i=1,2,…,k(k&lt;=m-1），其中，m为哈希表的表长。di 是产生冲突的时候的增量序列。如果di值可能为1,2,3,…m-1，称线性探测再散列。如果di取1，则每次冲突之后，向后移动1个位置.如果di取值可能为1,-1,4,-4,9,-9,16,-16,…k<em>k,-k</em>k(k&lt;=m/2），称二次探测再散列。如果di取值可能为伪随机数列。称伪随机探测再散列。</p><p>Hash算法函数根据分类：加法hash、位运算hash、乘法hash、除法hash、查表hash等。</p><h1 id="区块链中的哈希解读"><a href="#区块链中的哈希解读" class="headerlink" title="区块链中的哈希解读"></a>区块链中的哈希解读</h1><p>因为区块链技术作为比特币的底层技术之一，目的是用于保证数字货币在交易环节中的安全性。</p><p>在徐明星的图说区块链中以一种图解更直观的形式这样说道</p><p><img src="/2018/03/06/区块链01/tushuo01.png" alt="logo"><br><img src="/2018/03/06/区块链01/tushuo03.png" alt="logo"><br><img src="/2018/03/06/区块链01/tushuo04.png" alt="logo"></p><p>结合区块链，在区块链中很多地方都用到了hash函数：</p><p>1.区块链中节点的地址、公钥、私钥的计算。以地址为例：公钥经过一次SHA256计算，再进行一次RIPEMD160计算，得到一个公钥哈希（20字节\160比特），添加版本信息，再来两次SHA256运算、取前4比特字节，放到哈希公钥加版本信息后，再经过base58编码，最终得到地址。</p><p>2.merkle tree：是数据结构中的一种树结构，可以是二叉树，也可以是多叉树，他和数据结构中树的特点几乎一致，和普通树不同的是：merkle tree上的叶节点存放hash计算后的hash值，非叶节点是其对应的子节点串联的字符串的hash值。用于区块头和SPV认证中。</p><p>3.比特币中的挖矿，工作量证明（pow），计算的其实就是一个nonce，当这个随机数和其他散列过的数据合并时，产生一个比规定目标小（target）值。挖矿也可以理解一种快速不可逆的计算。SHA256(SHA256(version + prev_hash + merkle_root + ntime + nbits + x )) &lt; TARGET。</p><p>4.比特币中的bloom filter布隆过滤器，布隆过滤器基于hash函数的快速查找。解决了客户端检索的问题，原理是Bloom filter可以快速判断出某检索值一定不存在于某个指定的集合，从而可以过滤掉大量无关数据，减少客户端不必要的下载量。</p><p>简单介绍了HASH算法，和区块链中用到的HASH算法，区块链是多个技术的结合，结合各自特点出现的一种新的技术架构，HASH算法和加密技术为区块链的自证信任化及安全控制提供了基础，算法的碰撞和现在量子计算的发展，之前在区块链的安全性的文章中笔者有过说明，技术不断发展，肯定会有更适合的技术保障应用的实现。</p><p><img src="/2018/03/06/区块链01/tushuo02.png" alt="logo"></p><p>SHA (Secure Hash Algorithm，译作安全散列算法) 是美国国家安全局 (NSA) 设计，美国国家标准与技术研究院 (NIST) 发布的一系列密码散列函数，经历了SHA-0，SHA-1，SHA-2，SHA-3系列发展。NSA于2007年正式宣布在全球范围内征集新新一代（SHA-3）算法设计，2012年公布评选结果， Keccak算法最终获胜成为唯一官方标准SHA-3算法，但还有四种算法同时进入了第三轮评选，分别是：BLAKE, GrøSTL, JH和SKEIN，这些算法其实也非常安全，而且经受审查，被各种竞争币频繁使用。 </p><p><img src="/2018/03/06/区块链01/tushuo05.png" alt="logo"></p><p>比特币采用SHA256算法，该算法属于SHA-2系列，在中本聪发明比特币时（2008）被公认为最安全最先进的算法之一。除了生成地址中有一个环节使用了REPID-160算法，比特币系统中但凡有需要做Hash运算的地方都是用SHA256。随着比特币被更多人了解，大家开始好奇中本聪为何选择了SHA256，同时对SHA256的安全性发表各种意见，SHA256妥妥经受了质疑，到目前为止，没有公开的证据表明SHA256有漏洞，SHA256依然牢牢抗住保卫比特币安全的大旗。当然大家心里都明白，没有永远安全的算法，SHA256被替代是早晚的事，中本聪自己也说明了算法升级的必要和过程。</p><p><img src="/2018/03/06/区块链01/tushuo06.png" alt="logo"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;哈希算法&quot;&gt;&lt;a href=&quot;#哈希算法&quot; class=&quot;headerlink&quot; title=&quot;哈希算法&quot;&gt;&lt;/a&gt;哈希算法&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2018/03/06/区块链01/main.png&quot; alt=&quot;logo&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="区块链技术" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="数字货币" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81/"/>
    
      <category term="互联网金融" scheme="http://yoursite.com/tags/%E4%BA%92%E8%81%94%E7%BD%91%E9%87%91%E8%9E%8D/"/>
    
  </entry>
  
</feed>
