<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Funk Jungle</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-05T16:14:25.535Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>黄上</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JAVA新测试框架--testng和mockito</title>
    <link href="http://yoursite.com/2018/04/05/java-%E6%96%B0%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2018/04/05/java-新测试框架/</id>
    <published>2018-04-05T12:59:13.000Z</published>
    <updated>2018-04-05T16:14:25.535Z</updated>
    
    <content type="html"><![CDATA[<p>测试是检查应用程序的功能的过程是否按要求工作，在开发人员层面进行单元测试，在采取适当措施来测试每一个实体（类或方法）以确保最终产品符合要求。单元测试是非常必要的，这是软件公司向他们的客户提供高质量的软件产品必要前提。</p><p>较常用的测试框架是Junit4，这个是老框架，现在的互联网开发公司常用的新框架有testng和mockito两种。<br>单元测试用例是代码的一部分从而确保代码（方法）的另一部分工作正常。要快速实现这些理想的效果，测试框架是必需的。JUnit对于Java编程语言是完美的单元测试框架。<br><a id="more"></a><br>单元测试可以通过两种方式来完成：</p><p><strong>手动测试：</strong></p><p>手动执行测试用例，没有任何工具支持称为手动测试。<br>费时和乏味：由于测试案例是由人力的，所以它是非常缓慢而乏味的执行。<br>巨大的人力资源的投入：作为测试用例需要手动执行，所以更多的测试都需要手动测试。<br>较不可靠：手动测试是为测试可能不会被精确地每次执行，因为人为错误导致不可靠。<br>非可编程：无需编程就可以做，获取信息隐藏复杂的测试</p><p><strong>自动测试：</strong></p><p>以工具支持，并通过使用自动化工具则称为自动化测试执行测试用例。<br>快速自动化运行测试用例比人力显著更快。<br>人力资源的投入较少：测试用例是通过使用自动化工具，所以较少测试者都需要在自动化测试执行。<br>更可靠：自动化测试在每次运行的时间进行精确的相同操作。<br>可编程：测试人员可以编写复杂的测试，以带出隐藏的信息。</p><p>JUnit是一个Java编程语言编写的单元测试框架。 重要的是在测试驱动开发中，并且是一个家族的统称为xUnit单元测试框架中的一个。</p><p>JUnit促进“先测试再编码”，它强调建立测试数据的一段代码可以被测试，先测试再编码实现的想法。这种做法就像是“试了一下，码了一点，测试了一下，代码一点点……”这增加了程序员的工作效率和程序代码的稳定性，减少程序员的压力和花在调试的时间。</p><p>而TestNG和mockito是全新的测试体系，在junit4的基础上，很多更加简便的测试框架被开发出来，为什么介绍这两种框架，因为现在的软件开放公司都是利用junit+TestNG+mockito的方式，运用大家的优点来搭建总体的测试体系。不过似乎在功能方面，TestNG可以完全替代Junit的功能，不过Junit作为传统的xunit测试体系，在新出的Junit5测试框架也有很强的性能（在下面会做分析）。</p><h1 id="Testng"><a href="#Testng" class="headerlink" title="Testng"></a>Testng</h1><p>JUnit让开发人员了解测试的实用性，尤其是在单元测试这一模块上比任何其他测试框架都要简单明了。凭借一个相当简单，务实，严谨的架构，JUnit已经能够“感染”了一大批开发人员。</p><p>JUnit缺点：<br>1.最初的设计，使用于单元测试，现在只用于各种测试。<br>2.不能依赖测试<br>3.配置控制欠佳(安装/拆卸)<br>4.侵入性(强制扩展类，并以某种方式命名方法)<br>5.静态编程模型(不必要的重新编译)<br>6.不适合管理复杂项目应用，JUnit复杂项目中测试非常棘手。</p><h2 id="而TetsNG是什么样的框架？"><a href="#而TetsNG是什么样的框架？" class="headerlink" title="而TetsNG是什么样的框架？"></a>而TetsNG是什么样的框架？</h2><p>TestNG是一个测试框架，其灵感来自JUnit和NUnit（也就是xUnit家族的产品），但引入了一些新的功能，使其功能更强大，使用更方便。</p><p>TestNG是一个开源自动化测试框架;TestNG表示下一代(Next Generation的首字母)。 TestNG类似于JUnit(特别是JUnit 4)，但它不是JUnit框架的扩展。它的灵感来源于JUnit。它的目的是优于JUnit，尤其是在用于测试集成多类时。 TestNG的创始人是Cedric Beust(塞德里克·博伊斯特)。</p><p>TestNG消除了大部分的旧框架的限制，使开发人员能够编写更加灵活和强大的测试。 因为它在<strong>很大程度上借鉴了Java注解</strong>(JDK5.0引入的)来定义测试，它也可以显示如何使用这个新功能在真实的Java语言生产环境中。</p><p>TestNG的特点：</p><p>1.注解<br>2.TestNG使用Java和面向对象的功能<br>3.支持综合类测试(例如，默认情况下，不用创建一个新的测试每个测试方法的类的实例)<br>4.独立的编译时测试代码和运行时配置/数据信息<br>5.灵活的运行时配置<br>6.主要介绍“测试组”。当编译测试，只要要求TestNG运行所有的“前端”的测试，或“快”，“慢”，“数据库”等<br>7.支持依赖测试方法，并行测试，负载测试，局部故障<br>8.灵活的插件API<br>9.支持多线程测试</p><p>TestNG(Next Generation)是一个测试框架，它受到JUnit和NUnit的启发，而引入了许多新的创新功能，如依赖测试，分组概念，使测试更强大，更容易做到。 它旨在涵盖所有类别的测试：单元，功能，端到端，集成等…</p><h2 id="如何使用TestNG？"><a href="#如何使用TestNG？" class="headerlink" title="如何使用TestNG？"></a>如何使用TestNG？</h2><p>展示如何开始使用TestNG单元测试框架，使用的开发环境依然是Eclipse m.3+maven3+JDK1.8<br>这里选用TestNG的版本为TestNG 6.10版本</p><p>第一步：先去官网或者是ali的maven库中去复制TestNG 6.10的版本，然后将其放在pom中的dependencies标签下。</p><p>第二步：安装Eclipse的插件支持，在Eclipse Market中搜索“TestNG for Eclipse”，然后install，重启Eclipse。</p><p>第三步：查看是否安装成功，在eclipse的工具栏中，点击file-》new-》other，看到TestNG文件夹，即表示安装插件成功。</p><p>第四步：这就可以使用TestNG用于测试组件或者单元了，在想要测试的项目的src/test/java下新建“TestNG class”，这个类就相当于Junit的测试类，在这个类中，去写测试代码，然后右键run as–》选择“TestNG test”就可以测试了。(其实测试方法有两种，接下来就讲)</p><h3 id="TestNG的测试方式"><a href="#TestNG的测试方式" class="headerlink" title="TestNG的测试方式"></a>TestNG的测试方式</h3><p>第一种直接执行：右键要执行的方法，　　点Run As -&gt;TestNG Test</p><p>第二种:  通过testng.xml文件来执行. 把要执行的case, 放入testng.xml文件中。 右键点击testng.xml,   点Run As<br>这个xml文件放在src/test/java里即可</p><p>在testng.xml中，可以控制测试用例按顺序执行。  当preserve-order=”true”是，可以保证节点下面的方法是按顺序执行的</p><h3 id="断言（ASSERT-的用法"><a href="#断言（ASSERT-的用法" class="headerlink" title="断言（ASSERT)的用法"></a>断言（ASSERT)的用法</h3><p>这里介绍一下载TestNG中同样也支持断言Assert，在实际开发中用于检测错误。<br>如何用断言Assert，断言里面又有什么方法？那个方法较为常用呢？</p><p>在经过对其进行一定了解之后，对其作用及用法有了一定的了解，assert()的用法像是一种“契约式编程”，在我的理解中，其表达的意思就是，程序在我的假设条件下，能够正常良好的运作，其实就相当于一个if语句：其本质就是代替if-else，因为如果要用if-else来测的话，整个测试结构就会变得很复杂，可读性也不好，程序结构比较臃肿，用了Assert就好多了。</p><pre><code>if(假设成立){     程序正常运行；}else{      报错&amp;&amp;终止程序！（避免由程序运行引起更大的错误）  }</code></pre><p>如果断言的条件错误，则直接程序报错，可以说是一种保障正确的一种方式，org.testng.Assert 用来校验接口测试的结果，那么它提供哪些方法呢?</p><p>提供了以下这些方法：（根据实际情况需要而去测试）</p><p>assertTrue 判断是否为true。<br>assertFalse 判断是否为false。<br>assertSame 判断引用地址是否相等。<br>assertNotSame 判断引用地址是否不相等。<br>assertNull 判断是否为null<br>assertNotNull 判断是否不为null<br>assertEquals 判断是否相等，Object类型的对象需要实现hashCode及equals方法，集合类型Collection/Set/Map 中的对象也需要实现hashCode及equals方法，3个double参数时比较好玩，前两个double相等，或者前两个double的差值小于传入的第三个double值，即偏移量小于多少时，认为相等。<br>assertNotEquals 判断是否不相等<br>assertEqualsNoOrder 判断忽略顺序是否相等</p><p>例子：</p><p>StringGenerator类<br>    public class StringGenerator {</p><pre><code>    public String generate(){        return &quot;testng demo!&quot;;    }}</code></pre><p>Test类</p><pre><code>public class TestNgDemo {  @Test  public void test1() {      StringGenerator sg=new StringGenerator();      String content=sg.generate();      /*       * testng框架中的Assert断言的作用       *        */      Assert.assertNotNull(content);//判断是否为空      Assert.assertEquals(content, &quot;testng demo!&quot;);//判断内容是否相等  }}</code></pre><p>控制台输出内容的部分：</p><pre><code>[RemoteTestNG] detected TestNG version 6.10.0[TestNG] Running:  C:\Users\Administrator\AppData\Local\Temp\testng-eclipse--46238976\testng-customsuite.xmlPASSED: test1===============================================    Default test    Tests run: 1, Failures: 0, Skips: 0==============================================================================================Default suiteTotal tests run: 1, Failures: 0, Skips: 0===============================================</code></pre><p>这样就是TestNG测试框架的使用，当然这个测试框架还可以应用在很多方面，比如：<br>TestNG预期异常测试<br>TestNG忽略测试<br>TestNG超时测试<br>TestNG分组测试<br>TestNG套件测试<br>TestNG依赖测试<br>TestNG参数化测试<br>TestNG参数测试实例<br>TestNG + Selenium负载测试<br>TestNG + Spring集成测试</p><h3 id="介绍TestNG的各种测试案例"><a href="#介绍TestNG的各种测试案例" class="headerlink" title="介绍TestNG的各种测试案例"></a>介绍TestNG的各种测试案例</h3><h3 id="TestNG和Junit4相对比："><a href="#TestNG和Junit4相对比：" class="headerlink" title="TestNG和Junit4相对比："></a>TestNG和Junit4相对比：</h3><p>JUnit 4和TestNG都是Java中非常受欢迎的单元测试框架。两种框架在功能上看起来非常相似。 哪一个更好？ 在Java项目中应该使用哪个单元测试框架？</p><p>下面表中概括了JUnit 4和TestNG之间的功能比较。如下图所示 -</p><p><img src="/2018/04/05/java-新测试框架/p1.png" alt="logo"></p><h3 id="注释支持"><a href="#注释支持" class="headerlink" title="注释支持"></a>注释支持</h3><p>注释/注解支持在JUnit 4和TestNG中是非常类似的。<br><img src="/2018/04/05/java-新测试框架/p2.png" alt="logo"></p><p>JUnit4和TestNG之间的主要注释差异是：</p><p>在JUnit 4中，我们必须声明“@BeforeClass”和“@AfterClass”方法作为静态方法。 TestNG在方法声明中更灵活，它没有这个约束。</p><p>3个额外的setUp / tearDown级别：suite和group(@Before / AfterSuite，@Before / After Test，@Before / After Group)。</p><pre><code>JUnit 4@BeforeClasspublic static void oneTimeSetUp() {    // one-time initialization code    System.out.println(&quot;@BeforeClass - oneTimeSetUp&quot;);}TestNG@BeforeClasspublic void oneTimeSetUp() {        // one-time initialization code        System.out.println(&quot;@BeforeClass - oneTimeSetUp&quot;);}</code></pre><p>在JUnit 4中，注释命名约定有点混乱，例如“Before”，“After”和“Expected”，我们并不真正了解“Before”和“After”之前的内容，以及要测试中的“预期” 方法。TestiNG更容易理解，它使用类似“BeforeMethod”，“AfterMethod”和“ExpectedException”就很明了。</p><p><strong>异常测试</strong></p><p>“异常测试”是指从单元测试中抛出的异常，此功能在JUnit 4和TestNG中都可实现。</p><pre><code>JUnit 4@Test(expected = ArithmeticException.class)public void divisionWithException() {  int i = 1/0;}TestNG@Test(expectedExceptions = ArithmeticException.class)public void divisionWithException() {  int i = 1/0;}</code></pre><p><strong>忽略测试</strong></p><p>“忽略”表示是否应该忽略单元测试，该功能在JUnit 4和TestNG中均可实现。</p><pre><code>JUnit 4@Ignore(&quot;Not Ready to Run&quot;)@Testpublic void divisionWithException() {  System.out.println(&quot;Method is not ready yet&quot;);}TestNG@Test(enabled=false)public void divisionWithException() {  System.out.println(&quot;Method is not ready yet&quot;);}</code></pre><p><strong>时间测试</strong></p><p>“时间测试”表示如果单元测试所花费的时间超过指定的毫秒数，则测试将会终止，并将其标记为失败，此功能在JUnit 4和TestNG中均可实现。</p><pre><code>JUnit 4@Test(timeout = 1000)public void infinity() {    while (true);}TestNG@Test(timeOut = 1000)public void infinity() {    while (true);}</code></pre><p><strong>套件测试</strong></p><p>“套件测试”是指捆绑几个单元测试并一起运行。 此功能在JUnit 4和TestNG中都可实现。 然而，两者都使用非常不同的方法来实现它。</p><p>JUnit 4</p><p>“@RunWith”和“@Suite”用于运行套件测试。下面的类代码表示在JunitTest5执行之后，单元测试“JunitTest1”和“JunitTest2”一起运行。 所有的声明都是在类内定义的。</p><pre><code>@RunWith(Suite.class)@Suite.SuiteClasses({        JunitTest1.class,        JunitTest2.class})public class JunitTest5 {}</code></pre><p>TestNG</p><p>XML文件用于运行套件测试。以下XML文件表示单元测试“TestNGTest1”和“TestNGTest2”将一起运行。</p><pre><code>&lt;suite name=&quot;My test suite&quot;&gt;  &lt;test name=&quot;testing&quot;&gt;    &lt;classes&gt;       &lt;class name=&quot;com.fsecure.demo.testng.TestNGTest1&quot; /&gt;       &lt;class name=&quot;com.fsecure.demo.testng.TestNGTest2&quot; /&gt;    &lt;/classes&gt;  &lt;/test&gt;&lt;/suite&gt;</code></pre><p>TestNG可以做捆绑类测试，也可以捆绑方法测试。 凭借TestNG独特的“分组”概念，每种方法都可以与一个组合相结合，可以根据功能对测试进行分类(分组)。 例如，</p><p>下面是一个有四个方法的类，三个组(method1，method2和method3)</p><pre><code>@Test(groups=&quot;method1&quot;)public void testingMethod1() {  System.out.println(&quot;Method - testingMethod1()&quot;);}@Test(groups=&quot;method2&quot;)public void testingMethod2() {    System.out.println(&quot;Method - testingMethod2()&quot;);}@Test(groups=&quot;method1&quot;)public void testingMethod1_1() {    System.out.println(&quot;Method - testingMethod1_1()&quot;);}@Test(groups=&quot;method4&quot;)public void testingMethod4() {    System.out.println(&quot;Method - testingMethod4()&quot;);}</code></pre><p>使用以下XML文件，可以仅使用组“method1”执行单元测试。</p><pre><code>&lt;suite name=&quot;My test suite&quot;&gt;  &lt;test name=&quot;testing&quot;&gt;      &lt;groups&gt;      &lt;run&gt;        &lt;include name=&quot;method1&quot;/&gt;      &lt;/run&gt;    &lt;/groups&gt;    &lt;classes&gt;       &lt;class name=&quot;com.fsecure.demo.testng.TestNGTest5_2_0&quot; /&gt;    &lt;/classes&gt;  &lt;/test&gt;&lt;/suite&gt;</code></pre><p>通过“分组”测试概念，集成测试的可能性是无限制的。 例如，我们只能从所有单元测试类中测试“DatabaseFuntion”分组。</p><p><strong>参数化测试</strong></p><p>“参数化测试”是指单位测试参数值的变化。 此功能在JUnit 4和TestNG中都实现。 然而，两者都使用非常不同的方法来实现它。</p><p>JUnit 4</p><p>“@RunWith”和“@Parameter”用于提供单元测试的参数值，@Parameters必须返回List []，参数将作为参数传入类构造函数。</p><pre><code>@RunWith(value = Parameterized.class)public class JunitTest6 {     private int number;     public JunitTest6(int number) {        this.number = number;     }     @Parameters     public static Collection&lt;Object[]&gt; data() {       Object[][] data = new Object[][] { { 1 }, { 2 }, { 3 }, { 4 } };       return Arrays.asList(data);     }     @Test     public void pushTest() {       System.out.println(&quot;Parameterized Number is : &quot; + number);     }}</code></pre><p>这里有很多限制，我们必须遵循“JUnit”的方式来声明参数，并且必须将参数传递给构造函数才能初始化类成员作为测试的参数值。参数类的返回类型为“List []”，数据已被限制为String或用于测试的原始类型值。</p><p>TestNG</p><p>XML文件或“@DataProvider”用于提供不同参数进行测试。</p><p>用于参数化测试的XML文件 -</p><p>只有“@Parameters”在需要参数测试的方法中声明，参数化数据将在TestNG的XML配置文件中提供。 通过这样做，我们可以使用不同数据集的单个测试用例，甚至获得不同的结果。 另外，即使是最终用户，QA还是QE都可以在XML文件中提供自己的数据进行测试。</p><pre><code>public class TestNGTest6_1_0 {@Test@Parameters(value=&quot;number&quot;)public void parameterIntTest(int number) {       System.out.println(&quot;Parameterized Number is : &quot; + number);    }}</code></pre><p>XML文件的内容如下 -</p><pre><code>&lt;suite name=&quot;My test suite&quot;&gt;  &lt;test name=&quot;testing&quot;&gt;    &lt;parameter name=&quot;number&quot; value=&quot;2&quot;/&gt;    &lt;classes&gt;       &lt;class name=&quot;com.fsecure.demo.testng.TestNGTest6_0&quot; /&gt;    &lt;/classes&gt;  &lt;/test&gt;&lt;/suite&gt;</code></pre><p>@DataProvider用于参数化测试</p><p>将数据值拉入XML文件可能非常方便，但测试偶尔会需要复杂的类型，这些类型不能被表示为一个字符串或一个原始类型值。 TestNG使用@DataProvider注解来处理这种情况，这有助于将复杂参数类型映射到测试方法。</p><p>@DataProvider for Vector，String或Integer作为参数，参考如下代码 -</p><pre><code>@Test(dataProvider = &quot;Data-Provider-Function&quot;)    public void parameterIntTest(Class clzz, String[] number) {       System.out.println(&quot;Parameterized Number is : &quot; + number[0]);       System.out.println(&quot;Parameterized Number is : &quot; + number[1]);    }    //This function will provide the patameter data    @DataProvider(name = &quot;Data-Provider-Function&quot;)    public Object[][] parameterIntTestProvider() {        return new Object[][]{                   {Vector.class, new String[] {&quot;java.util.AbstractList&quot;,&quot;java.util.AbstractCollection&quot;}},                   {String.class, new String[] {&quot;1&quot;, &quot;2&quot;}},                   {Integer.class, new String[] {&quot;1&quot;, &quot;2&quot;}}                  };    }</code></pre><p>@DataProvider作为对象的参数</p><p>“TestNGTest6_3_0”是一个简单的对象，只需使用get/set方法进行演示。</p><pre><code>@Test(dataProvider = &quot;Data-Provider-Function&quot;)public void parameterIntTest(TestNGTest6_3_0 clzz) {   System.out.println(&quot;Parameterized Number is : &quot; + clzz.getMsg());   System.out.println(&quot;Parameterized Number is : &quot; + clzz.getNumber());}//This function will provide the patameter data@DataProvider(name = &quot;Data-Provider-Function&quot;)public Object[][] parameterIntTestProvider() {    TestNGTest6_3_0 obj = new TestNGTest6_3_0();    obj.setMsg(&quot;Hello&quot;);    obj.setNumber(123);    return new Object[][]{               {obj}    };}</code></pre><p>TestNG的参数化测试非常用户友好和灵活(在XML文件或类内)。 它可以支持许多复杂的数据类型作为参数值，可能性是无限的。 如上例所示，我们甚至可以传入我们自己的对象(TestNGTest6_3_0)进行参数化测试</p><p><strong>依赖性测试</strong></p><p>“参数化测试”表示方法是依赖性测试，它将在所需方法之前执行。 如果依赖方法失败，则所有后续测试将会被跳过，不会被标记为失败。</p><p>JUnit 4</p><p>JUnit框架着重于测试隔离; 目前它不支持此功能。</p><p>TestNG</p><p>它使用“dependOnMethods”来实现依赖测试如下 -</p><pre><code>@Testpublic void method1() {   System.out.println(&quot;This is method 1&quot;);}@Test(dependsOnMethods={&quot;method1&quot;})public void method2() {    System.out.println(&quot;This is method 2&quot;);}</code></pre><p>“method2()”只有在“method1()”运行成功的情况下才会执行，否则“method2()”将跳过测试。</p><p><strong>结论</strong></p><p>在考虑所有功能比较之后，建议使用TestNG作为Java项目的核心单元测试框架，因为TestNG在参数化测试，依赖测试和套件测试(分组概念)方面更加突出。 TestNG用于高级测试和复杂集成测试。 它的灵活性对于大型测试套件尤其有用。 此外，TestNG还涵盖了整个核心的JUnit4功能。这样说来，好像也没有理由使用JUnit了。</p><h2 id="TestNG与spring或spring-boot结合"><a href="#TestNG与spring或spring-boot结合" class="headerlink" title="TestNG与spring或spring boot结合"></a>TestNG与spring或spring boot结合</h2><h1 id="mockito"><a href="#mockito" class="headerlink" title="mockito"></a>mockito</h1><p>mockito的官网：<a href="http://site.mockito.org/" target="_blank" rel="noopener">http://site.mockito.org/</a><br>在实际项目中写单元测试的过程中我们会发现需要测试的类有很多依赖，这些依赖项又会有依赖，导致在单元测试代码里几乎无法完成构建，尤其是当依赖项尚未构建完成时会导致单元测试无法进行。为了解决这类问题我们引入了Mock的概念，简单的说就是模拟这些需要构建的类或者资源，提供给需要测试的对象使用。业内的Mock工具有很多，也已经很成熟了，这里我们将直接使用最流行的Mockito进行实战演练，完成mockito教程。</p><p>EasyMock 以及 Mockito 都因为可以极大地简化单元测试的书写过程而被许多人应用在自己的工作中，但是这两种 Mock 工具都不可以实现对静态函数、构造函数、私有函数、Final 函数以及系统函数的模拟，但是这些方法往往是我们在大型系统中需要的功能。</p><h2 id="如何使用Mockito？"><a href="#如何使用Mockito？" class="headerlink" title="如何使用Mockito？"></a>如何使用Mockito？</h2><p>第一步：在项目的pom中添加依赖，我用的阿里库的mockito版本为2.9.0的版本，ali的maven库中找到mockito-core的依赖jar，导入项目pom<br>也可以直接去官网下载相应的jar包，更新到了2.17版本。</p><p>第二步：另外Mockito需要Junit配合使用，在Pom文件中同样引入：junit4的版本。</p><p>第三步：然后为了使代码更简洁，最好在测试类中导入静态资源，还有为了使用常用的junit关键字，也要引入junit的两个类Before和Test：</p><pre><code>import static org.mockito.Mockito.*;import static org.junit.Assert.*;import org.junit.Before;import org.junit.Test;</code></pre><p>第四步：然后就可以编写测试代码进行使用了，这里用junit的测试步骤来测试即可，mockito主要的功能就是模拟。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;测试是检查应用程序的功能的过程是否按要求工作，在开发人员层面进行单元测试，在采取适当措施来测试每一个实体（类或方法）以确保最终产品符合要求。单元测试是非常必要的，这是软件公司向他们的客户提供高质量的软件产品必要前提。&lt;/p&gt;
&lt;p&gt;较常用的测试框架是Junit4，这个是老框架，现在的互联网开发公司常用的新框架有testng和mockito两种。&lt;br&gt;单元测试用例是代码的一部分从而确保代码（方法）的另一部分工作正常。要快速实现这些理想的效果，测试框架是必需的。JUnit对于Java编程语言是完美的单元测试框架。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="java类库" scheme="http://yoursite.com/tags/java%E7%B1%BB%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JAVA-理解文章汇总（不断更新）</title>
    <link href="http://yoursite.com/2018/04/03/java-se/"/>
    <id>http://yoursite.com/2018/04/03/java-se/</id>
    <published>2018-04-03T10:45:01.000Z</published>
    <updated>2018-04-03T18:18:41.957Z</updated>
    
    <content type="html"><![CDATA[<p>JAVA基础总结，持续更新，以防忘记。<br><a id="more"></a></p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="JDK8后的接口新规"><a href="#JDK8后的接口新规" class="headerlink" title="JDK8后的接口新规"></a>JDK8后的接口新规</h2><p>在jdk8之前，interface之中可以定义变量和方法，变量必须是public、static、final的，方法必须是public、abstract的。由于这些修饰符都是默认的，所以在JDK8之前，下面的写法都是等价的。</p><pre><code>public interface JDK8BeforeInterface {      public static final int field1 = 0;      int field2 = 0;      public abstract void method1(int a) throws Exception;      void method2(int a) throws Exception;  }  </code></pre><p>接口变量的默认修饰是public static final，就是自动声明为常量，这些都是隐式默认的规则，所以直接用public声明也是一样的效果，变量必须是常量，而方法也必须的抽象方法，且限定修饰符必须是public，这些也是隐式规定的。</p><p>JDK8及以后，允许我们在接口中定义static方法和default方法。也就是静态方法和默认方法。<br>static方法和default方法都可以直接在接口里写方法体（方法的具体逻辑）了。<br>这就是java变相的让接口能够结合抽象类的功能。</p><pre><code>public interface JDK8Interface {      // static修饰符定义静态方法      static void staticMethod() {          System.out.println(&quot;接口中的静态方法&quot;);      }      // default修饰符定义默认方法      default void defaultMethod() {          System.out.println(&quot;接口中的默认方法&quot;);      }  }  </code></pre><p>再定义一个接口的实现类：</p><pre><code>public class JDK8InterfaceImpl implements JDK8Interface {      //实现接口后，因为默认方法不是抽象方法，所以可以不重写，但是如果开发需要，也可以重写  }  </code></pre><p>default修饰的方法可以不重写，根据其实现类的对象来调用这个接口的default方法<br>而静态方法则是只能这个接口名来直接调用。<br>静态方法，只能通过接口名调用，不可以通过实现类的类名或者实现类的对象调用。default方法，只能通过接口实现类的对象来调用。</p><pre><code>public class Main {      public static void main(String[] args) {          // static方法必须通过接口类调用          JDK8Interface.staticMethod();          //default方法必须通过实现类的对象调用          new JDK8InterfaceImpl().defaultMethod();      }  } </code></pre><p>当然如果接口中的默认方法不能满足某个实现类需要，那么实现类可以覆盖默认方法。</p><pre><code>public class AnotherJDK8InterfaceImpl implements JDK8Interface {      // 签名跟接口default方法一致,但是不能再加default修饰符      @Override      public void defaultMethod() {          System.out.println(&quot;接口实现类覆盖了接口中的default&quot;);      }  }      </code></pre><p>由于java支持一个实现类可以实现多个接口，如果多个接口中存在同样的static和default方法会怎么样呢？如果有两个接口中的静态方法一模一样，并且一个实现类同时实现了这两个接口，此时并不会产生错误，因为jdk8只能通过接口类调用接口中的静态方法，所以对编译器来说是可以区分的。但是如果两个接口中定义了一模一样的默认方法，并且一个实现类同时实现了这两个接口，那么必须在实现类中重写默认方法，否则编译失败。</p><p>例如JDK8Interface1也有一个defaultMethod()</p><pre><code>public interface JDK8Interface1 {      // static修饰符定义静态方法      static void staticMethod() {          System.out.println(&quot;JDK8Interface1接口中的静态方法&quot;);      }      // default修饰符定义默认方法      default void defaultMethod() {          System.out.println(&quot;JDK8Interface1接口中的默认方法&quot;);      }  } </code></pre><p>必须要覆盖defaultMethod()，然后调用的时候JVM才不会混乱，不然JVM不知道调用哪个default方法</p><pre><code>public class JDK8InterfaceImpl implements JDK8Interface,JDK8Interface1 {      // 由于JDK8Interface和JDK8Interface1中default方法一样,所以这里必须覆盖      @Override      public void defaultMethod() {          System.out.println(&quot;接口实现类覆盖了接口中的default&quot;);      }  } </code></pre><p>对象调用的是重写后的defaultMethod()。</p><pre><code>public class Main {      public static void main(String[] args) {          JDK8Interface.staticMethod();          JDK8Interface1.staticMethod();          new JDK8InterfaceImpl().defaultMethod();      }  }</code></pre><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态是同一个行为具有多个不同表现形式或形态的能力。<br>多态就是同一个接口，使用不同的实例而执行不同操作，如图所示：</p><p><img src="/2018/04/03/java-se/p1.png" alt="logo"> </p><p>多态性是对象多种表现形式的体现。</p><p>现实中，比如我们按下 F1 键这个动作：<br>如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；<br>如果当前在 Word 下弹出的就是 Word 帮助；<br>在 Windows 下弹出的就是 Windows 帮助和支持。</p><p>同一个事件发生在不同的对象上会产生不同的结果。</p><p>多态的优点<br>1.消除类型之间的耦合关系<br>2.可替换性<br>3.可扩充性<br>4.接口性<br>5.灵活性<br>6.简化性</p><p>多态存在的三个必要条件</p><p>1.继承<br>2.重写<br>3.父类引用指向子类对象</p><p>比如：<br>Parent p = new Child();//这就是典型的多态</p><p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。<br>多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。<br>以下是一个多态实例的演示，详细说明请看注释：</p><pre><code>public class Test {    public static void main(String[] args) {      show(new Cat());  // 以 Cat 对象调用 show 方法      show(new Dog());  // 以 Dog 对象调用 show 方法      Animal a = new Cat();  // 向上转型        a.eat();               // 调用的是 Cat 的 eat      Cat c = (Cat)a;        // 向下转型        c.work();        // 调用的是 Cat 的 work  }      public static void show(Animal a)  {      a.eat();          // 类型判断        if (a instanceof Cat)  {  // 猫做的事情             Cat c = (Cat)a;              c.work();          } else if (a instanceof Dog) { // 狗做的事情             Dog c = (Dog)a;              c.work();          }      }  }abstract class Animal {      abstract void eat();  }  class Cat extends Animal {      public void eat() {          System.out.println(&quot;吃鱼&quot;);      }      public void work() {          System.out.println(&quot;抓老鼠&quot;);      }  }  class Dog extends Animal {      public void eat() {          System.out.println(&quot;吃骨头&quot;);      }      public void work() {          System.out.println(&quot;看家&quot;);      }  }</code></pre><p>执行以上程序，输出结果为：</p><pre><code>吃鱼抓老鼠吃骨头看家吃鱼抓老鼠</code></pre><p>java多态，如何理解父类引用指向子类对象</p><p>要理解多态性，首先要知道什么是“向上转型”。</p><p>我定义了一个子类Cat，它继承了Animal类，那么后者就是前者是父类。我可以通过   Cat c = new Cat(); 实例化一个Cat的对象，这个不难理解。</p><p>但当我这样定义时：   Animal a = new Cat();  </p><p>表示定义了一个Animal类型的引用，指向新建的Cat类型的对象。由于Cat是继承自它的父类Animal，所以Animal类型的引用是可以指向Cat类型的对象的。</p><p>那么这样做有什么意义呢？因为子类是对父类的一个改进和扩充，所以一般子类在功能上较父类更强大，属性较父类更独特，   定义一个父类类型的引用指向一个子类的对象既可以使用子类强大的功能，又可以抽取父类的共性。 </p><p>所以，父类类型的引用可以调用父类中定义的所有属性和方法，而对于子类中定义而父类中没有的方法，它是无可奈何的；   同时，父类中的一个方法只有在父类中定义而在子类中没有重写的情况下，才可以被父类类型的引用调用；   对于父类中定义的方法，如果子类中重写了该方法，那么父类类型的引用将会调用子类中的这个方法，这就是动态连接。也可以叫做动态绑定。</p><p>动态绑定是指”在执行期间（而非编译期间）“判断所引用对象的实际类型，根据实际的类型调用其相应的方法。</p><p>看下面这段程序：</p><pre><code>class Father {    public void func1()    {        func2();    } // 这是父类中的func2()方法，因为下面的子类中重写了该方法 ，所以在父类类型的引用中调用时，这个方法将不再有效，取而代之的是将调用子类中重写的func2()方法    public void func2() {        System.out.println(&quot;AAA&quot;);    }}class Child extends Father { // func1(int i)是对func1()方法的一个重载   由于在父类中没有定义这个方法，所以它不能被父类类型的引用调用    所以在下面的main方法中child.func1(68)是不对的    public void func1(int i) {        System.out.println(&quot;BBB&quot;);    } // func2()重写了父类Father中的func2()方法   如果父类类型的引用中调用了func2()方法，那么必然是子类中重写的这个方法    public void func2() {        System.out.println(&quot;CCC&quot;);    }}public class PolymorphismTest {    public static void main(String[] args) {        Father child = new Child();        child.func1();// 打印结果将会是什么？ } }         上面的程序是个很典型的多态的例子。子类Child继承了父类Father，并重载了父类的func1()方法，重写了父类的func2()方法。重载后的 func1(int i)和func1()不再是同一个方法，由于父类中没有func1(int i)，那么，父类类型的引用child就不能调用func1(int  i)方法。而子类重写了func2()方法，那么父类类型的引用child在调用该方法时将会调用子类中重写的func2()    }}</code></pre><p>那么该程序将会打印出什么样的结果呢？       很显然，应该是“CCC”。     </p><p>对于多态，可以总结它为：       </p><p>一、使用父类类型的引用指向子类的对象；</p><p>二、该引用只能调用父类中定义的方法和变量；</p><p>三、如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法；（动态连接、动态调用）</p><p>四、变量不能被重写（覆盖），”重写“的概念只针对方法，如果在子类中”重写“了父类中的变量，那么在编译时会报错。</p><p>多态的3个必要条件：<br>1.继承   2.重写   3.父类引用指向子类对象。</p><p>向上转型： Person p = new Man() ; //向上转型不需要强制类型转化<br>向下转型： Man man = (Man)new Person() ; //必须强制类型转化</p><h2 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h2><p>我们将介绍在Java中，当设计类时，被重写的方法的行为怎样影响多态性。<br>我们已经讨论了方法的重写，也就是子类能够重写父类的方法。<br>当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。<br>要想调用父类中被重写的方法，则必须使用关键字super。</p><pre><code>/* 文件名 : Employee.java */public class Employee {   private String name;   private String address;   private int number;   public Employee(String name, String address, int number) {      System.out.println(&quot;Employee 构造函数&quot;);      this.name = name;      this.address = address;      this.number = number;   }   public void mailCheck() {      System.out.println(&quot;邮寄支票给： &quot; + this.name       + &quot; &quot; + this.address);   }   public String toString() {      return name + &quot; &quot; + address + &quot; &quot; + number;   }   public String getName() {      return name;   }   public String getAddress() {      return address;   }   public void setAddress(String newAddress) {      address = newAddress;   }   public int getNumber() {     return number;   }}</code></pre><p>假设下面的类继承Employee类：</p><pre><code>/* 文件名 : Salary.java */public class Salary extends Employee{   private double salary; // 全年工资   public Salary(String name, String address, int number, double salary) {       super(name, address, number);       setSalary(salary);   }   public void mailCheck() {       System.out.println(&quot;Salary 类的 mailCheck 方法 &quot;);       System.out.println(&quot;邮寄支票给：&quot; + getName()       + &quot; ，工资为：&quot; + salary);   }   public double getSalary() {       return salary;   }   public void setSalary(double newSalary) {       if(newSalary &gt;= 0.0) {          salary = newSalary;       }   }   public double computePay() {      System.out.println(&quot;计算工资，付给：&quot; + getName());      return salary/52;   }}</code></pre><p>现在我们仔细阅读下面的代码，尝试给出它的输出结果：</p><pre><code>/* 文件名 : VirtualDemo.java */public class VirtualDemo {   public static void main(String [] args) {      Salary s = new Salary(&quot;员工 A&quot;, &quot;北京&quot;, 3, 3600.00);      Employee e = new Salary(&quot;员工 B&quot;, &quot;上海&quot;, 2, 2400.00);      System.out.println(&quot;使用 Salary 的引用调用 mailCheck -- &quot;);      s.mailCheck();      System.out.println(&quot;\n使用 Employee 的引用调用 mailCheck--&quot;);      e.mailCheck();    }}</code></pre><p>以上实例编译运行结果如下：</p><pre><code>Employee 构造函数Employee 构造函数使用 Salary 的引用调用 mailCheck -- Salary 类的 mailCheck 方法 邮寄支票给：员工 A ，工资为：3600.0使用 Employee 的引用调用 mailCheck--Salary 类的 mailCheck 方法 邮寄支票给：员工 B ，工资为：2400.0</code></pre><p>例子解析</p><p>实例中，实例化了两个 Salary 对象：一个使用 Salary 引用 s，另一个使用 Employee 引用 e。<br>当调用 s.mailCheck() 时，编译器在编译时会在 Salary 类中找到 mailCheck()，执行过程 JVM 就调用 Salary 类的 mailCheck()。<br>因为 e 是 Employee 的引用，所以调用 e 的 mailCheck() 方法时，编译器会去 Employee 类查找 mailCheck() 方法 。<br>在编译的时候，编译器使用 Employee 类中的 mailCheck() 方法验证该语句， 但是在运行的时候，Java虚拟机(JVM)调用的是 Salary 类中的 mailCheck() 方法。<br>以上整个过程被称为虚拟方法调用，该方法被称为虚拟方法。<br>Java中所有的方法都能以这种方式表现，因此，重写的方法能在运行时调用，不管编译的时候源代码中引用变量是什么数据类型。</p><p>多态的实现方式：</p><p>方式一：重写：<br>这个内容已经在上一章节详细讲过，就不再阐述，详细可访问：Java 重写(Override)与重载(Overload)。<br>方式二：接口</p><ol><li>生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。</li><li>java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 java接口 这一章节的内容。<br>方式三：抽象类和抽象方法</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JAVA基础总结，持续更新，以防忘记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="javaSE" scheme="http://yoursite.com/tags/javaSE/"/>
    
  </entry>
  
  <entry>
    <title>Ajax技术浅谈</title>
    <link href="http://yoursite.com/2018/03/31/java-ajax/"/>
    <id>http://yoursite.com/2018/03/31/java-ajax/</id>
    <published>2018-03-31T06:05:40.000Z</published>
    <updated>2018-03-31T07:36:29.088Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是Ajax？"><a href="#什么是Ajax？" class="headerlink" title="什么是Ajax？"></a>什么是Ajax？</h1><p>AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。</p><p>AJAX 是一种用于创建快速动态网页的技术。</p><p>通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 AJAX）如果需要更新内容，必须重载整个网页页面。AJAX 技术的广泛使用，对B/S模式应用慢慢取代了桌面软件起到了很大的推动作用。<br><a id="more"></a></p><h1 id="同步and异步？"><a href="#同步and异步？" class="headerlink" title="同步and异步？"></a>同步and异步？</h1><p>异步传输是面向字符的传输，它的单位是字符；而同步传输是面向比特的传输，它的单位是桢，它传输的时候要求接受方和发送方的时钟是保持一致的。</p><h2 id="异步传输"><a href="#异步传输" class="headerlink" title="异步传输"></a>异步传输</h2><p>具体来说，异步传输是将比特分成小组来进行传送。一般每个小组是一个8位字符，在每个小组的头部和尾部都有一个开始位和一个停止位，它在传送过程中接收方和发送方的时钟不要求一致，也就是说，发送方可以在任何时刻发送这些小组，而接收方并不知道它什么时候到达。</p><p>一个最明显的例子就是计算机键盘和主机的通信，按下一个键的同时向主机发送一个8比特位的ASCII代 码，键盘可以在任何时刻发送代码，这取决于用户的输入速度，内部的硬件必须能够在任何时刻接收一个键入的字符。这是一个典型的异步传输过程。</p><p>异步传输存在 一个潜在的问题，即接收方并不知道数据会在什么时候到达。在它检测到数据并做出响应之前，第一个比特已经过去了。这就像有人出乎意料地从后面走上来跟你说 话，而你没来得及反应过来，漏掉了最前面的几个词。因此，每次异步传输的信息都以一个起始位开头，它通知接收方数据已经到达了，这就给了接收方响应、接收 和缓存数据比特的时间；在传输结束时，一个停止位表示该次传输信息的终止。按照惯例，空闲（没有传送数据）的线路实际携带着一个代表二进制1的信号。步传输的开始位使信号变成0，其他的比特位使信号随传输的数据信息而变化。最后，停止位使信号重新变回1，该信号一直保持到下一个开始位到达。例如在键盘上数字“1”，按照8比特位的扩展ASCII编码，将发送“00110001”，同时需要在8比特位的前面加一个起始位，后面一个停止位。</p><h2 id="同步传输"><a href="#同步传输" class="headerlink" title="同步传输"></a>同步传输</h2><p>同步传输的比特分组要大得多。它不是独立地发送每个字符，每个字符都有自己的开始位和停止位，而是把它们组合起来一起发送。我们将这些组合称为数据帧，或简称为帧。</p><p>数据帧的第一部分包含一组同步字符，它是一个独特的比特组合，类似于前面提到的起始位，用于通知接收方一个帧已经到达，但它同时还能确保接收方的采样速度和比特的到达速度保持一致，使收发双方进入同步。</p><p>帧的最后一部分是一个帧结束标记。与同步字符一样，它也是一个独特的比特串，类似于前面提到的停止位，用于表示在下一帧开始之前没有别的即将到达的数据了。</p><p>同步传输通常要比异步传输快速得多。接收方不必对每个字符进行开始和停止的操作。一旦检测到帧同步字符，它就在接下来的数据到达时接收它们。另外，同步传输的开销也比较少。例如，一个典型的帧可能有500字节（即4000比特）的数据，其中可能只包含100比特的开销。这时，增加的比特位使传输的比特总数增加2.5%，这与异步传输中25 %的增值要小得多。随着数据帧中实际数据比特位的增加，开销比特所占的百分比将相应地减少。但是，数据比特位越长，缓存数据所需要的缓冲区也越大，这就限制了一个帧的大小。另外，帧越大，它占据传输媒体的连续时间也越长。在极端的情况下，这将导致其他用户等得太久。</p><p>了解了同步和异步的概念之后，大家应该对ajax为什么可以提升用户体验应该比较清晰了，它是利用异步请求方式的。打个比方，如果现在你家里所在的小区因 某种情况而面临停水，现在有关部门公布了两种方案，一是完全停水8个小时，在这8个小时内完全停水，8个小时后恢复正常。二是不完全停水10 个小时，在这10个小时内水没有完全断，只是流量比原来小了很多，在10个小时后恢复正常流量，那么，如果是你你会选择哪种方式呢？显然是后者。</p><h1 id="AJAX-所包含的技术"><a href="#AJAX-所包含的技术" class="headerlink" title="AJAX 所包含的技术"></a>AJAX 所包含的技术</h1><p>大家都知道ajax并非一种新的技术，而是几种原有技术的结合体。它由下列技术组合而成。</p><p>1.使用CSS和XHTML来表示。<br>2.使用DOM模型来交互和动态显示。<br>3.使用XMLHttpRequest来和服务器进行异步通信。<br>4.使用javascript来绑定和调用。</p><p>在上面几中技术中，除了XmlHttpRequest对象以外，其它所有的技术都是基于web标准并且已经得到了广泛使用的，XMLHttpRequest虽然目前还没有被W3C所采纳，但是它已经是一个事实的标准，因为目前几乎所有的主流浏览器都支持它。</p><h1 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h1><p>Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。要清楚这个过程和原理，我们必须对 XMLHttpRequest有所了解。</p><p>XMLHttpRequest是ajax的核心机制，它是在IE5中首先引入的，是一种支持异步请求的技术。简单的说，也就是javascript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。<br>所以我们先从XMLHttpRequest讲起，来看看它的工作原理。<br>首先，我们先来看看XMLHttpRequest这个对象的属性。<br>它的属性有：</p><p>onreadystatechange  每次状态改变所触发事件的事件处理程序。<br>responseText     从服务器进程返回数据的字符串形式。<br>responseXML    从服务器进程返回的DOM兼容的文档数据对象。<br>status           从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪）<br>status Text       伴随状态码的字符串信息<br>readyState       对象状态值<br>　　0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法）<br>　　1 (初始化) 对象已建立，尚未调用send方法<br>　　2 (发送数据) send方法已调用，但是当前的状态及http头未知<br>　　3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误，<br>　　4 (完成) 数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据<br>通常都是用readystate==4这个状态码判断传输是否完成。</p><h1 id="如何使用Ajax技术呢？"><a href="#如何使用Ajax技术呢？" class="headerlink" title="如何使用Ajax技术呢？"></a>如何使用Ajax技术呢？</h1><p>这里通常我们开发WEB项目若是用到Ajax技术，首先先要创建XMLHttpRequest这个对象，以为这是一个公共代码，我们可以直接在单独的js脚本文件中创建这个对象，以便所有的html5中都可以使用这个对象，只需要<script>调用这个js脚本即可。</p><pre><code>//获得ajax对象 function getXhr(){          var xhr=null;          if(window.XMLHttpRequest){              //非ie浏览器              xhr=new XMLHttpRequest();          }else{              //ie浏览器              xhr=new ActiveXObject(                      &quot;Microsoft.XMLHttp&quot;);          }          return xhr;}</code></pre><p>因为IE和其他浏览器的纷争，这里是W3C制定的统一规范，本来是微软发明的，但是微软不肯将自己的技术交给W3C，因此出现了IE浏览器要和其他浏览器做一个if判定。（中间微软和W3C关于ajax技术的所有权可以去看下相关报道）</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;     function check_adminCode(){         //step1:先获得ajax对象         //在ajax.js文件中，外部引入         var xhr=getXhr();         //弹出这个xhr对象信息,测试js代码是否正确         //当触发事件的时候会调用这个函数       //alert(xhr);         //step2:发送请求         //a.准备工作(请求方式,发送地址?数据,是否异步)         //因为是get方式发送         //所以路径后面是要传递的数据         //$F是取得根据该节点id取得对应的值         var uri=&apos;check_admin.do?adminCode=&apos; + $F(&apos;adminCode&apos;);         //encodeURI是javascript函数，         xhr.open(&apos;get&apos;,encodeURI(uri),true);         //b.绑定事件处理函数         //用于处理服务器返回数据并用于展现         //因为事件处理函数也需要xhr对象进行判断         //所以这里的事件处理函数直接用匿名函数来写就好         xhr.onreadystatechange=function(){             //step3是编写服务器端的相关带代码             //step4编写事件处理函数             if(xhr.readyState==4 &amp;&amp; xhr.status==200){                 //通信状态为4，表示其完全收到服务端传来的数据                 //status为200，即表示成功                 var res=xhr.responseText;//返回的是文本                 //并将数据进行展示                // alert(res);弹出警告的方式不友好                 //先找到要显示的位置span标签                 //innerHTML是输出文本信息                 $(&apos;adminCode_msg&apos;).innerHTML=res;             }         };         //c.发送         //get方式的参数是null，post则是数据         xhr.send(null);     }&lt;/script&gt;</code></pre><p>以上这些代码是根据传统的模式，调用XMLHttpRequest对象的属性去赋值，显然太过麻烦。</p><p>一般是采用和Jquery框架结合的方法：<br>通过jQuery内置的$.ajax({“attribute”:”value”…});的写法即可完成异步传输。</p><pre><code>function quoto(){      //利用jQuery提供的方法来向服务器发送请求      $.ajax({          //url发送请求，然后服务器就会返回数据          &quot;url&quot;:&quot;quoto.do&quot;,          &quot;type&quot;:&quot;post&quot;,          &quot;dataType&quot;:&quot;json&quot;,          &quot;success&quot;:function(stocks){              //事件处理函数              //dataType会自动将json字符串转换为js对象              //success指定的这个匿名函数中的参数              //就是经过jquery转换的那个javascript对象              //追加数据之前要先清空之前的表格内容tbody              //不是remove而是empty。数据清空              $(&apos;#tb1&apos;).empty();              //因为服务器传来的数据是一个数组              //所以需要遍历输出              for(i=0;i&lt;stocks.length;i++){                  //注意js中没有int类型，统统都用var                  //所以用for循环的时候要注意                  var s=stocks[i];                  //更新表格                  //往tbody标签中插入数据,循环插入                  $(&apos;#tb1&apos;).append(                          &apos;&lt;tr&gt;&lt;td&gt;&apos; + s.code +                          &apos;&lt;/td&gt;&lt;td&gt;&apos; + s.name +                           &apos;&lt;/td&gt;&lt;td&gt;&apos; + s.price +                           &apos;&lt;/td&gt;&lt;/tr&gt;&apos;);              }          }      });  }</code></pre><h1 id="AJAX-的缺点"><a href="#AJAX-的缺点" class="headerlink" title="AJAX 的缺点"></a>AJAX 的缺点</h1><p>AJAX的优点不言而喻。</p><p>下面所阐述的ajax的缺陷都是它先天所产生的。<br>1、ajax干掉了back按钮，即对浏览器后退机制的破坏。后退按钮是一个标准的web站点的重要功能，但是它没法和js进行很好的合作。这是ajax所带来的一个比较严重的问题，因为用户往往是希望能够通过后退来取消前一次操作的。那么对于这个问题有没有办法？答案是肯定的，用过Gmail的知道，Gmail下面采用的ajax技术解决了这个问题，在Gmail下面是可以后退的，但是，它也并不能改变ajax的机制，它只是采用的一个比较笨但是有效的办法，即用户单击后退按钮访问历史记录时，通过创建或使用一个隐藏的IFRAME来重现页面上的变更。（例如，当用户在Google Maps中单击后退时，它在一个隐藏的IFRAME中进行搜索，然后将搜索结果反映到Ajax元素上，以便将应用程序状态恢复到当时的状态。）<br>但是，虽然说这个问题是可以解决的，但是它所带来的开发成本是非常高的，和ajax框架所要求的快速开发是相背离的。这是ajax所带来的一个非常严重的问题。</p><p>2、安全问题<br>技术同时也对IT企业带来了新的安全威胁，ajax技术就如同对企业数据建立了一个直接通道。这使得开发者在不经意间会暴露比以前更多的数据和服务器逻辑。ajax的逻辑可以对客户端的安全扫描技术隐藏起来，允许黑客从远端服务器上建立新的攻击。还有ajax也难以避免一些已知的安全弱点，诸如跨站点脚步攻击、SQL注入攻击和基于credentials的安全漏洞等。</p><p>3、对搜索引擎的支持比较弱。</p><p>4、破坏了程序的异常机制。至少从目前看来，像ajax.dll，ajaxpro.dll这些ajax框架是会破坏程序的异常机制的。关于这个问题，我曾经在开发过程中遇到过，但是查了一下网上几乎没有相关的介绍。后来我自己做了一次试验，分别采用ajax和传统的form提交的模式来删除一条数据……给我们的调试带来了很大的困难。</p><p>5、另外，像其他方面的一些问题，比如说违背了url和资源定位的初衷。例如，我给你一个url地址，如果采用了ajax技术，也许你在该url地址下面看到的和我在这个url地址下看到的内容是不同的。这个和资源定位的初衷是相背离的。</p><p>6、一些手持设备（如手机、PDA等）现在还不能很好的支持ajax，比如说我们在手机的浏览器上打开采用ajax技术的网站时，它目前是不支持的，当然，这个问题和我们没太多关系。</p></script></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是Ajax？&quot;&gt;&lt;a href=&quot;#什么是Ajax？&quot; class=&quot;headerlink&quot; title=&quot;什么是Ajax？&quot;&gt;&lt;/a&gt;什么是Ajax？&lt;/h1&gt;&lt;p&gt;AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。&lt;/p&gt;
&lt;p&gt;AJAX 是一种用于创建快速动态网页的技术。&lt;/p&gt;
&lt;p&gt;通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 AJAX）如果需要更新内容，必须重载整个网页页面。AJAX 技术的广泛使用，对B/S模式应用慢慢取代了桌面软件起到了很大的推动作用。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="ajax" scheme="http://yoursite.com/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>谈SAAS</title>
    <link href="http://yoursite.com/2018/03/31/SAAS/"/>
    <id>http://yoursite.com/2018/03/31/SAAS/</id>
    <published>2018-03-30T16:37:39.000Z</published>
    <updated>2018-03-30T17:29:35.547Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Saas"><a href="#Saas" class="headerlink" title="Saas"></a>Saas</h1><p>SaaS是Software-as-a-Service（软件即服务）的简称，随着互联网技术的发展和应用软件的成熟， 在21世纪开始兴起的一种完全创新的软件应用模式。它与“on-demand software”（按需软件)，the application service provider(ASP，应用服务提供商)，hosted software(托管软件)所具有相似的含义。它是一种通过Internet提供软件的模式，厂商将应用软件统一部署在自己的服务器上，客户可以根据自己实际需求，通过互联网向厂商定购所需的应用软件服务，按定购的服务多少和时间长短向厂商支付费用，并通过互联网获得厂商提供的服务。<br><a id="more"></a></p><p>用户不用再购买软件，而改用向提供商租用基于Web的软件，来管理企业经营活动，且无需对软件进行维护，服务提供商会全权管理和维护软件，软件厂商在向客户提供互联网应用的同时，也提供软件的离线操作和本地数据存储，让用户随时随地都可以使用其定购的软件和服务。对于许多小型企业来说，SaaS是采用先进技术的最好途径，它消除了企业购买、构建和维护基础设施和应用程序的需要。</p><p>SaaS 应用软件的价格通常为“全包”费用，囊括了通常的应用软件许可证费、软件维护费以及技术支持费，将其统一为每个用户的月度租用费。 对于广大中小型企业来说，SaaS是采用先进技术实施信息化的最好途径。但SaaS绝不仅仅适用于中小型企业，所有规模的企业都可以从SaaS中获利。</p><p>SaaS有什么特别之处呢？其实在云计算还没有盛行的时代，我们已经接触到了一些SaaS的应用，通过浏览器我们可以使用Google、百度等搜索系统，可以使用E-mail，我们不需要在自己的电脑中安装搜索系统或者邮箱系统。典型的例子，我们在电脑上使用的Word、Excel、PowerPoint等办公软件，这些都是需要在本地安装才能使用的；而在GoogleDocs（DOC、XLS、ODT、ODS、RTF、CSV和PPT等）、MicrosoftOfficeOnline（WordOnline、ExcelOnline、PowerPointOnline和OneNoteOnline）网站上，无需在本机安装，打开浏览器，注册帐号，可以随时随地通过网络来使用这些软件编辑、保存、阅读自己的文档。对于用户只需要自由自在地使用，不需要自己去升级软件、维护软件等操作。由用户自主维护转化为公司为这些项目服务提供全套托管，用户不用担心升级软件所需要的东西，无需维护产品的安装包，全部操作都在WEB端进行。用户购买软件产品转为在网站租用公司的产品服务费用，改成租赁的形式。</p><p>关于这些数据的安全性，SaaS提供商通过有效的技术措施，可以保证每家企业数据的安全性和保密性。</p><p>SaaS采用灵活租赁的收费方式。一方面，企业可以按需增减使用帐号；另一方面，企业按实际使用账户和实际使用时间（以月/年计）付费。由于降低了成本，SaaS的租赁费用较之传统软件许可模式更加低廉。<br>企业采用SaaS模式在效果上与企业自建信息系统基本没有区别，但节省了大量资金，从而大幅度降低了企业信息化的门槛与风险。</p><p>这就是软件即服务。由以前去买软件，到现在去买服务。</p><p>CRM即客户关系管理（client relation message）<br>ERP系统是企业资源计划(Enterprise Resource Planning )的简称，企业全面化管理平台<br>EHR即电子人力资源管理系统（electric-human resources）<br>SCM即软件配置管理（software configuration Message）<br>OA即办公自动化平台（Office Automation）</p><p><strong>应该都可以Saas化</strong></p><p>a、实际上saas主要在CRM软件领域应用广泛。<br>b、另外，进销存，物流软件等也是一种应用。<br>C、更广义的是工具化SaaS，比如视频会议租用等，企业邮箱等成为SaaS应用的主要应用。</p><p>优点<br>对企业来说，SaaS的优点在于：<br>⒈ 从技术方面来看：SaaS是简单的部署，不需要购买任何硬件，刚开始只需要简单注册即可。企业无需再配备IT方面的专业技术人员，同时又能得到最新的技术应用，满足企业对信息管理的需求。<br>⒉ 从投资方面来看：企业只以相对低廉的“月费”方式投资，不用一次性投资到位，不占用过多的营运资金，从而缓解企业资金不足的压力；不用考虑成本折旧问题，并能及时获得最新硬件平台及最佳解决方案。<br>⒊ 从维护和管理方面来看：由于企业采取租用的方式来进行物流业务管理，不需要专门的维护和管理人员，也不需要为维护和管理人员支付额外费用。很大程度上缓解企业在人力、财力上的压力，使其能够集中资金对核心业务进行有效的运营；SaaS能使用户在世界上都是一个完全独立的系统。如果您连接到网络，就可以访问系统。</p><p>缺点<br>1.安全性：企业，尤其是大型企业，很不情愿使用SaaS正是因为安全问题，他们要保护他们的核心数据，不希望这些核心数据由第三方来负责。<br>2.标准化：SaaS解决方案缺乏标准化。这个行业刚刚起步，没有明确的解决办法，一家公司可以设计建立一个解决方案。鉴于复杂和高度可定制的ERP产品，这是一个冒险的建议。</p><h1 id="关于Saas的数据安全"><a href="#关于Saas的数据安全" class="headerlink" title="关于Saas的数据安全"></a>关于Saas的数据安全</h1><p>软件即服务已成为了流行的趋势，整个SaaS的范畴涵盖了广泛的用户可以获取并利用的应用，而SaaS的普及也代表着在未来随着互联网的发展，用户不必再投资于任何服务器或是自己的设备上安装任何软件。<br>从包含了在线Office应用程序的GoogleApps到Adobe的Buzzword服务，以及通过LiveOffice和Hotmail提供的电子邮件及即时消息服务都是很好的SaaS的例证。同时，你还会发现大量的在线备份和数据保护服务，无论是IronMoutain还是AmeriVault，当然，其中还包括一些规模较大的供应商，如EMC、IBM、HP，也加入到了这个市场中来，正在日益将其发展方向转向服务以扩大他们的市场。<br>通过提供这些软件，企业们提供了SaaS服务或是将你的数据存放在他的服务器上，以及获取捏计算机系统，所以，引伸出一个问题：用户使用这些服务的安全性到底如何？<br>“中小型企业必须非常谨慎的挑选供应商以存储他们宝贵的数据。”分析机构IDC的分析师Laura DuBois表示，这位分析师一直关注在线存储服务以及SaaS领域的发展动向，曾在一篇文章中表示，由于在线存储服务来势汹汹，IDC甚至没有为其准备好一个相应的分类方法。<br>很明显，可取的做法是尽可能多的了解该公司是如何提供SaaS服务的，他们为了您的信息的安全做了什么？如果你需要恢复数据，需要多久才能收到？该公司是否能够在低迷而又不稳定的市场中长久生存下去？这些都是你应该问问自己的关键问题–只有做出满意的答案才能够任何选择SaaS供应商的决定。<br>SaaS能够节省用户在部署应用时捆绑的软件许可、硬件以及管理成本，但是这并不意味着SaaS就是每一个人都是使用的。当打算选择一家SaaS供应商时，你应该深入了解这家供应商到底能够提供多少实质性内容，反面的典型就是不愿意向用户提供详细的参考资料或是只有很低用户口碑度。<br>“在SaaS的世界里，留住用户的数字是一个非常重要的宣传。”LiveOffice公司的总裁Matt Smith这样认为，他的公司提供电子邮件、即时消息以及其它SaaS产品，”一个可靠的公司的客户保持率应该至少在98%。”<br>如果这是一家刚刚成立的没有太多用户听说过的初创厂商，你就需要进行更加彻底的调查，以核实其原有的一些用户是否成功交付了。<br>从另一个角度来看，评价一个SaaS提供商还要看用户的支持度，也许有些供应商的设备看起来是豪华的，但是却可能是华而不实的并不中用，尤其是可能会很薄弱的售后支持，虽然在某些情况下，熟练的服务人员和专业的顶尖的技术支持可能与其高昂的价格相比并不值得。<br>“这实际上取决于公司想要什么，”Iron Mountain公司Digital Record Center for Images服务的总经理Tom Meyer认为，”一些供应商并不具备高度安全的内容管理系统，所以他们提供的在线存储空间价格低廉而且简单易行，但是这确实可能会被罚款的。”<br>很清楚的一件事是，安全应该是供应商在选择SaaS标准之前就应考虑的问题并且应该一直放在核心位置，这些在线服务提供商的一个重要的工作就是如何保持其数据的安全，并且确保保护这些数据的保障系统的安全，以免使其遭受灾难。<br>“小型企业的拥有者应该问问供应商如何存储他们的数据，”Smith认为，”<strong>一个好的供应商应该有多个镜像数据中心</strong>，这也就意味着客户端的数据备份在多个地点和多个时间内总是可以用的。”</p><p>SaaS厂商利用各种方式来保障他们的数据，他们其中的一些喜欢使用提供了数据加密功能的磁盘阵列，另外一些供应商的方法更加机械化，他们将数据存放在一个大的仓库中，并给予起一个孤立但是安全的位置。<br>Iron Mountain公司提供了一项名为Digital Record Center for Images的服务，这项服务为用户提供了数据加密传输、用户访问路径控制以及确保位于地下200英尺的数据中心的安全的服务。<br>备份和存储SaaS提供商Elephant Drive通过将数据存储在多个基于硬盘的存储池并进行复制的方法来保证用户数据的安全，数据复制保护功能被集成到其产品系统中，所有的数据都可以让用户在位于至少两个不同地点的独立站点进行访问。<br>AmeriVault也是一家在线备份服务提供商，其帮助用户在三个地点保存用户的备份数据，每个用户的数据都存放在两个不同的磁盘系统中，第三份备份则放置在1000公里之外的保证业务连续性的站点中。<br>在线备份提供商DS3则使用EMCClariion作为主存储设备，为了保证备份方便，他们将备份的数据保存在其他的高端磁盘系统中，在DS3的三个数据中心中，有一个数据中心专门用于保存用户的信息的备份。<br>“任何一家有个良好信誉的SaaS供应商都应该采取必要合适的措施确保他们服务器的安全，并且为每个用户都展现出所有的操作。”Smith表示。</p><p>服务满意度</p><p>服务级别协议是我们通常用来判断一个SaaS服务是否令用户满意的工具，SLA是一项针对提供某种程度上的稳定性的厂商的合同义务，Smith认为，当前使用SLA协议的用户达到了99%以上。<br>此外，SLA协议还包括如果合同到期的话，SaaS服务提供商应该如何处理用户数据的条款，在这种情况下，用户应该确保拥有这些信息的所有权，并且确认是受到法律保护的。<br>例如，Prince Street Capital Management公司采用了由Data Storage公司提供的备份服务，这项服务可以对企业的电子邮件系统实施保护，并对离线数据存储池进行保护，确保远程存储安全以及信息的快速恢复，SLA协议在其中也是一个重要的组成部分。<br>该公司的首席财务官Peter McKown表示，”在你寻找一款适合的备份和恢复解决方案时，对Microsoft Exchange的快速恢复是一个重要的考查标准，在选择了Data Storage服务作为我们的备份和恢复服务管理合作伙伴之后，我们的业务获得了充分的满足，服务水平超过了我们的想象。”</p><p>用户质疑SaaS是很正常的，但是从多个方面来看，在十几年前业界关于电子商务的不休争论时，这些质疑就已经存在了。<br>SaaS服务模式与传统许可模式软件有很大的不同，它是未来管理软件的发展趋势。相比较传统服务方式而言SaaS具有很多独特的特征：SaaS不仅减少了或取消了传统的软件授权费用，而且厂商将应用软件部署在统一的服务器上，免除了最终用户的服务器硬件、网络安全设备和软件升级维护的支出，客户不需要除了个人电脑和互联网连接之外的其它IT投资就可以通过互联网获得所需要软件和服务。此外，大量的新技术，如Web Service，提供了更简单、更灵活、更实用的SaaS。</p><p>另外，SaaS供应商通常是按照客户所租用的软件模块来进行收费的，因此用户可以根据需求按需订购软件应用服务，而且SaaS的供应商会负责系统的部署、升级和维护。而传统管理软件通常是买家需要一次支付一笔可观的费用才能正式启动。</p><p>ERP这样的企业应用软件，软件的部署和实施比软件本身的功能、性能更为重要，万一部署失败，那所有的投入几乎全部白费，这样的风险是每个企业用户都希望避免的。通常的ERP、CRM项目的部署周期至少需要一两年甚至更久的时间，而SaaS模式的软件项目部署通常只占五分之一时间，而且用户无需在软件许可证和硬件方面进行投资。传统软件在使用方式上受空间和地点的限制，必须在固定的设备上使用，而SaaS模式的软件项目可以在任何可接入互联网的地方与时间使用。相对于传统软件而言，SaaS模式在软件的升级、服务、数据安全传输等各个方面都有很大的优势。</p><p>SaaS已成为软件产业的一个重要力量。只要SaaS的品质和可信度能继续得到证实，它的魅力就不会消退。例如中企云软基于excel平台和excel服务器，使这一服务云端化，支持在线定制，在线服务，在线使用，让用户无需自建服务器即可轻松拥有saas+paas的平台。而协达软件的渡云SAAS则通过“微商务”的方式让用户低成本使用简洁易用的微型SAAS应用功能，从而逐步升级到更贴身的应用功能上。</p><p>过去，很多中小企业对于数据安全都有所顾虑，他们不知道是不是可以信任那些初创厂商，或是不太确定电子商务是一个稳定的业务模式，但是在10年之后，似乎每个人都多多少少和电子商务有所联系，不过，要是想让企业也接受这个全新的技术还要等一段时间。</p><p>同样的，SaaS服务也需要经历这样的循环，赢得人们的信任是SaaS服务提供商们不得不面对的一项日产共工作，但是对于那些只有几个技术人员或是根本没有IT部门的中小企业来说，SaaS确实有很重要的作用，能够为企业提供他们必须要完成的工作。</p><p>同时，如果你是Prince Street公司的话，或许你需要和多个厂商合作，DuBois认为，在判断究竟哪一个供应商才是可信的时候，用户需要问自己三个问题：谁是技术提供商？谁是管理他们数据的供应商？谁负责建设数据中心和他们的基本数据架构？</p><p>她认为：”在很多情况下，这些问题的答案指向不同的三个厂商，因此每个层次都会有危险存在，在任何情况下，用户要认真的了解隐私性、加密、可用性、恢复时间、SLA协议、成本以及合同期限等细节情况。”</p><p>总之，安全问题不容小觑，解决安全问题是SaaS模式继续存在并发展的前提，而周全的考虑各方面的安全性则是中小企业在选择SaaS服务商时必须注意的问题。</p><h1 id="如何保证数据安全性"><a href="#如何保证数据安全性" class="headerlink" title="如何保证数据安全性"></a>如何保证数据安全性</h1><p>除了选择优秀的Saas提供商以外，我们还需要注意：<br>如何辨别具体的一种SaaS是否安全，需要把握以下几点：</p><p>1、传输协议加密<br>首先，要看SaaS产品提供使用的协议，是https://还是一般的http://，别小看这个s，这表明所有的数据在传输过程中都是加密的。如果不加密，网上可能有很多“嗅探器”软件能够轻松的获得您的数据，甚至是您的用户名和密码；实际上网上很多聊天软件帐号被盗大多数都是遭到“嗅探器”的“招”了。<br>其次，传输协议加密还要看是否全程加密，即软件的各个部分都是https://协议访问的，有部分软件只做了登录部分，这是远远不够的。比如Salesforce、XToolsCRM都是采取全程加密的。<br>2、服务器安全证书<br>服务器安全证书是用户识别服务器身份的重要标示，有些不正规的服务厂商并没有使用全球认证的服务器安全证书。用户对服务器安全证书的确认，表示服务器确实是用户访问的服务器，此时可以放心的输入用户名和密码，彻底避免“钓鱼”型网站，大多数银行卡密码泄漏都是被“钓鱼”站钓上的。<br>3、URL数据访问安全码技术<br>对于一般用户来说，复杂的URL看起来只是一串没有意义的字符而已。但是对于一些IT高手来说，这些字符串中可能隐藏着一些有关于数据访问的秘密，通过修改URL，很多黑客可以通过诸如SQL注入等方式攻入系统，获取用户数据。<br>4、数据的管理和备份机制<br>SaaS服务商的数据备份应该是完善的，用户必须了解自己服务商为您提供了什么样的数据备份机制，一旦出现重大问题，如何恢复数据等。服务商在内部管理上如何保证用户数据不被服务商所泄露，也是需要用户和服务商沟通的。<br>5、运营服务系统的安全<br>在评估SaaS产品安全度的时侯，最重要的是看公司对于服务器格局的设置，只有这样的格局才是可以信任的，包括：运营服务器与网站服务器分离。<br>服务器的专用是服务器安全最重要的保证。试想，如果一台服务器安装了SaaS系统，但同时又安装了网站系统、邮件系统、论坛系统……，他还能安全吗?在黑客角度来说，越多的系统就意味着越多的漏洞，况且大多数网站使用的网站系统、邮件系统和论坛系统都是在网上能够找到源代码的免费产品，有了源代码，黑客就可以很容易攻入。很多网站被攻入都是因为论坛系统的漏洞。<br>因此，一个优秀的软件SaaS运营商，运营服务器和网站服务器应该完全隔离的，甚至域名也应该分开。</p><p>总而言之，SaaS 最大特色是虽是软件在线使用，数据却能本地存储，保证数据安全.（就是服务和数据是分离开的，数据在网络上传输，处理，然后汇集到本地的数据库里来，数据的储存虽然是本地储存，但是由于数据的交互全都是在网络上执行和传输，所以存在相当的风险。）</p><p><strong>“云”取代“SaaS”成为新的热点</strong></p><p>———更新线———</p><h1 id="云和Saas又有什么不同"><a href="#云和Saas又有什么不同" class="headerlink" title="云和Saas又有什么不同"></a>云和Saas又有什么不同</h1><p>云计算是Grid计算和（广义的基于SOA的）SaaS技术和理念融合、提升、和发展后的产物。</p><p>SaaS不是云计算，云计算也不等于SaaS。SaaS是云计算上的应用表现，云计算是SaaS的后端基础服务保障。</p><p>云计算将弱化SaaS门槛，促进SaaS发展。云计算应用直接剥离出去，将平台留下，做平台的始终做平台，做云计算资源的人专心做好资深的调度和服务。SaaS服务商只需要关注自己的软件功能表现，无需投入大量资金到后端基础系统建设。</p><p>因为SOA就是如此设计的，面向服务的架构，但是现在又有新的技术出来替代这个SOA设计模式了，那就是微服务架构，将软件开发完全的组件化。<br>当然云计算也是可以和微服务结合的。</p><p>云计算系统建立起来之后SaaS将获得跨越式的发展，云计算将大力推动SaaS发展。</p><p>根据NIST的权威定义，云计算有SPI， 即SaaS、PaaS和IaaS三大服务模式。这是目前被业界最广泛认同的划分。PaaS和IaaS源于SaaS理念。</p><p>1.SaaS：提供给客户的服务是运营商运行在云计算基础设施上的应用程序，用户可以在各种设备上通过搜客户端界面访问，如浏览器。消费者不需要管理或控制任何云计算基础设施，包括网络、服务器、操作系统、存储等等；<br>NIST云计算划分<br>NIST云计算划分<br>2.PaaS：提供给消费者的服务是把客户采用提供的开发语言和工具（例如Java，python, .Net等）开发的或收购的应用程序部署到供应商的云计算基础设施上去。客户不需要管理或控制底层的云基础设施，包括网络、服务器、操作系统、存储等，但客户能控制部署的应用程序，也可能控制运行应用程序的托管环境配置；<br>3。IaaS: 提供给消费者的服务是对所有设施的利用，包括处理器、存储、网络和其它基本的计算资源，用户能够部署和运行任意软件，包括操作系统和应用程序。消费者不管理或控制任何云计算基础设施，但能控制操作系统的选择、储存空间、部署的应用，也有可能获得有限制的网络组件（例如，防火墙，负载均衡器等）的控制。</p><h2 id="用云计算还是Saas？"><a href="#用云计算还是Saas？" class="headerlink" title="用云计算还是Saas？"></a>用云计算还是Saas？</h2><p>主要还是看需求。</p><p>一些网络声音总结：</p><p>云计算是一种新兴的共享基础架构的方法，可以将巨大的系统池连接在一起以提供各种基于互联网的IT服务。而IaaS、PaaS、SaaS是云计算最主要的三种落地方式。其中IaaS是第一层：基础设施即服务，代表公司：阿里云、腾讯云等；PaaS是第二层：平台即服务，代表公司：数人云；SaaS是第三层：软件即服务，代表公司：用友财务软件、微软office.</p><p>云计算（cloud computing）是基于互联网的相关服务的增加、使用和交付模式，通常涉及通过互联网来提供动态易扩展且经常是虚拟化的资源。 SaaS：提供给客户的服务是运营商运行在云计算基础设施上的应用程序，用户可以在各种设备上通过客户端界面访问，如浏览器，消费者不需要管理或控制任何云计算基础设施，包括网络、服务器、操作系统、存储等等 。SaaS带来的是商业模式的转变，云计算带来的是技术的变革。云计算不仅继承了SAAS的所有优点，而且在此基础上还创造了属于自己的特点。      云计算的出现，恰好解决了SaaS发展过程中面临的一些问题，当SaaS提供商的客户快速增加到一定程度，客户所消耗的巨大资源将迫使SaaS供应商提供更多的硬件资源，但由于成本的问题，SaaS又不想花费大量资金购买硬件或带宽资源的时候，云计算无疑是个不错的选择。根据通常的概念，云计算处于SaaS的更底层，而SaaS位于云计算和最终客户之间，如果SaaS在最初开发的时候是基于云计算架构的，那么就很容易利用云计算架构来获取海量的资源，并提供给最终用户。这就一劳永逸的解决SaaS发展的瓶颈问题。</p><p>等等。来自知乎</p><h1 id="与物联网的合作"><a href="#与物联网的合作" class="headerlink" title="与物联网的合作"></a>与物联网的合作</h1><p>物联网的两种业务模式</p><ol><li>MAI（M2M Application Integration), 内部MaaS</li><li>MaaS（M2M As A Service), MMO, Multi-Tenants(多租户模型）随着物联网业务量的增加，对数据存储和计算量的需求将带来对“云计算”能力的要求：<br>云计算：从计算中心到数据中心在物联网的初级阶段，PoP即可满足需求<br>在物联网高级阶段，可能出现MVNO/MMO营运商（国外已存在多年），需要虚拟化云计算技术，SOA等技术的结合实现物联网的泛在服务： TaaS （everyTHING As A Service)。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Saas&quot;&gt;&lt;a href=&quot;#Saas&quot; class=&quot;headerlink&quot; title=&quot;Saas&quot;&gt;&lt;/a&gt;Saas&lt;/h1&gt;&lt;p&gt;SaaS是Software-as-a-Service（软件即服务）的简称，随着互联网技术的发展和应用软件的成熟， 在21世纪开始兴起的一种完全创新的软件应用模式。它与“on-demand software”（按需软件)，the application service provider(ASP，应用服务提供商)，hosted software(托管软件)所具有相似的含义。它是一种通过Internet提供软件的模式，厂商将应用软件统一部署在自己的服务器上，客户可以根据自己实际需求，通过互联网向厂商定购所需的应用软件服务，按定购的服务多少和时间长短向厂商支付费用，并通过互联网获得厂商提供的服务。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具类" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
      <category term="软件架构" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
      <category term="云计算" scheme="http://yoursite.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Saas" scheme="http://yoursite.com/tags/Saas/"/>
    
  </entry>
  
  <entry>
    <title>JVM-GC机制</title>
    <link href="http://yoursite.com/2018/03/30/JVM-GC/"/>
    <id>http://yoursite.com/2018/03/30/JVM-GC/</id>
    <published>2018-03-30T04:30:17.000Z</published>
    <updated>2018-03-30T05:39:34.473Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么需要GC"><a href="#为什么需要GC" class="headerlink" title="为什么需要GC"></a>为什么需要GC</h1><p>应用程序对资源操作，通常简单分为以下几个步骤：</p><p>1、为对应的资源分配内存</p><p>2、初始化内存</p><p>3、使用资源</p><p>4、清理资源</p><p>5、释放内存<br><a id="more"></a></p><p>应用程序对资源（内存使用）管理的方式，常见的一般有如下几种：</p><p>1、手动管理：C,C++</p><p>2、计数管理：COM</p><p>3、自动管理：.NET,Java,PHP,GO…</p><p>但是，手动管理和计数管理的复杂性很容易产生以下典型问题：</p><p>1.程序员忘记去释放内存</p><p>2.应用程序访问已经释放的内存</p><p>产生的后果很严重，常见的如内存泄露、数据内容乱码，而且大部分时候，程序的行为会变得怪异而不可预测，还有Access Violation（访问违例）等。</p><p>.NET、Java等给出的解决方案，就是通过自动垃圾回收机制GC进行内存管理。这样，问题1自然得到解决，问题2也没有存在的基础。</p><p>总结：无法自动化的内存管理方式极容易产生bug，影响系统稳定性，尤其是线上多服务器的集群环境，程序出现执行时bug必须定位到某台服务器然后dump内存再分析bug所在，极其打击开发人员编程积极性，而且源源不断的类似bug让人厌恶。因此自动化的GC机制就很重要。</p><p>GC的工作流程主要分为如下几个步骤：</p><p>1、标记(Mark)</p><p>2、计划(Plan)</p><p>3、清理(Sweep)</p><p>4、引用更新(Relocate)</p><p>5、压缩(Compact)</p><p><img src="/2018/03/30/JVM-GC/main.png" alt="logo"><br>（一）、标记</p><p>目标：找出所有引用不为0(live)的实例</p><p>方法：找到所有的GC的根结点(GC Root), 将他们放到队列里，然后依次递归地遍历所有的根结点以及引用的所有子节点和子子节点，将所有被遍历到的结点标记成live。弱引用不会被考虑在内</p><p>（二）、计划和清理</p><p>1、计划</p><p>目标：判断是否需要压缩</p><p>方法：遍历当前所有的generation上所有的标记(Live),根据特定算法作出决策</p><p>2、清理</p><p>目标：回收所有的free空间</p><p>方法：遍历当前所有的generation上所有的标记(Live or Dead),把所有处在Live实例中间的内存块加入到可用内存链表中去</p><p>（三）、引用更新和压缩</p><p>1、引用更新</p><p>目标： 将所有引用的地址进行更新</p><p>方法：计算出压缩后每个实例对应的新地址，找到所有的GC的根结点(GC Root), 将他们放到队列里，然后依次递归地遍历所有的根结点以及引用的所有子节点和子子节点，将所有被遍历到的结点中引用的地址进行更新，包括弱引用。</p><p>2、压缩</p><p>目标：减少内存碎片</p><p>方法：根据计算出来的新地址，把实例移动到相应的位置。</p><p>GC的根节点也即GC Root是个什么东西呢？</p><p>每个应用程序都包含一组根（root）。每个根都是一个存储位置，其中包含指向引用类型对象的一个指针。该指针要么引用托管堆中的一个对象，要么为null。</p><p>在应用程序中，只要某对象变得不可达，也就是没有根（root）引用该对象，这个对象就会成为垃圾回收器的目标。</p><p>用一句简洁的英文描述就是:GC roots are not objects in themselves but are instead references to objects.而且，Any object referenced by a GC root will automatically survive the next garbage collection. </p><p>.NET中可以当作GC Root的对象有如下几种：</p><p>1、全局变量</p><p>2、静态变量</p><p>3、栈上的所有局部变量(JIT)</p><p>4、栈上传入的参数变量</p><p>5、寄存器中的变量</p><p>注意，只有引用类型的变量才被认为是根，值类型的变量永远不被认为是根。只有深刻理解引用类型和值类型的内存分配和管理的不同，才能知道为什么root只能是引用类型。</p><p>顺带提一下JAVA，在Java中，可以当做GC Root的对象有以下几种：</p><p>1、虚拟机（JVM）栈中的引用的对象</p><p>2、方法区中的类静态属性引用的对象</p><p>3、方法区中的常量引用的对象（主要指声明为final的常量值）</p><p>4、本地方法栈中JNI的引用的对象</p><h1 id="GC什么时候发生"><a href="#GC什么时候发生" class="headerlink" title="GC什么时候发生"></a>GC什么时候发生</h1><p>1、当应用程序分配新的对象，GC的代的预算大小已经达到阈值，比如GC的第0代已满</p><p>2、代码主动显式调用System.GC.Collect()，System.gc()；当然这只是建议GC去处理垃圾，而不是立刻执行，主动权完全在JVM上。</p><p>3、其他特殊情况，比如，windows报告内存不足、CLR卸载AppDomain、CLR关闭，甚至某些极端情况下系统参数设置改变也可能导致GC回收</p><h1 id="GC中的代"><a href="#GC中的代" class="headerlink" title="GC中的代"></a>GC中的代</h1><p>代（Generation)引入的原因主要是为了提高性能（Performance),以避免收集整个堆（Heap）。一个基于代的垃圾回收器做出了如下几点假设：<br>在JAV中也叫新生代和老年代。<br>1、对象越新，生存期越短</p><p>2、对象越老，生存期越长</p><p>3、回收堆的一部分，速度快于回收整个堆</p><p>.NET的垃圾收集器将对象分为三代（Generation0,Generation1,Generation2）。不同的代里面的内容如下：</p><p>1、G0 小对象(Size&lt;85000Byte)</p><p>2、G1:在GC中幸存下来的G0对象</p><p>3、G2:大对象(Size&gt;=85000Byte);在GC中幸存下来的G1对象</p><p>object o = new Byte[85000]; //large object<br>Console.WriteLine(GC.GetGeneration(o)); //output is 2,not 0<br>这里必须知道，CLR要求所有的资源都从托管堆（managed heap）分配，CLR会管理两种类型的堆，小对象堆（small object heap，SOH）和大对象堆（large object heap，LOH），其中所有大于85000byte的内存分配都会在LOH上进行。一个有趣的问题是为什么是85000字节？</p><p>代收集规则：当一个代N被收集以后，在这个代里的幸存下来的对象会被标记为N+1代的对象。GC对不同代的对象执行不同的检查策略以优化性能。每个GC周期都会检查第0代对象。大约1/10的GC周期检查第0代和第1代对象。大约1/100的GC周期检查所有的对象。</p><h1 id="使用GC"><a href="#使用GC" class="headerlink" title="使用GC"></a>使用GC</h1><p>（1）除了释放不再被引用的对象，垃圾收集器还要处理堆碎块。请求分配新对象时可能不得不增大堆空间的大小，虽然可以使用的空闲空间是足够的，但是堆中没有没有连续的空间放得下新对象。可能会导致虚拟机产生不必要的”内存不足“错误。</p><p>（2）使用垃圾收集堆，有一个潜在的缺陷就是加大程序的负担，可能影响程序的性能。因为虚拟机需要追踪哪些对象被正在执行的程序引用，还要动态释放垃圾对象。</p><p>（3）程序可以调用System.gc()建议jvm去收集垃圾， 但是不能为垃圾回收机制指定某个对象是不是垃圾。即便调用了gc（），并不会马上进行垃圾回收，甚至不一定会执行垃圾回收。所有的内存分配和回收权限都在jvm，不在开发人员手里。</p><p>Example：</p><pre><code>public class RubbishRelease {    // 类的finalize方法，可以告诉垃圾回收器应该执行的操作，该方法从Object类继承而来。    // 在从堆中永久删除对象之前，垃圾回收器调用该对象的finalize方法。    public void finalize() {        System.out.println(&quot;the Object is going...&quot;);    }    public static void main(String[] args) {        for (int i = 0; i &lt; 100; i++) {            // 下面不断创建对象，但是这些对象都没有被引用            new RubbishRelease();            new RubbishRelease();            new RubbishRelease();            System.gc();        }        System.out.println(&quot;The program is over!&quot;);    }}</code></pre><p>运行结果：</p><p><img src="/2018/03/30/JVM-GC/p1.png" alt="logo"></p><p>（4）垃圾收集算法有很多，但任何垃圾收集算法都必须做两件事情。首先，它必须检测出垃圾对象。其次，它必须回收垃圾对象所使用的堆空间并还给程序。</p><h2 id="区分活动对象和垃圾的两个基本方法是引用计数和跟踪"><a href="#区分活动对象和垃圾的两个基本方法是引用计数和跟踪" class="headerlink" title="区分活动对象和垃圾的两个基本方法是引用计数和跟踪"></a>区分活动对象和垃圾的两个基本方法是引用计数和跟踪</h2><p><strong>引用计数</strong>是垃圾收集的早期策略。在这种方法中，堆中每一个对象都有一个引用计数。一个对象被创建了，并且指向该对象的引用被分配给一个变量，这个对象的引用计数被置为1。当任何其他变量被赋值为对这个对象的引用时，计数加1。当一个对象的引用超过了生存期或者被设置一个新的值时，对象的引用计数减1。任何引用计数为0的对象可以被当作垃圾收集。当一个对象被垃圾收集的时候，它引用的任何对象计数值减1。这种方法的好处是，引用计数收集器可以很快地执行，交织在程序的运行之中。这个特性对于程序不能被长时间打断的实时环境很有利。坏处就是，引用计数无法检测出循环(即两个或者更多的对象互相引用)。</p><ul><li>引用计数算法（Reference Counting） java不用<br>介绍：给对象添加一个引用计数器，每当一个地方引用它时，数据器加1；当引用失效时，计数器减1；计数器为0的即可被回收。</li></ul><p>优点：实现简单，判断效率高</p><p>缺点：很难解决对象之间的相互循环引用（objA.instance = objB; objB.instance = objA）的问题，所以java语言并没有选用引用计数法管理内存</p><p><strong>跟踪收集器</strong>追踪从根节点开始的对象引用图。给追踪过程中遇到对象以某种方式打上标记。追踪结束时，未被标记的对象就是无法触及的，从而被收集。基本的追踪算法被称作“标记并清除”，这个名字指出垃圾收集过程的两个阶段。</p><ul><li>根搜索算法（GC Root Tracing）</li></ul><p>Java和C#都是使用根搜索算法来判断对象是否存活。通过一系列的名为“GC Root”的对象作为起始点，从这些节点开始向下搜索，搜索所有走过的路径称为引用链（Reference Chain）,当一个对象到GC Root没有任何引用链相连时（用图论来说就是GC Root到这个对象不可达时），证明该对象是可以被回收的。</p><p><img src="/2018/03/30/JVM-GC/p2.png" alt="logo"></p><p>在Java中哪些对象可以成为GC Root?（在上面提过了，再写一遍）</p><p>虚拟机栈（栈帧中的本地变量表）中的引用对象<br>方法区中的类静态属性引用的对象<br>方法区中的常量引用对象<br>本地方法栈中JNI（即Native方法）的引用对象</p><p>Java虚拟机的垃圾收集器可能有对付堆碎块的策略。<strong>标记并清除收集器通常使用的两种策略是压缩和拷贝</strong>。这两种方法都是快速地移动对象来减少堆碎块。</p><p><strong>压缩收集器</strong>把活动的对象越过空闲区滑动到堆的一端，在这个过程中，堆的另一端出现一个大的连续空闲区。所有被移动的对象的引用也被更新，指向新的位置。</p><p><strong>拷贝收集器</strong>把所有的活动的对象移动到一个新的区域。在拷贝过程中，被紧挨着布置，这样可以消除原本它们在旧区域的空隙。即空闲区。一般的拷贝收集器算法被称为“停止并拷贝”。此方案中，堆被分成两个区域，任何时候都使用一个区域。对象在同一个区域中分配直到被耗尽。此时，程序执行被中止，堆被遍历，遍历时遇到活动的对象被拷贝到另个区域。当停止和拷贝过程结束时，程序恢复执行。依次往复，对于指定大小的堆来说需要两倍大小的内存，由于任何时候都只使用其中的一半，这就是该方法带来的代价。</p><ul><li>复制算法（Copying）</li></ul><p>将内存划分为大小相等的两块，每次只使用其中的一块。当这块内存用完了，就将还存活的对象复制到另一块内存上，然后把已使用过的内存空间一次清理掉。</p><p><img src="/2018/03/30/JVM-GC/p4.png" alt="logo"></p><p>优点：每次只对其中一块进行GC,不用考虑内存碎片的问题，并且实现简单，运行高效</p><p>缺点：内存缩小了一半</p><p>注：现在的商业虚拟机都是用这种收集算法回收新生代。内存分为一块较大的Eden空间和两块较小的Survior空间，每次使用Eden和其中的一块Survior.当回收时，将Eden和Survior中还存活的对象一次性拷贝到另外一块Survior空间上，最后清理Eden和刚才用过的Survior空间。</p><p>按代收集：根据对象的存活周期（一次垃圾收集为一个周期）的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用拷贝算法，只需要付出少量存活对象的拷贝成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，可以使用“标记并清除”算法。</p><p>据对象的存活周期的不同将内存划分为几块，一般就分为新生代和老年代，根据各个年代的特点采用不同的收集算法。新生代（少量存活）用复制算法，老年代（对象存活率高）“标记-清理”算法</p><p>补充：分代划分内存介绍</p><p>整个JVM内存总共划分为三代：年轻代（Young Generation）、年老代（Old Generation）、持久代（Permanent Generation）</p><p>1、年轻代：所有新生成的对象首先都放在年轻代内存中。年轻代的目标就是尽可能快速的手机掉那些生命周期短的对象。年轻代内存分为一块较大的Eden空间和两块较小的Survior空间，每次使用Eden和其中的一块Survior.当回收时，将Eden和Survior中还存活的对象一次性拷贝到另外一块Survior空间上，最后清理Eden和刚才用过的Survior空间。</p><p>2、年老代：在年轻代经历了N次GC后，仍然存活的对象，就会被放在老年代中。因此可以认为老年代存放的都是一些生命周期较长的对象。</p><p>3、持久代：基本固定不变，用于存放静态文件，例如Java类和方法。持久代对GC没有显著的影响。持久代可以通过-XX:MaxPermSize=<n>进行设置。</n></p><p>终结方法（finalize），这个在上面第3点也有提到：这个方法是垃圾收集器在释放对象前必须运行。这个可能存在的终结方法使得任何Java虚拟机的垃圾收集器要完成的工作更加复杂。因为终结方法可能“复活”了某些不再被引用的对象（本身或者其他对象）。</p><p>堆中的每一个对象都有三种状态之一：可触及的、可复活的以及不可触及的。可触及状态好理解。关于可复活状态：它在从根节点开始的追踪图中不可触及，但是又可能在垃圾收集器执行某些终结方法时触及。不仅仅是那些声明了finalize方法的对象，而是所有的对象都要经过可复活状态。而不可触及状态标志着不但对象不再被触及，而且也不可能通过任何终结方法复活。不可触及的对象不再对程序的执行产生影响，可自由地回收它们占据的内存。</p><p>一些其他算法总结：</p><ul><li>标记-清除算法（Mark-Sweep）</li></ul><p>首先标记出需要回收的对象，在标记完成后统一回收掉所有的被标记对象。</p><p><img src="/2018/03/30/JVM-GC/p3.png" alt="logo"></p><p>缺点：效率问题和空间问题（标记清除后会产生大量的不连续内存碎片，内存碎片过多可能会导致程序需要分配较大对象时找不到足够大的连续内存空间而不得不提前触发另一次垃圾回收动作）</p><ul><li>标记-整理算法（Mark-Compact）</li></ul><p>　让所有存活对象都向一端移动，然后直接清理掉端边界以外的所有内存。<br><img src="/2018/03/30/JVM-GC/p5.png" alt="logo"></p><h2 id="对象的强，软，弱，虚引用。"><a href="#对象的强，软，弱，虚引用。" class="headerlink" title="对象的强，软，弱，虚引用。"></a>对象的强，软，弱，虚引用。</h2><p>强引用：如果一个对象具有强引用，垃圾回收器绝不会回收它。当内存空间不足，JVM宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会考随意回收具有强引用的对象来解决内存不足的问题。</p><p>软引用：如果一个对象具有软引用。如果内存空间足够。垃圾回收器不会回收它。如果内存不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>弱引用：如果一个对象具有弱引用。当垃圾回收器发现只具有弱引用对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现只具有弱引用的对象。</p><p>虚引用：虚引用不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p><h2 id="谨慎显式调用GC"><a href="#谨慎显式调用GC" class="headerlink" title="谨慎显式调用GC"></a>谨慎显式调用GC</h2><p>GC的开销通常很大，而且它的运行具有不确定性，微软的编程规范里是强烈建议你不要显式调用GC。但你的代码中还是可以使用framework中GC的某些方法进行手动回收，前提是你必须要深刻理解GC的回收原理，否则手动调用GC在特定场景下很容易干扰到GC的正常回收甚至引入不可预知的错误。</p><p>比如如下代码：</p><pre><code>void SomeMethod(){    object o1 = new Object();    object o2 = new Object();    o1.ToString();    System.gc(); // this forces o2 into Gen1, because it&apos;s still referenced    o2.ToString();}</code></pre><p>如果没有GC.Collect()，o1和o2都将在下一次垃圾自动回收中进入Gen0，但是加上GC.Collect()，o2将被标记为Gen1，也就是0代回收没有释放o2占据的内存</p><p>还有的情况是编程不规范可能导致死锁，比如流传很广的一段代码：</p><pre><code>var instance = new MyClass();Monitor.Enter(instance);instance = null;GC.Collect();GC.WaitForPendingFinalizers();Console.WriteLine(&quot;instance is gabage collected&quot;);</code></pre><p>上述代码将会导致死锁。原因分析如下：</p><p>1、客户端主线程调用代码Monitor.Enter(instance)代码段lock住了instance实例</p><p>2、接着手动执行GC回收，主（Finalizer)线程会执行MyClass析构函数</p><p>3、在MyClass析构函数内部，使用了lock (this)代码，而主（Finalizer)线程还没有释放instance（也即这里的this），此时主线程只能等待</p><p>虽然严格来说，上述代码并不是GC的错，和多线程操作似乎也无关，而是Lock使用不正确造成的。</p><p>同时请注意，GC的某些行为在Debug和Release模式下完全不同（Jeffrey Richter在&lt;<clr via="" c#="">&gt;举过一个Timer的例子说明这个问题）。比如上述代码，在Debug模式下你可能发现它是正常运行的，而Release模式下则会死锁。</clr></p><h2 id="当GC遇到多线程"><a href="#当GC遇到多线程" class="headerlink" title="当GC遇到多线程"></a>当GC遇到多线程</h2><p>前面讨论的垃圾回收算法有一个很大的前提就是：只在一个线程运行。而在现实开发中，经常会出现多个线程同时访问托管堆的情况，或至少会有多个线程同时操作堆中的对象。一个线程引发垃圾回收时，其它线程绝对不能访问任何线程，因为垃圾回收器可能移动这些对象，更改它们的内存位置。CLR想要进行垃圾回收时，会立即挂起执行托管代码中的所有线程，正在执行非托管代码的线程不会挂起。然后，CLR检查每个线程的指令指针，判断线程指向到哪里。接着，指令指针与JIT生成的表进行比较，判断线程正在执行什么代码。</p><p>如果线程的指令指针恰好在一个表中标记好的偏移位置，就说明该线程抵达了一个安全点。线程可在安全点安全地挂起，直至垃圾回收结束。如果线程指令指针不在表中标记的偏移位置，则表明该线程不在安全点，CLR也就不会开始垃圾回收。在这种情况下，CLR就会劫持该线程。也就是说，CLR会修改该线程栈，使该线程指向一个CLR内部的一个特殊函数。然后，线程恢复执行。当前的方法执行完后，他就会执行这个特殊函数，这个特殊函数会将该线程安全地挂起。然而，线程有时长时间执行当前所在方法。所以，当线程恢复执行后，大约有250毫秒的时间尝试劫持线程。过了这个时间，CLR会再次挂起线程，并检查该线程的指令指针。如果线程已抵达一个安全点，垃圾回收就可以开始了。但是，如果线程还没有抵达一个安全点，CLR就检查是否调用了另一个方法。如果是，CLR再一次修改线程栈，以便从最近执行的一个方法返回之后劫持线程。然后，CLR恢复线程，进行下一次劫持尝试。所有线程都抵达安全点或被劫持之后，垃圾回收才能使用。垃圾回收完之后，所有线程都会恢复，应用程序继续运行，被劫持的线程返回最初调用它们的方法。</p><p>实际应用中，CLR大多数时候都是通过劫持线程来挂起线程，而不是根据JIT生成的表来判断线程是否到达了一个安全点。之所以如此，原因是JIT生成表需要大量内存，会增大工作集，进而严重影响性能。</p><p>这里再说一个真实案例。某web应用程序中大量使用Task，后在生产环境发生莫名其妙的现象，程序时灵时不灵，根据数据库日志（其实还可以根据Windows事件跟踪（ETW）、IIS日志以及dump文件），发现了Task执行过程中有不规律的未处理的异常，分析后怀疑是CLR垃圾回收导致，当然这种情况也只有在高并发条件下才会暴露出来。</p><h2 id="开发中的一些建议和意见"><a href="#开发中的一些建议和意见" class="headerlink" title="开发中的一些建议和意见"></a>开发中的一些建议和意见</h2><p>由于GC的代价很大，平时开发中注意一些良好的编程习惯有可能对GC有积极正面的影响，否则有可能产生不良效果。</p><p>1、尽量不要new很大的object，大对象（&gt;=85000Byte）直接归为G2代，GC回收算法从来不对大对象堆（LOH）进行内存压缩整理，因为在堆中下移85000字节或更大的内存块会浪费太多CPU时间</p><p>2、不要频繁的new生命周期很短object，这样频繁垃圾回收频繁压缩有可能会导致很多内存碎片，可以使用设计良好稳定运行的对象池（ObjectPool）技术来规避这种问题</p><p>3、使用更好的编程技巧，比如更好的算法、更优的数据结构、更佳的解决策略等等</p><h2 id="GC线程和Finalizer线程"><a href="#GC线程和Finalizer线程" class="headerlink" title="GC线程和Finalizer线程"></a>GC线程和Finalizer线程</h2><p>GC在一个独立的线程中运行来删除不再被引用的内存。</p><p>Finalizer则由另一个独立（高优先级CLR)线程来执行Finalizer的对象的内存回收。</p><p>对象的Finalizer被执行的时间是在对象不再被引用后的某个不确定的时间，并非和C++中一样在对象超出生命周期时立即执行析构函数。</p><p>GC把每一个需要执行Finalizer的对象放到一个队列(从终结列表移至freachable队列）中去，然后启动另一个线程而不是在GC执行的线程来执行所有这些Finalizer，GC线程继续去删除其他待回收的对象。</p><p>在下一个GC周期，这些执行完Finalizer的对象的内存才会被回收。也就是说一个实现了Finalize方法的对象必需等两次GC才能被完全释放。这也表明有Finalize的方法（Object默认的不算）的对象会在GC中自动“延长”生存周期。因为Finalize是在GC回收对象前调用，所以在类中若是写了Finalize方法，那么GC在收集这个对象时会先执行这个方法，因为优先级较高，然后跑去收集别的了，等到最后再回来收集这个对象，可以说是变相的延长了对象的寿命。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;为什么需要GC&quot;&gt;&lt;a href=&quot;#为什么需要GC&quot; class=&quot;headerlink&quot; title=&quot;为什么需要GC&quot;&gt;&lt;/a&gt;为什么需要GC&lt;/h1&gt;&lt;p&gt;应用程序对资源操作，通常简单分为以下几个步骤：&lt;/p&gt;
&lt;p&gt;1、为对应的资源分配内存&lt;/p&gt;
&lt;p&gt;2、初始化内存&lt;/p&gt;
&lt;p&gt;3、使用资源&lt;/p&gt;
&lt;p&gt;4、清理资源&lt;/p&gt;
&lt;p&gt;5、释放内存&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="底层原理" scheme="http://yoursite.com/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>java书单</title>
    <link href="http://yoursite.com/2018/03/30/java%E4%B9%A6%E5%8D%95/"/>
    <id>http://yoursite.com/2018/03/30/java书单/</id>
    <published>2018-03-29T16:00:12.000Z</published>
    <updated>2018-03-29T17:17:02.287Z</updated>
    
    <content type="html"><![CDATA[<p>多数都是在知乎和ImportNew上收集的，作为自己的知识储备。作为一个java开发工程师，若想在职业这条道路上走的更远，不仅要学会底层的知识，学习各种虚拟机，明白各种设计模式，web微服务开发框架，半个DBA，大数据方向作知识储备，hadoop和spark集群演变和原理实现，爬虫与反爬，各种最新的框架和API，跟上java版本更新，保持学习动力。</p><a id="more"></a><ul><li>《Effective Java中文版》 </li></ul><p>人手一本？谷歌出品，必属精品？</p><p>《Effective Java中文版》的作者是Joshua Bloch，这个人就很厉害了，他是谷歌的首席架构师，属于超级技术大牛级别了吧，呵呵。由于没有看过这本书，所以我不好发表评论，但是从这本书的知名度以及其作者的来头来看（多提一句，这本书也是Java之父James Gosling博士推崇的一本书），我相信这一定是一本值得一看的好书。</p><p>好的代码是每个Java程序员都应该去追求的，不是说我今天写一段好代码相比写一段烂代码对性能会有多大的提升，更多的应该是提升了代码的可读性以及可以规避许多潜在的、未知的问题，避免代码上线之后出问题而花时间去维护—-无论从时间成本、人力成本还是风险成本来说，这都是非常高的。</p><ul><li>《深入分析Java Web技术内幕》，作者许令波，淘宝工程师。</li></ul><p>这本书我用一个字概括就是：全。真的非常全，HTTP、DNS、CDN、静态化、Jetty、Tomcat、Servlet、Spring、MyBatis等等，什么都有，涉及知识面非常广，但又不像专门精讲某个知识点的书籍一样讲得非常深入，感觉这本书就是尽量去用短的篇幅讲清楚一些Java Web使用到的技术的内幕，让读者对这些知识点的技术内幕有一个理性的认识。</p><p>不过，尽管每个知识点的篇幅都不多，但是重点都基本讲到了，是一本让人真正有收获的书。如果想进一步了解这些技术的技术内幕，就要自己去买相关书籍或者自己上网查资料了，有种抛砖引玉，或者说师傅领进门、修行在个人的感觉。</p><ul><li>《大型网站技术架构 核心原理与案例分析》的作者是李智慧，原阿里巴巴技术专家</li></ul><p>Java的大多数应用都是用在Web上的，现在只要稍微大型一点的Web应用，都一定是一个分布式系统，那么一个分布式系统用到了哪些技术？一个大型网站是如何从一个小型网站成长起来的？如何保证你的网站安全？分布式系统使用到了缓存，有哪些缓存？缓存的使用有哪些值得注意的事项？</p><p>关于分布式的知识点，都在这本书里面有体现，只有你想不到，没有他写不到，而且写得非常易懂，基本属于看一两遍，再记一些笔记就知道是怎么一回事儿了。多看几遍，对分布式的理解一定会加深不少。而且里面不仅仅是分布式的知识，还非常接地气地写了如何做一个好的架构师，其实我认为这不仅仅是写给想做架构师的读者看的，就是给读者一些建议，如何更好地提出意见、如何更让别人关注你的声音、如何看到他人的优点，入木三分，让人获益匪浅。</p><ul><li>《大型网站系统与Java中间件实践》作者曾宪杰，是淘宝的技术总监，算起来应该在阿里有至少P8的级别了吧。</li></ul><p>中间件读物，如果产品开发中涉及到中间件，可以一读。</p><p>这本书的部分内容和上面一本李智慧的《大型网站技术架构 核心原理与案例分析》有所重合，像分布式系统的演化、CDN、CAP理论和BASE理论等等，这也更说明这些都是分布式系统或者说是一个大型网站重点关注的内容，当作一次再学习也不错。</p><p>本书要突出的重点是中间件三个字，中间件是分布式系统中一个非常重要的东西，其最重要的作用应该就是解耦，降低模块与模块之间的强依赖，不同的模块之间的依赖度降低，便可以各自独立地开发自己的功能，这也可以说是软件工程发展的目标和驱动力。</p><p>因此，本书有一部分的内容就是基于中间件，详细讲解了中间件与JMS的各种知识，适合对分布式系统比较熟悉并且想要往中间件方面有一定研究的读者。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多数都是在知乎和ImportNew上收集的，作为自己的知识储备。作为一个java开发工程师，若想在职业这条道路上走的更远，不仅要学会底层的知识，学习各种虚拟机，明白各种设计模式，web微服务开发框架，半个DBA，大数据方向作知识储备，hadoop和spark集群演变和原理实现，爬虫与反爬，各种最新的框架和API，跟上java版本更新，保持学习动力。&lt;/p&gt;
    
    </summary>
    
      <category term="工具类" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="书单" scheme="http://yoursite.com/tags/%E4%B9%A6%E5%8D%95/"/>
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="代码" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA-线程重读</title>
    <link href="http://yoursite.com/2018/03/29/java-thread/"/>
    <id>http://yoursite.com/2018/03/29/java-thread/</id>
    <published>2018-03-29T08:05:14.000Z</published>
    <updated>2018-03-29T16:30:35.025Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/03/29/java-thread/main.png" alt="logo"><br><a id="more"></a></p><h1 id="传统线程及并发处理"><a href="#传统线程及并发处理" class="headerlink" title="传统线程及并发处理"></a>传统线程及并发处理</h1><p>关于同步及互斥，对象锁与类锁，wait(),notify(),notifyAll()这三种方法怎么用这是最关键的问题。</p><p>wait，notify，notifyAll 是定义在Object类的实例方法，用于控制线程状态。</p><p>三个方法都必须在synchronized 同步关键字所限定的作用域中调用，否则会报错java.lang.IllegalMonitorStateException ，意思是因为没有同步，所以线程对对象锁的状态是不确定的，不能调用这些方法。</p><p>wait 表示持有对象锁的线程A准备释放对象锁权限，释放cpu资源并进入等待。<br>notify 表示持有对象锁的线程A准备释放对象锁权限，通知jvm唤醒某个竞争该对象锁的线程X。线程A synchronized 代码作用域结束后，线程X直接获得对象锁权限，其他竞争线程继续等待(即使线程X同步完毕，释放对象锁，其他竞争线程仍然等待，直至有新的notify ,notifyAll被调用)。<br>notifyAll 表示持有对象锁的线程A准备释放对象锁权限，通知jvm唤醒所有竞争该对象锁的线程，线程A synchronized 代码作用域结束后，jvm通过算法将对象锁权限指派给某个线程X，所有被唤醒的线程不再等待。线程X synchronized 代码作用域结束后，之前所有被唤醒的线程都有可能获得该对象锁权限，这个由JVM算法决定。<br>wait有三个重载方法，同时必须捕获非运行时异常InterruptedException。</p><p>wait() 进入等待，需要notify ,notifyAll才能唤醒<br>wait(long timeout) 进入等待，经过timeout 超时后，若未被唤醒，则自动唤醒<br>wait(timeout, nanos) 进入等待，经过timeout 超时后，若未被唤醒，则自动唤醒。相对wait(long timeout) 更加精确时间。</p><p>那么对象锁又是什么？类锁又是啥？</p><p>synchronized关键字</p><p>synchronized关键字有如下两种用法：</p><p>1、 在需要同步的方法的方法签名中加入synchronized关键字。<br>在非静态方法中加入synchronized关键字是对象级别的</p><pre><code>synchronized public void getValue() {    System.out.println(&quot;getValue method thread name=&quot;            + Thread.currentThread().getName() + &quot; username=&quot; + username            + &quot; password=&quot; + password);}</code></pre><p>上面的代码修饰的synchronized是非静态方法，如果修饰的是静态方法（static）含义是完全不一样的。具体不一样在哪里，后面会详细说清楚。<br>而在静态方法中加入synchronized关键字是类级别的（静态方法是类直接调用的）<br>    synchronized static public void getValue() {<br>        System.out.println(“getValue method thread name=”</p><pre><code>            + Thread.currentThread().getName() + &quot; username=&quot; + username            + &quot; password=&quot; + password);}</code></pre><p>2、使用synchronized块对需要进行同步的代码段进行同步。<br>因为同步是对系统开销很大的一种操作，若是要执行高并发就必须要用到同步，因此为了尽量减少同步的内容要用到同步块，对方法里的一部分进行加锁。<br>同步块所锁住的参数也是对应不同的级别<br>同步代码块的synchronized (this)用法和synchronized (非this对象)的用法锁的是对象<br>同步代码块的synchronized (类.class)用法锁的是类<br>包括上面所声明的在方法前加关键字，syncronized总共有5种方法</p><pre><code>public void serviceMethod() {    try {        synchronized (this) {            System.out.println(&quot;begin time=&quot; + System.currentTimeMillis());            Thread.sleep(2000);            System.out.println(&quot;end    end=&quot; + System.currentTimeMillis());        }    } catch (InterruptedException e) {        e.printStackTrace();    }}</code></pre><p>上面的代码块是synchronized (this)用法，还有synchronized (非this对象)以及synchronized (类.class)这两种用法，这些使用方式的含义也是有根本的区别的。我们先带着这些问题继续往下看。</p><p>1.一段synchronized的代码被一个线程执行之前，他要先拿到执行这段代码的权限；（执行代码的权限就是对象锁）<br>2.在Java里边就是拿到某个同步对象的锁（一个对象只有一把锁）；<br>3.如果这个时候同步对象的锁被其他线程拿走了，他（这个线程）就只能等了（线程阻塞在锁池等待队列中）。<br>4.取到锁后，他就开始执行同步代码(被synchronized修饰的代码）；<br>5.线程执行完同步代码后马上就把锁还给同步对象，其他在锁池中等待的某个线程就可以拿到锁执行同步代码了。<br>6.这样就保证了同步代码在统一时刻只有一个线程在执行。</p><p>上面提到锁，这里先引出锁的概念。先来看看下面这些啰嗦而必不可少的文字。</p><p><strong>多线程的线程同步机制实际上是靠锁的概念来控制的。</strong></p><p>在Java程序运行时环境中，JVM需要对两类线程共享的数据进行协调：<br>1）保存在堆中的实例变量（对象信息放在堆中Heap）<br>2）保存在方法区中的类变量（类信息放在方法区中Method Area）</p><p>这两类数据是被所有线程共享的。<br>（程序不需要协调保存在Java 栈当中的数据。因为这些数据是属于拥有该栈的线程所私有的。）</p><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</p><p>栈：在Java中，JVM中的栈记录了线程的方法调用。每个线程拥有一个栈。在某个线程的运行过程中，如果有新的方法调用，那么该线程对应的栈就会增加一个存储单元，即帧(frame)。在frame中，保存有该方法调用的参数、局部变量和返回地址。</p><p>堆是JVM中一块可自由分配给对象的区域。当我们谈论垃圾回收(garbage collection)时，我们主要回收堆(heap)的空间。<br>Java的普通对象存活在堆中。与栈不同，堆的空间不会随着方法调用结束而清空。因此，在某个方法中创建的对象，可以在方法调用结束之后，继续存在于堆中。这带来的一个问题是，如果我们不断的创建新的对象，内存空间将最终消耗殆尽。</p><p>在java虚拟机中，每个对象和类在逻辑上都是和一个监视器相关联的。<br>对于对象来说，相关联的监视器保护对象的实例变量。</p><p>对于类来说，监视器保护类的类变量。</p><p>（如果一个对象没有实例变量，或者一个类没有变量，相关联的监视器就什么也不监视。）<br>为了实现监视器的排他性监视能力，java虚拟机为每一个对象和类都关联一个锁。代表任何时候只允许一个线程拥有的特权。线程访问实例变量或者类变量不需锁。</p><p>但是如果线程获取了锁，那么在它释放这个锁之前，就没有其他线程可以获取同样数据的锁了。（锁住一个对象就是获取对象相关联的监视器）</p><p>类锁实际上用对象锁来实现。当虚拟机装载一个class文件的时候，它就会创建一个java.lang.Class类的实例。当锁住一个对象的时候，实际上锁住的是那个类的Class对象。</p><p>一个线程可以多次对同一个对象上锁。对于每一个对象，java虚拟机维护一个加锁计数器，线程每获得一次该对象，计数器就加1，每释放一次，计数器就减 1，当计数器值为0时，锁就被完全释放了。</p><p>java编程人员不需要自己动手加锁，对象锁是java虚拟机内部使用的。</p><p>在java程序中，只需要使用synchronized块或者synchronized方法就可以标志一个监视区域。当每次进入一个监视区域时，java 虚拟机都会自动锁上对象或者类。</p><blockquote><p>参考这篇文章 ：<a href="https://blog.csdn.net/u013142781/article/details/51697672" target="_blank" rel="noopener">https://blog.csdn.net/u013142781/article/details/51697672</a></p></blockquote><p>在这篇文章中你将会学到如何使用 wait、notify 和 notifyAll 来实现线程间的通信，从而解决生产者消费者问题。如果你想要更深入地学习Java中的多线程同步问题，我强烈推荐阅读Brian Goetz所著的《Java Concurrency in Practice | Java 并发实践》，不读这本书你的 Java 多线程征程就不完整哦！这是我最向Java开发者推荐的书之一。</p><p>回到wait(),notify(),notifyAll()这三个方法中来</p><p>这里用药店窗口取药的模型可以很好的解释这一点。。。</p><p>wait( )，notify( )，notifyAll( )都不属于Thread类，而是属于Object基础类，也就是每个对象都有wait( )，notify( )，notifyAll( ) 的功能，因为每个对象都有锁，锁是每个对象的基础，当然操作锁的方法也是最基础了。</p><p>当需要调用以上的方法的时候，一定要对竞争资源进行加锁，如果不加锁的话，则会报 IllegalMonitorStateException 异常</p><p>当想要调用wait( )进行线程等待时，必须要取得这个锁对象的控制权（对象监视器），一般是放到synchronized(obj)代码中。</p><p>在while循环里而不是if语句下使用wait，这样，会在线程暂停恢复后都检查wait的条件，并在条件实际上并未改变的情况下处理唤醒通知</p><p>调用obj.wait( )释放了obj的锁，否则其他线程也无法获得obj的锁，也就无法在synchronized(obj){ obj.notify() } 代码段内唤醒A。</p><p>notify( )方法只会通知等待队列中的第一个相关线程（不会通知优先级比较高的线程）</p><p>notifyAll( )通知所有等待该竞争资源的线程（也不会按照线程的优先级来执行）</p><p>假设有三个线程执行了obj.wait( )，那么obj.notifyAll( )则能全部唤醒tread1，thread2，thread3，但是要继续执行obj.wait（）的下一条语句，必须获得obj锁，因此，tread1，thread2，thread3只有一个有机会获得锁继续执行，例如tread1，其余的需要等待thread1释放obj锁之后才能继续执行。</p><p>当调用obj.notify/notifyAll后，调用线程依旧持有obj锁，因此，thread1，thread2，thread3虽被唤醒，但是仍无法获得obj锁。直到调用线程退出synchronized块，释放obj锁后，thread1，thread2，thread3中的一个才有机会获得锁继续执行。</p><p>wait()与sleep()的区别：</p><p>1.首先sleep()是Thread()类的方法，而wait()是Object类的方法，包括notify()，notifyAll()都是Object类的方法</p><p>2.sleep()方法是休眠，阻塞线程的同时仍然会持有锁，也就是说它休眠期间其他线程仍然无法获得锁，同时sleep()休眠时自动醒           的；而调用wait()方法时，则自动释放锁，也就是其他线程可以获得锁，而且wait()是无法自动醒的，只有通过notify()或 notifyAll()         才行。如果不设置wait自动醒的时间，那么wait将会一直等下去直至notify来唤醒，进入锁池去获取对象锁。</p><p>notify()与notifyAll()的区别</p><p>notify()一次只能激活一个对这个对象进行wait()的线程，当多个线程都对此对象wait()时，是随机挑一个notify()，而notifyAll()是一次      性激活所以对此对象进行wait()的线程。</p><p>接下来说说利用wait()和notify()来实现<strong>生产者和消费者并发问题</strong>：</p><p>显然要保证生产者和消费者并发运行不出乱，主要要解决：当生产者线程的缓存区为满的时候，就应该调用wait()来停止生产者继续生产，而当生产者满的缓冲区被消费者消费掉一块时，则应该调用notify()唤醒生产者，通知他可以继续生产；同样，对于消费者，当消费者线程的缓存区为空的时候，就应该调用wait()停掉消费者线程继续消费，而当生产者又生产了一个时就应该调用notify()来唤醒消费者线程通知他可以继续消费了。</p><p>当然我们必须在wait()和notify()的时候锁住我们所要操作的对象,这里即缓存区，下面是一个使用wait()的notify()的规范代码模板：<br>synchronized的背景下和那个被多线程共享的对象上调用</p><pre><code>synchronized (sharedObject) { //锁住操作对象，锁的是对象      while (condition) { //当某个条件下      sharedObject.wait(); //进入wait，这个shareObject就是所有线程共享的对象，在生产者-消费者模型里面这个对象就是缓冲区队列     }       // 做了什么事，就可以激活，注意在while循环外     shareObject.notify();  } </code></pre><p>wait, notify 和 notifyAll，这些在多线程中被经常用到的保留关键字，在实际开发的时候很多时候却并没有被大家重视。本文对这些关键字的使用进行了描述。</p><p>在 Java 中可以用 wait、notify 和 notifyAll 来实现线程间的通信。。举个例子，如果你的Java程序中有两个线程——即生产者和消费者，那么生产者可以通知消费者，让消费者开始消耗数据，因为队列缓冲区中有内容待消费（不为空）。相应的，消费者可以通知生产者可以开始生成更多的数据，因为当它消耗掉某些数据后缓冲区不再为满。</p><p>我们可以利用wait()来让一个线程在某些条件下暂停运行。例如，在生产者消费者模型中，生产者线程在缓冲区为满的时候，消费者在缓冲区为空的时候，都应该暂停运行。如果某些线程在等待某些条件触发，那当那些条件为真时，你可以用 notify 和 notifyAll 来通知那些等待中的线程重新开始运行。不同之处在于，notify 仅仅通知一个线程，并且我们不知道哪个线程会收到通知，然而 notifyAll 会通知所有等待中的线程。换言之，如果只有一个线程在等待一个信号灯，notify和notifyAll都会通知到这个线程。但如果多个线程在等待这个信号灯，那么notify只会通知到其中一个，而其它线程并不会收到任何通知，而notifyAll会唤醒所有等待中的线程。</p><p>如何使用Wait</p><p>尽管关于wait和notify的概念很基础，它们也都是Object类的函数，但用它们来写代码却并不简单。如果你在面试中让应聘者来手写代码，用wait和notify解决生产者消费者问题，我几乎可以肯定他们中的大多数都会无所适从或者犯下一些错误，例如在错误的地方使用 synchronized 关键词，没有对正确的对象使用wait，或者没有遵循规范的代码方法。说实话，这个问题对于不常使用它们的程序员来说确实令人感觉比较头疼。</p><p>第一个问题就是，我们怎么在代码里使用wait()呢？因为wait()并不是Thread类下的函数，我们并不能使用Thread.call()。事实上很多Java程序员都喜欢这么写，因为它们习惯了使用Thread.sleep()，所以他们会试图使用wait() 来达成相同的目的，但很快他们就会发现这并不能顺利解决问题。<strong>正确的方法是对在多线程间共享的那个Object来使用wait。在生产者消费者问题中，这个共享的Object就是那个缓冲区队列。</strong></p><p>第二个问题是，既然我们应该在synchronized的函数或是对象里调用wait，那哪个对象应该被synchronized呢？答案是，那个你希望上锁的对象就应该被synchronized，即那个在多个线程间被共享的对象。在生产者消费者问题中，应该被synchronized的就是那个缓冲区队列。（我觉得这里是英文原文有问题……本来那个句末就不应该是问号不然不太通……）</p><p>永远在循环（loop）里调用 wait 和 notify，不是在 If 语句，常用的是while循环</p><p>现在你知道wait应该永远在被synchronized的背景下和那个被多线程共享的对象上调用，下一个一定要记住的问题就是，你应该永远在while循环，而不是if语句中调用wait。因为线程是在某些条件下等待的——在我们的例子里，即“如果缓冲区队列是满的话，那么生产者线程应该等待”，你可能直觉就会写一个if语句。但if语句存在一些微妙的小问题，导致即使条件没被满足，你的线程你也有可能被错误地唤醒。所以如果你不在线程被唤醒后再次使用while循环检查唤醒条件是否被满足，你的程序就有可能会出错——例如在缓冲区为满的时候生产者继续生成数据，或者缓冲区为空的时候消费者开始消耗数据。所以记住，永远在while循环而不是if语句中使用wait！我会推荐阅读《Effective Java》，这是关于如何正确使用wait和notify的最好的参考资料。</p><p>就像我之前说的一样，在while循环里使用wait的目的，是在线程被唤醒的前后都持续检查条件是否被满足。如果条件并未改变，wait被调用之前notify的唤醒通知就来了，那么这个线程并不能保证被唤醒，有可能会导致死锁问题。</p><p>下面我们提供一个使用wait和notify的范例程序。在这个程序里，我们使用了上文所述的一些代码规范。</p><p>我们有两个线程，分别名为PRODUCER（生产者）和CONSUMER（消费者），他们分别继承了了Producer和Consumer类，而Producer和Consumer都继承了Thread类。Producer和Consumer想要实现的代码逻辑都在run()函数内。</p><p>Main线程开始了生产者和消费者线程，并声明了一个LinkedList作为缓冲区队列（在Java中，LinkedList实现了队列的接口）。生产者在无限循环中持续往LinkedList里插入随机整数直到LinkedList满。我们在while(queue.size == maxSize)循环语句中检查这个条件。请注意到我们在做这个检查条件之前已经在队列对象上使用了synchronized关键词，因而其它线程不能在我们检查条件时改变这个队列。如果队列满了，那么PRODUCER线程会在CONSUMER线程消耗掉队列里的任意一个整数，并用notify来通知PRODUCER线程之前持续等待。在我们的例子中，wait和notify都是使用在同一个共享对象上的。</p><p>这一套程序如果能在面试中写出来那就给劲了，其实逻辑并不难，只需要按照套路来即可。</p><pre><code>import java.util.LinkedList; import java.util.Queue; import java.util.Random; /**     * Simple Java program to demonstrate How to use wait, notify and notifyAll()     * method in Java by solving producer consumer problem.    *     * @author Javin Paul     */public class ProducerConsumerInJava {     public static void main(String args[]) {         System.out.println(&quot;How to use wait and notify method in Java&quot;);         System.out.println(&quot;Solving Producer Consumper Problem&quot;);         Queue&lt;Integer&gt; buffer = new LinkedList&lt;&gt;();         int maxSize = 10;         Thread producer = new Producer(buffer, maxSize, &quot;PRODUCER&quot;);         Thread consumer = new Consumer(buffer, maxSize, &quot;CONSUMER&quot;);         producer.start(); consumer.start(); }     }     /**         * Producer Thread will keep producing values for Consumer         * to consumer. It will use wait() method when Queue is full         * and use notify() method to send notification to Consumer         * Thread.         *         * @author WINDOWS 8         *         */    class Producer extends Thread     { private Queue&lt;Integer&gt; queue;         private int maxSize;         public Producer(Queue&lt;Integer&gt; queue, int maxSize, String name){             super(name); this.queue = queue; this.maxSize = maxSize;         }         @Override public void run()         {             while (true)                 {                     synchronized (queue) {                         while (queue.size() == maxSize) { //queue满了，那么Producer就要被wait                            try {                                 System.out .println(&quot;Queue is full, &quot; + &quot;Producer thread waiting for &quot; + &quot;consumer to take something from queue&quot;);                                 queue.wait();                             } catch (Exception ex) {                                 ex.printStackTrace(); }                             }                             Random random = new Random();                             int i = random.nextInt();                             System.out.println(&quot;Producing value : &quot; + i);                             queue.add(i);                             queue.notifyAll();                         }                     }                 }             }     /**         * Consumer Thread will consumer values form shared queue.         * It will also use wait() method to wait if queue is         * empty. It will also use notify method to send         * notification to producer thread after consuming values         * from queue.         *         * @author WINDOWS 8         *         */    class Consumer extends Thread {         private Queue&lt;Integer&gt; queue;         private int maxSize;         public Consumer(Queue&lt;Integer&gt; queue, int maxSize, String name){             super(name);             this.queue = queue;             this.maxSize = maxSize;         }         @Override public void run() {             while (true) {                 synchronized (queue) {                     while (queue.isEmpty()) {   //queue空的时候，Consumer要被wait                        System.out.println(&quot;Queue is empty,&quot; + &quot;Consumer thread is waiting&quot; + &quot; for producer thread to put something in queue&quot;);                         try {                             queue.wait();                         } catch (Exception ex) {                             ex.printStackTrace();                         }                     }                     System.out.println(&quot;Consuming value : &quot; + queue.remove());                     queue.notifyAll();                 }             }         }     }</code></pre><blockquote><p>参考资料：<a href="http://www.importnew.com/16453.html" target="_blank" rel="noopener">http://www.importnew.com/16453.html</a><br>如何在 Java 中正确使用 wait, notify 和 notifyAll – 以生产者消费者模型为例 </p></blockquote><p>为了更好地理解这个程序，我建议你在debug模式里跑这个程序。一旦你在debug模式下启动程序，它会停止在PRODUCER或者CONSUMER线程上，取决于哪个线程占据了CPU。因为两个线程都有wait()的条件，它们一定会停止，然后你就可以跑这个程序然后看发生什么了（很有可能它就会输出我们以上展示的内容）。你也可以使用Eclipse里的Step into和Step over按钮来更好地理解多线程间发生的事情。</p><ol><li><p>你可以使用wait和notify函数来实现线程间通信。你可以用它们来实现多线程（&gt;3）之间的通信。</p></li><li><p>永远在synchronized的函数或对象里使用wait、notify和notifyAll，不然Java虚拟机会生成 IllegalMonitorStateException。</p></li><li><p>永远在while循环里而不是if语句下使用wait。这样，循环会在线程睡眠前后都检查wait的条件，并在条件实际上并未改变的情况下处理唤醒通知。</p></li><li><p>永远在多线程间共享的对象（在生产者消费者模型里即缓冲区队列）上使用wait。</p></li><li><p>基于前文提及的理由，更倾向用 notifyAll()，而不是 notify()。</p></li></ol><h1 id="来点新东西吧"><a href="#来点新东西吧" class="headerlink" title="来点新东西吧"></a>来点新东西吧</h1><p>在JAVA1.8或1.9中，并发工具的改变</p><p>Java 8 中 Concurrent package的改变</p><p>java.util.concurrent中新的类和接口</p><p>增加了两个新接口和4个新类:</p><p>接口 CompletableFuture.AsynchronousCompletionTask<br>接口 CompletionStage<br>类 CompletableFuture<br>类 ConcurrentHashMap.KeySetView<br>类 CountedCompleter<br>类 CompletionException<br>java.util.concurrent.ConcurrentHashMap的新方法</p><p>集合框架 在Java 8中做了修订，基于 stream 和 lambda表达式 添加了很多聚合方法。因此 ConcurrentHashMap 也引入了30几个新方法，包括各种 foreach 方法(forEach , forEachKey , forEachValue , 和 forEachEntry )、搜索方法( search , searchKeys , searchValues , 和 searchEntries )和reduction方法( reduce ,reduceToDouble , reduceToLong 等)。</p><p>也添加了一些其它方法，比如 mappingCount 和 newKeySet 。并且当前版本的 ConcurrentHashMap 的更适合做cache，因为增加了当键值不存在的时候的检查方法。</p><p>java.util.concurrent.atomic中的新类</p><p>为了并发计算count、sum， 新引入了 DoubleAccumulator , DoubleAdder , LongAccumulator , LongAdder 类，比Atomic提供更高的吞吐率。</p><p>java.util.concurrent.ForkJoinPool的新方法</p><p>静态的 commonPool() 新加入，可以为ForkJoinTask提供通用池。</p><p>两个方法 getCommonPoolParallelism() 和 commonPool() 提供不同的配置。</p><p>新类 java.util.concurrent.locks.StampedLock</p><p>新类 StampedLock 提供三种模式(写，读，乐观读)，用来提高性能。</p><p>Java 9 中 Concurrent package的改变</p><p>主要是 JEP 266: More Concurrency Updates , 包括publish-subscribe, CompletableFuture 接口的加强等。</p><p>支持Reactive Streams publish-subscribe框架，四个接口 Processor 、 Publisher 、 Subscriber 、 Subscription ，容器类 java.util.concurrent.Flow 、java.util.concurrent.SubmissionPublisher<br>CompletableFuture类加强，支持delays, timeout, subclassing 以及其它方法<br>调优以及修改javadoc</p><blockquote><p>可以参考：<a href="http://www.importnew.com/28319.html" target="_blank" rel="noopener">http://www.importnew.com/28319.html</a></p></blockquote><h1 id="普及JAVA内存管理机制"><a href="#普及JAVA内存管理机制" class="headerlink" title="普及JAVA内存管理机制"></a>普及JAVA内存管理机制</h1><p>因为线程调度跟内存分配有着很大的关系。</p><p>转载内容，觉得这篇是我看过讲得最好的：<a href="https://blog.csdn.net/u013142781/article/details/50830754" target="_blank" rel="noopener">https://blog.csdn.net/u013142781/article/details/50830754</a></p><p><img src="/2018/03/29/java-thread/p1.png" alt="logo"></p><p>请注意上图的这个：</p><p><img src="/2018/03/29/java-thread/p2.png" alt="logo"></p><p>我们再来复习下进程与线程吧：</p><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。</p><p>线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p><p>似乎现在更好理解了一些：</p><p>方法区和堆是分配给进程的，也就是所有线程共享的。</p><p>而栈和程序计数器，则是分配给每个独立线程的，是运行过程中必不可少的资源。</p><p>下面我们逐个看下栈、堆、方法区和程序计数器。</p><p>1、方法区（Method Area）</p><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</p><p>2、程序计数器（Program Counter Register）</p><p>程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>下面重点解下Java内存管理中的栈和堆。</p><p>3、栈（Stacks）</p><p>在Java中，JVM中的栈记录了线程的方法调用。每个线程拥有一个栈。在某个线程的运行过程中，如果有新的方法调用，那么该线程对应的栈就会增加一个存储单元，即帧(frame)。在frame中，保存有该方法调用的参数、局部变量和返回地址。</p><p>Java的参数和局部变量只能是基本类型的变量(比如int)，或者对象的引用(reference)。因此，在栈中，只保存有基本类型的变量和对象引用。引用所指向的对象保存在堆中。(引用可能为Null值，即不指向任何对象)。</p><p>当被调用方法运行结束时，该方法对应的帧将被删除，参数和局部变量所占据的空间也随之释放。线程回到原方法，继续执行。当所有的栈都清空时，程序也随之运行结束。</p><p>本地方法栈与虚拟机栈的区别：</p><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p><p>4、堆（Heap）</p><p>堆是JVM中一块可自由分配给对象的区域。当我们谈论垃圾回收(garbage collection)时，我们主要回收堆(heap)的空间。</p><p>Java的普通对象存活在堆中。与栈不同，堆的空间不会随着方法调用结束而清空。因此，在某个方法中创建的对象，可以在方法调用结束之后，继续存在于堆中。这带来的一个问题是，如果我们不断的创建新的对象，内存空间将最终消耗殆尽。</p><p>垃圾回收（Garbage Collection，GC）</p><p>垃圾回收(garbage collection，简称GC)可以自动清空堆中不再使用的对象。垃圾回收机制最早出现于1959年，被用于解决Lisp语言中的问题。垃圾回收是Java的一大特征。并不是所有的语言都有垃圾回收功能。比如在C/C++中，并没有垃圾回收的机制。程序员需要手动释放堆中的内存。</p><p>由于不需要手动释放内存，程序员在编程中也可以减少犯错的机会。利用垃圾回收，程序员可以避免一些指针和内存泄露相关的bug(这一类bug通常很隐蔽)。但另一方面，垃圾回收需要耗费更多的计算时间。垃圾回收实际上是将原本属于程序员的责任转移给计算机。使用垃圾回收的程序需要更长的运行时间。</p><p>在Java中，对象的是通过引用使用的(把对象相像成致命的毒物，引用就像是用于提取毒物的镊子)。如果不再有引用指向对象，那么我们就再也无从调用或者处理该对象。这样的对象将不可到达(unreachable)。垃圾回收用于释放不可到达对象所占据的内存。这是垃圾回收的基本原则。</p><p>早期的垃圾回收采用引用计数(reference counting)的机制。每个对象包含一个计数器。当有新的指向该对象的引用时，计数器加1。当引用移除时，计数器减1。当计数器为0时，认为该对象可以进行垃圾回收。</p><p>然而，一个可能的问题是，如果有两个对象循环引用(cyclic reference)，比如两个对象互相引用，而且此时没有其它(指向A或者指向B)的引用，我们实际上根本无法通过引用到达这两个对象。</p><p>因此，我们以栈和static数据为根(root)，从根出发，跟随所有的引用，就可以找到所有的可到达对象。也就是说，一个可到达对象，一定被根引用，或者被其他可到达对象引用。</p><p>5、再整理下</p><p>通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；</p><p>而通过new关键字和构造器创建的对象放在堆空间；</p><p>程序中的字面量（literal）如直接书写的100、”hello”和常量都是放在静态区中；</p><p>栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，理论上整个内存没有被其他进程使用的空间甚至硬盘上的虚拟内存都可以被当成堆空间来使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/03/29/java-thread/main.png&quot; alt=&quot;logo&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="java类库" scheme="http://yoursite.com/tags/java%E7%B1%BB%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JAVA I/O流详解</title>
    <link href="http://yoursite.com/2018/03/28/java-io/"/>
    <id>http://yoursite.com/2018/03/28/java-io/</id>
    <published>2018-03-28T04:55:49.000Z</published>
    <updated>2018-03-29T08:11:30.079Z</updated>
    
    <content type="html"><![CDATA[<h1 id="流的概念和作用"><a href="#流的概念和作用" class="headerlink" title="流的概念和作用"></a>流的概念和作用</h1><p>流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。<br>集合框架相当于数据结构，那么IO框架就相当于数据传输。<br><a id="more"></a></p><h1 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h1><p>根据处理数据类型的不同分为：字符流和字节流<br>根据数据流向不同分为：输入流和输出流</p><p>对输入流只能进行读操作，对输出流只能进行写操作，程序中需要根据待传输数据的不同特性而使用不同的流。</p><p>java.io包中提供了大量的流类，其中所有的输入流都是InputStream抽象类或抽象类Reader的子类，而所有的输出流都是outputStream抽象类或Writer的抽象类，所有继承自InputStream与outputStream的流都是字节流，而所有继承自Reader与Writer的流都是字符流。</p><p>要知道所有的高级流都需要借助低级流来操作文件，字节流属于低级流，而字符流属于改进只针对于文字的高级流，但是字符流中也有方法可以直接操作文件不需要借助低级流，但是一般的高级流操作都需要以低级流作为基础。</p><p><img src="/2018/03/28/java-io/p1.png" alt="logo"> </p><p>其中IO流具体的类或接口有哪些；<br>File                  文件类<br>RandomAccessFile      随机存取文件类<br>InputStream           字节输入流<br>OutputStream          字节输出流<br>Reader                字符输入流<br>writer                字符输出流</p><p>首先先从文件的路径解释下：</p><p>文件和目录路径名的抽象表示形式。</p><p>用户界面和操作系统使用与系统相关的路径名字符串 来命名文件和目录。此类呈现分层路径名的一个抽象的、与系统无关的视图。抽象路径名 有两个组件：</p><p>一个可选的与系统有关的前缀 字符串，比如盘符，”/“ 表示 UNIX 中的根目录，”\\“ 表示 Microsoft Windows UNC 路径名。<br>零个或更多字符串名称 的序列。<br>抽象路径名中的第一个名称是目录名，对于 Microsoft Windows UNC 路径名则是主机名。抽象路径名中第一个名称之后的每个名称表示一个目录；最后一个名称既可以表示目录，也可以表示文件。空 抽象路径名没有前缀和名称序列。<br>路径名字符串与抽象路径名之间的转换与系统有关。将抽象路径名转换为路径名字符串时，每个名称与下一个名称之间用一个默认分隔符 隔开。默认名称分隔符由系统属性 file.separator 定义，可通过此类的公共静态字段 separator 和 separatorChar 使其可用。将路径名字符串转换为抽象路径名时，可以使用默认名称分隔符或者底层系统支持的任何其他名称分隔符来分隔其中的名称。</p><p>无论是抽象路径名还是路径名字符串，都可以是绝对 路径名或相对 路径名。绝对路径名是完整的路径名，不需要任何其他信息就可以定位它所表示的文件。相反，相对路径名必须使用取自其他路径名的信息进行解释。默认情况下，java.io 包中的类总是根据当前用户目录来解析相对路径名。此目录由系统属性 user.dir 指定，通常是 Java 虚拟机的调用目录。</p><p>调用此类的 getParent() 方法可以获取抽象路径名的父 路径名，它由路径名前缀以及路径名名称序列中的每个名称（最后一个除外）组成。对于任何具有绝对抽象路径名的 File 对象，如果其绝对抽象路径名以某个目录的绝对路径名开头，那么该目录的绝对路径名是该 File 对象的祖先。例如，抽象路径名 “/usr” 表示的目录是路径名 “/usr/local/bin” 所表示目录的一个祖先。</p><p>在处理 UNIX 平台的根目录，以及 Microsoft Windows 平台的盘符、根目录和 UNC 路径名时，将用到前缀这一概念。如下所示：</p><p>对于 UNIX 平台，绝对路径名的前缀始终是 “/“。相对路径名没有前缀。表示根目录的绝对路径名的前缀为 “/“ 且名称序列为空。<br>对于 Microsoft Windows 平台，包含盘符的路径名前缀由驱动器号和一个 “:” 组成。如果路径名是绝对路径名，还可能后跟 “\“。UNC 路径名的前缀是 “\\“；主机名和共享名是名称序列中的前两个名称。没有指定驱动器的相对路径名没有前缀。<br>此类的实例可能表示（也可能不表示）实际文件系统对象，如文件或目录。如果它表示这种对象，那么该对象驻留在一个分区 中。分区是文件系统特定于操作系统的存储分区。一个存储设备（例如，物理磁盘驱动器、闪存、CD-ROM）可以包含多个分区。对象（如果有）将驻留在此路径名（绝对形式）某个祖先指定的分区上。</p><p>文件系统可以实现对实际文件系统对象上的某些操作（比如，读、写、执行）进行限制。这些限制统称为访问权限。文件系统可以对一个对象设置多个访问权限。例如，一个设置可能适用于对象的所有者，另一个设置则可能适用于所有其他用户。对象上的访问权限可能导致此类的某些方法执行失败。</p><h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><p>最基础的文件流，java 处理文件的类 File,java提供了十分详细的文件处理方法<br>主要是创建文件，（不存在则新建，存在则替代），主要是封装了所有文件的属性和元数据。</p><p>File类是对文件系统中文件以及文件夹进行封装的对象，可以通过对象的思想来操作文件和文件夹。 File类保存文件或目录的各种元数据信息，包括文件名、文件长度、最后修改时间、是否可读、获取当前文件的路径名，判断指定文件是否存在、获得当前目录中的文件列表，创建、删除文件和目录等方法。</p><p>File 类的实例是不可变的；也就是说，一旦创建，File 对象表示的抽象路径名将永不改变。 </p><p>这个类中的方法有常用几个：</p><p>boolean    mkdir()<br>创建此抽象路径名指定的目录。<br>boolean    mkdirs()<br>创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。<br>boolean    renameTo(File dest)<br>重新命名此抽象路径名表示的文件。<br>long    length()<br>返回由此抽象路径名表示的文件的长度。<br>boolean    isDirectory()<br>测试此抽象路径名表示的文件是否是一个目录。<br>boolean    isFile()<br>测试此抽象路径名表示的文件是否是一个标准文件。<br>boolean    isHidden()<br>测试此抽象路径名指定的文件是否是一个隐藏文件。<br>long    lastModified()<br>返回此抽象路径名表示的文件最后一次被修改的时间。<br>String    getName()<br>返回由此抽象路径名表示的文件或目录的名称。<br>String    getParent()<br>返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回 null。<br>File    getParentFile()<br>返回此抽象路径名父目录的抽象路径名；如果此路径名没有指定父目录，则返回 null。<br>boolean    delete()<br>删除此抽象路径名表示的文件或目录。<br>boolean    exists()<br>测试此抽象路径名表示的文件或目录是否存在。<br>boolean    createNewFile()<br>当且仅当不存在具有此抽象路径名指定名称的文件时，不可分地创建一个新的空文件。</p><pre><code>public class FileExample{      public static void main(String[] args) {          createFile();      }    /**    * 文件处理示例    */    public static void createFile() {       File f=new File(&quot;E:/电脑桌面/jar/files/create.txt&quot;);          try{              f.createNewFile();  //当且仅当不存在具有此抽象路径名指定名称的文件时，不可分地创建一个新的空文件。              System.out.println(&quot;该分区大小&quot;+f.getTotalSpace()/(1024*1024*1024)+&quot;G&quot;); //返回由此抽象路径名表示的文件或目录的名称。              f.mkdirs();  //创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。  //            f.delete(); //  删除此抽象路径名表示的文件或目录             System.out.println(&quot;文件名  &quot;+f.getName());  //  返回由此抽象路径名表示的文件或目录的名称。             System.out.println(&quot;文件父目录字符串 &quot;+f.getParent());// 返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回 null。          }catch (Exception e) {              e.printStackTrace();          }    }  }  </code></pre><h2 id="RamdomAccessFile"><a href="#RamdomAccessFile" class="headerlink" title="RamdomAccessFile"></a>RamdomAccessFile</h2><p>该对象并不是流体系中的一员，其封装了字节流，同时还封装了一个缓冲区（字符数组），通过内部的指针来操作字符数组中的数据。 该对象特点：</p><p>该对象只能操作文件，所以构造函数接收两种类型的参数：a.字符串文件路径；b.File对象。<br>该对象既可以对文件进行读操作，也能进行写操作，在进行对象实例化时可指定操作模式(r,rw)，r是只读不能写，rw是读写模式。<br>注意：该对象在实例化时，如果要操作的文件不存在，会自动创建；如果文件存在，写数据未指定位置，会从头开始写，即覆盖原有的内容。 可以用于多线程下载或多个线程同时写数据到文件。</p><p>此类的实例支持对随机访问文件的读取和写入。随机访问文件的行为类似存储在文件系统中的一个大型 byte 数组。存在指向该隐含数组的光标或索引，称为文件指针；输入操作从文件指针开始读取字节，并随着对字节的读取而前移此文件指针。如果随机访问文件以读取/写入模式创建，则输出操作也可用；输出操作从文件指针开始写入字节，并随着对字节的写入而前移此文件指针。写入隐含数组的当前末尾之后的输出操作导致该数组扩展。该文件指针可以通过 getFilePointer 方法读取，并通过 seek 方法设置。</p><p>通常，如果此类中的所有读取例程在读取所需数量的字节之前已到达文件末尾，则抛出 EOFException（是一种 IOException）。如果由于某些原因无法读取任何字节，而不是在读取所需数量的字节之前已到达文件末尾，则抛出 IOException，而不是 EOFException。需要特别指出的是，如果流已被关闭，则可能抛出 IOException。</p><p>常用方法：</p><p>void    close()<br>关闭此随机访问文件流并释放与该流关联的所有系统资源。<br>long    getFilePointer()<br>返回此文件中的当前偏移量。<br>long    length()<br>返回此文件的长度。<br>int    read()<br>从此文件中读取一个数据字节。<br>int    read(byte[] b)<br>将最多 b.length 个数据字节从此文件读入 byte 数组。<br>int    read(byte[] b, int off, int len)<br>将最多 len 个数据字节从此文件读入 byte 数组。<br>void    seek(long pos)<br>设置到此文件开头测量到的文件指针偏移量，在该位置发生下一个读取或写入操作。<br>void    setLength(long newLength)<br>设置此文件的长度。<br>void    write(int b)<br>向此文件写入指定的字节。</p><h2 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h2><p>InputStream 是所有的输入字节流的父类，它是一个抽象类。<br>ByteArrayInputStream、StringBufferInputStream、FileInputStream 是三种基本的介质流，它们分别从Byte 数组、StringBuffer、和本地文件中读取数据。PipedInputStream 是从与其它线程共用的管道中读取数据，与Piped 相关的知识后续单独介绍。<br>ObjectInputStream 和所有FilterInputStream 的子类都是装饰流（装饰器模式的主角）。</p><p>常用方法：<br>void    close()<br>关闭此输入流并释放与该流关联的所有系统资源。<br>void    mark(int readlimit)<br>在此输入流中标记当前的位置。<br>boolean    markSupported()<br>测试此输入流是否支持 mark 和 reset 方法。<br>abstract  int    read()<br>从输入流中读取数据的下一个字节。<br>int    read(byte[] b)<br>从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。<br>int    read(byte[] b, int off, int len)<br>将输入流中最多 len 个数据字节读入 byte 数组。<br>void    reset()<br>将此流重新定位到最后一次对此输入流调用 mark 方法时的位置。<br>long    skip(long n)<br>跳过和丢弃此输入流中数据的 n 个字节。</p><p>有哪些常用的子类：FileInputStream，ObjectInputStream等</p><p>分别实例其用法，方便快速回顾：</p><p>1.FileInputStream（文件字节输入流）</p><pre><code>package io;  import java.io.File;  import java.io.FileInputStream;  import java.io.IOException;  import java.io.InputStream;  public class ByteInput {      public static void main(String[] args) throws IOException {          //1、定义要使用的文件          File file = new File(&quot;F:&quot; + File.separator + &quot;byteInput.txt&quot;);          file.createNewFile();   //文件存在的时候不会执行，不存在的时候会执行          //2、定义字节输入流指定为文件输入流          InputStream input = new FileInputStream(file);          byte[] b = new byte[(int) file.length()]; // file.length()获取文件的长度返回long类型          int len = input.read(b);          input.close();          //3、验证输入结果          System.out.println(&quot;文件的内容长度为 : &quot; + len);          System.out.println(&quot;文件的内容为: &quot; + new String(b));      }  } </code></pre><p>2.ObjectInputStream（对象输入流）本例需要对象实现序列化接口，实现对文件内容的逐个对象处理<br>先定义一个实现Serializable接口的pojo实体类</p><pre><code>package io;    import java.io.Serializable;    public class StudentInfo implements Serializable{      private String stuno;      private String name;      private Integer age;      public StudentInfo() {      }      public StudentInfo(String stuno, String name, Integer age) {          super();          this.stuno = stuno;          this.name = name;          this.age = age;      }    //省略所有get/set方法 } package io;  import java.io.File;  import java.io.FileInputStream;  import java.io.IOException;  import java.io.ObjectInputStream;  public class ObjectInput {      public static void main(String[] args) throws IOException, ClassNotFoundException {          File file=new File(&quot;F:&quot;+File.separator+&quot;object.txt&quot;);          file.createNewFile();          ObjectInputStream in=new ObjectInputStream(new FileInputStream(file));          StudentInfo stu=(StudentInfo)in.readObject();          in.close();          System.out.println(stu);      }  }  </code></pre><h2 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h2><p>OutputStream 是所有的输出字节流的父类，它是一个抽象类。<br>ByteArrayOutputStream、FileOutputStream 是两种基本的介质流，它们分别向Byte 数组、和本地文件中写入数据。PipedOutputStream 是向与其它线程共用的管道中写入数据，<br>ObjectOutputStream 和所有FilterOutputStream 的子类都是装饰流。</p><p>常用方法：<br>void    close()<br>关闭此输出流并释放与此流有关的所有系统资源。<br>void    flush()<br>刷新此输出流并强制写出所有缓冲的输出字节。<br>void    write(byte[] b)<br>将 b.length 个字节从指定的 byte 数组写入此输出流。<br>void    write(byte[] b, int off, int len)<br>将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。<br>abstract  void    write(int b)<br>将指定的字节写入此输出流。</p><p>有哪些常用的子类呢：FileOutputStream，ObjectOutputStream等</p><p>分别实例其用法，方便快速回顾：</p><p>1.FileOutputStream（文件字节输出流）实现对文件内容的逐字节处理</p><pre><code>package io;  import java.io.File;  import java.io.FileOutputStream;  import java.io.IOException;  import java.io.OutputStream;  public class ByteOutput {      public static void main(String[] args) throws IOException{          //1、获取要操作的文件          File file=new File(&quot;F:&quot;+File.separator+&quot;byteOutput.txt&quot;);          file.createNewFile();          //2、写入指定的内容          String str=&quot;I Like Java!&quot;;          OutputStream output=new FileOutputStream(file);          output.write(str.getBytes(), 0, str.length()); //写入字符串          output.close();      }  }  </code></pre><p>2.ObjectOutputStream（对象输出流）本例需要对象实现序列化接口，实现对文件内容的逐个对象处理<br>pojo对象同5例中的StudentInfo对象，测试类如下（用到ObjectInputStream的那个对象）</p><pre><code>package io;  import java.io.File;  import java.io.FileOutputStream;  import java.io.IOException;  import java.io.ObjectOutputStream;  public class ObjectOutput {      public static void main(String[] args) throws IOException {          File file=new File(&quot;F:&quot;+File.separator+&quot;object.txt&quot;);          file.createNewFile();          StudentInfo student=new StudentInfo(&quot;10001&quot;,&quot;zhangsan&quot;,20);          ObjectOutputStream output=new ObjectOutputStream(new FileOutputStream(file));          output.writeObject(student);          output.close();      }  } </code></pre><h2 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h2><p>Reader 是所有的输入字符流的父类，它是一个抽象类。<br>CharReader、StringReader 是两种基本的介质流，它们分别将Char 数组、String中读取数据。PipedReader 是从与其它线程共用的管道中读取数据。<br>BufferedReader 很明显就是一个装饰器，它和其子类负责装饰其它Reader 对象。<br>FilterReader 是所有自定义具体装饰流的父类，其子类PushbackReader 对Reader 对象进行装饰，会增加一个行号。<br>InputStreamReader 是一个连接字节流和字符流的桥梁，它将字节流转变为字符流。FileReader 可以说是一个达到此功能、常用的工具类，在其源代码中明显使用了将FileInputStream 转变为Reader 的方法。我们可以从这个类中得到一定的技巧。Reader 中各个类的用途和使用方法基本和InputStream 中的类使用一致。后面会有Reader 与InputStream 的对应关系。</p><p>常用子类：FileReader，BufferedReader等</p><p>分别实例其用法，方便快速回顾：</p><p>1.FileReader（文件字符输入流）实现对文件内容的逐字符处理</p><pre><code>package io;  import java.io.File;  import java.io.FileReader;  import java.io.IOException;  import java.io.Reader;  public class CharInput {      public static void main(String[] args) throws IOException {          //1、指定要操作的文件          File file=new File(&quot;F:&quot;+File.separator+&quot;charInput.txt&quot;);          file.createNewFile();          //2、指定字节输入流          Reader reader=new FileReader(file);          char[] c=new char[(int)file.length()];          int len=reader.read(c);          reader.close();          //3、验证          System.out.println(&quot;字符流读取文件的长度为: &quot;+len);          System.out.println(&quot;字符流读取文件的内容: &quot;+new String(c));      }  } </code></pre><p>2.BufferedReader（缓存文件输入流）实现对文件内容的逐行处理</p><pre><code>package io;  import java.io.BufferedReader;  import java.io.File;  import java.io.FileReader;  import java.io.IOException;  public class BufferReaderDemo {      public static void main(String[] args) throws IOException {          //指定文件          File file = new File(&quot;F:&quot; + File.separator + &quot;buffered.txt&quot;);          file.createNewFile();          //定义需要验证的变量          int i = 1;          String str;          StringBuffer buffer = new StringBuffer();          //定义逐行读入的流          BufferedReader br = new BufferedReader(new FileReader(file));          while ((str = br.readLine()) != null) {    //逐行读取并验证              System.out.println(&quot;读取的行数: &quot; + (i));              buffer.append(str);              System.out.println(&quot;第&quot; + (i++) + &quot;行的内容为: &quot; + str);          }          br.close();          //打印最终结果          System.out.println(&quot;\n文件中的全部内容为: &quot;+buffer.toString());      }  }  </code></pre><h2 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h2><p>Writer 是所有的输出字符流的父类，它是一个抽象类。<br>CharArrayWriter、StringWriter 是两种基本的介质流，它们分别向Char 数组、String 中写入数据。PipedWriter 是向与其它线程共用的管道中写入数据，<br>BufferedWriter 是一个装饰器为Writer 提供缓冲功能。<br>PrintWriter 和PrintStream 极其类似，功能和使用也非常相似。<br>OutputStreamWriter 是OutputStream 到Writer 转换的桥梁，它的子类FileWriter 其实就是一个实现此功能的具体类（具体可以研究一SourceCode）。功能和使用和OutputStream 极其类似，后面会有它们的对应图。</p><p>常用子类：FileWriter，BufferedWriter等</p><p>分别实例其用法，方便快速回顾：</p><p>1.FileWriter（文件字符输出流）实现对文件内容的逐字符处理</p><pre><code>package io;  import java.io.File;  import java.io.FileWriter;  import java.io.IOException;  import java.io.Writer;  public class CharOutput {      public static void main(String[] args) throws IOException {          File file = new File(&quot;F:&quot; + File.separator + &quot;charOutput.txt&quot;);          file.createNewFile();          Writer writer = new FileWriter(file);          writer.write(&quot;I Love Basketball！&quot;, 0, 18);          writer.close();      }  } </code></pre><p>2.BufferedWriter（缓存文件输出流）实现对文件内容的逐行处理</p><pre><code>package io;  import java.io.BufferedWriter;  import java.io.File;  import java.io.FileWriter;  import java.io.IOException;  import java.io.Writer;  public class BufferedWriterDemo {      public static void main(String[] args) throws IOException{          //指定文件          File file=new File(&quot;F:&quot;+File.separator+&quot;buffered.txt&quot;);          file.createNewFile();          //指定          Writer bw=new BufferedWriter(new FileWriter(file,true));          bw.write(&quot;\r\n&quot;);          bw.write(&quot;XiaoHuangRen like banana!&quot;);          bw.write(&quot;\r\n&quot;);          bw.write(&quot;XiaoHuangRen like bana!&quot;);          bw.close();      }  }</code></pre><p>资料参考：<a href="https://blog.csdn.net/qq_34207422/article/details/76149026" target="_blank" rel="noopener">https://blog.csdn.net/qq_34207422/article/details/76149026</a>  </p><h2 id="那么如何使用这4种类型呢？"><a href="#那么如何使用这4种类型呢？" class="headerlink" title="那么如何使用这4种类型呢？"></a>那么如何使用这4种类型呢？</h2><p>关于字节流和字符流到底用哪个来处理实际的业务需求呢</p><p>字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。 字节流和字符流的区别：</p><p>读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。<br>处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。</p><p>结论：只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。字节流可以处理全部数据类型的传输，但是字符流就只适合读写纯文字的数据。</p><h2 id="关于缓冲流（常用）"><a href="#关于缓冲流（常用）" class="headerlink" title="关于缓冲流（常用）"></a>关于缓冲流（常用）</h2><p>java.io提供了四种数据传输的缓冲技术</p><p>BufferedInputStream<br>BufferedOutputStream<br>BufferedReader<br>BufferedWriter </p><p>其常用的构造方法：</p><p>BufferedReader（Reader in）<br>BufferedReader（Reader in,int sz）//sz为自定义缓冲区大小<br>BufferedWriter （Writer out）<br>BufferedWriter （ Writer out, int sz）<br>BufferedInputStream（InputStream in）<br>BufferedInputStream（ InputStream in,int size）<br>BufferedOutputStream （OutputStream out）<br>BufferedOutputStream （OutputStream out,int size）<br>前四个四字符流，后四个是字节流</p><p>带缓冲的字节输入流：上面我们知道文件字节输入流的读取时，是直接同字节流中读取的。由于字节流是与硬件（存储介质）进行的读取，所以速度较慢。而CPU需要使用数据时通过read()、read(byte[])读取数据时就要受到硬件IO的慢速度限制。我们又知道，CPU与内存发生的读写速度比硬件IO快10倍不止，所以优化读写的思路就有了：在内存中建立缓存区，先把存储介质中的字节读取到缓存区中。CPU需要数据时直接从缓冲区读就行了，缓冲区要足够大，在被读完后又触发fill()函数自动从存储介质的文件字节内容中读取字节存储到缓冲区数组。</p><p>BufferedInputStream 内部有一个缓冲区，默认大小为8M，每次调用read方法的时候，它首先尝试从缓冲区里读取数据，若读取失败（缓冲区无可读数据），则选择从物理数据源 （譬如文件）读取新数据（这里会尝试尽可能读取多的字节）放入到缓冲区中，最后再将缓冲区中的内容返回给用户.由于从缓冲区里读取数据远比直接从存储介质读取速度快，所以BufferedInputStream的效率很高。</p><h2 id="转换流（常用）"><a href="#转换流（常用）" class="headerlink" title="转换流（常用）"></a>转换流（常用）</h2><p>字符流与字节流转换</p><p>转换流的特点：</p><p>其是字符流和字节流之间的桥梁<br>可对读取到的字节数据经过指定编码转换成字符<br>可对读取到的字符数据经过指定编码转换成字节<br>何时使用转换流？</p><p>当字节和字符之间有转换动作时；<br>流操作的数据需要编码或解码时。<br>具体的对象体现：</p><p>InputStreamReader:字节到字符的桥梁<br>OutputStreamWriter:字符到字节的桥梁<br>这两个流对象是字符体系中的成员，它们有转换作用，本身又是字符流，所以在构造的时候需要传入字节流对象进来。</p><blockquote><p>InputStreamReader演示：</p></blockquote><p>InputStreamReader是字节流通向字符流的桥梁，它使用指定的charset读取字节并将其解码为字符。它拥有一个InputStream类型的变量，并继承了Reader，使用了对象的适配器模式</p><p>根据InputStream的实例创建InputStreamReader的方法有4种：</p><p>InputStreamReader(InputStream in);<br>//根据默认字符集创建<br>InputStreamReader(InputStream in, Charset cs);<br>//使用给定字符集创建<br>InputStreamReader(InputStream in, CharsetDecoder dec);<br>//使用给定字符集解码器创建<br>InputStreamReader(InputStream in, String charsetName);<br>//使用指定字符集创建 </p><p>后面的3个构造函数都指定了一个字符集，最后一个是最简单的，可以直接指定字符集的名称来创建，例如GB2312等。</p><p>每次调用InputStreamReader中的一个read()方法都会导致从底层输入流读取一个或多个字节。要启用从字节到字符的有效转换，可以提前从底层流读取更多的字节，使其超过满足当前读取操作所需的字节。共有3个可用的read()方法：</p><p>int read();<br>//读取单个字符<br>int read(char[] cbuf, int offset, int length);<br>//将字符读入数组中的某一部分<br>boolean ready();<br>//判断此流是否已经准备好用于读取 </p><p>InputStreamReader继承自Reader，因此该类的实例可以被各种输入字符流包装。为了达到最高效率，可以考虑在BufferedReader内包装InputStreamReader。我们首先创建了一个FileInputStream类的实例，然后转换为InputStreamReader对象is，最后使用BufferedReader进行包装。这样就可以将字节流转换为带缓冲功能的字符流。</p><pre><code>public class TestInputStreamReader {      public static void main(String[] args) {          try {  // 创建输入流  FileInputStream fis = new FileInputStream(&quot;D:/demo/test.txt&quot;);  InputStreamReader is = new InputStreamReader(fis);  BufferedReader bis = new BufferedReader(is);  // 从输入流读取数据  while (bis.ready()) {      int c = bis.read();      System.out.print((char)c);  }  // 关闭输入流  bis.close();  is.close();  fis.close();          } catch (IOException e) {          }      }  } </code></pre><blockquote><p>OutputStreamWriter演示：</p></blockquote><p>OutputStreamWriter是字符流通向字节流的桥梁，可使用指定的charset将要写入流中的字符编码成字节。因此，它拥有一个OutputStream类型的变量，并继承了Writer，使用了对象的适配器模式</p><p>根据OutputStream的实例创建OutputStreamWriter的方法有4种：</p><p>OutputStreamReader(OutputStream out);<br>//根据默认字符集创建<br>OutputStreamReader(OutputStream out, Charset cs);<br>//使用给定字符集创建<br>OutputStreamReader(OutputStream out, CharsetDecoder dec);<br>//使用给定字符集解码器创建<br>OutputStreamReader(OutputStream out, Stroutg charsetName);<br>//使用指定字符集创建 </p><p>后面的3个构造函数都制定了一个字符集，最后一个是最简单的，可以直接指定字符集的名称来创建，例如GB2312等。</p><p>每次调用write()方法都会导致在给定字符（或字符集）上调用编码转换器。在写入底层输出流之前，得到的这些字节将在缓冲区中累积。可以指定此缓冲区的大小，不过，默认的缓冲区对多数用途来说已足够大。注意，传递给write()方法的字符没有缓冲。共有3个可用的write()方法：</p><p>void write(char[] cbuf, int off, int len);//写入字符数组的某一部分<br>void write(int c);//写入单个字符<br>void write(String str, int off, int len);//写入字符串的某一部分<br>OutputStreamWriter继承自Writer，因此该类的实例可以被各种输出字符流包装。为了达到最高效率，可以考虑在BufferedWriter内包装OutputStreamWriter。我们首先创建了一个FileOutputStream类的实例，然后转换为OutputStreamReader对象os，最后使用BufferedWriter进行包装。这样就可以将字节流转换为带缓冲功能的字符流。</p><pre><code>public class TestOutputStreamWriter {      public static void main(String[] args) {          try {          // 创建输出流              FileOutputStream fos = new FileOutputStream(&quot;D:/demo/test.txt&quot;);              OutputStreamWriter os = new OutputStreamWriter(fos);              BufferedWriter bos = new BufferedWriter(os);              // 写入数组数据              char[] buf = new char[3];              buf[0] = &apos;a&apos;;              buf[1] = &apos;b&apos;;              buf[2] = &apos;中&apos;;              bos.write(buf);              // 关闭输出流              bos.close();              os.close();              fos.close();          } catch (IOException e) {          }      }  } </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;流的概念和作用&quot;&gt;&lt;a href=&quot;#流的概念和作用&quot; class=&quot;headerlink&quot; title=&quot;流的概念和作用&quot;&gt;&lt;/a&gt;流的概念和作用&lt;/h1&gt;&lt;p&gt;流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。&lt;br&gt;集合框架相当于数据结构，那么IO框架就相当于数据传输。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="java类库" scheme="http://yoursite.com/tags/java%E7%B1%BB%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>创业之路--企业技术支持</title>
    <link href="http://yoursite.com/2018/03/26/%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E6%90%AD%E5%BB%BA01/"/>
    <id>http://yoursite.com/2018/03/26/从无到有搭建01/</id>
    <published>2018-03-25T16:20:30.000Z</published>
    <updated>2018-03-26T12:48:23.629Z</updated>
    
    <content type="html"><![CDATA[<p>中小型互联网企业的技术支持到底有哪些（数据来源于网络爬虫及本人总结），项目包括多终端接口（WEB,IOS,Android），接入微服务架构，服务端软件层面主要语言为JAVA开发，考虑架构稳定性以及可拓展性，灵活性，硬件层面包括完整的企业级应用主机服务器，服务器商业托管服务，数据管理中心，云计算，大数据，OA系统，ERP软件，数据库储存方案等等，企业对接服务包括400电话，企业邮箱，企业公众号等等，关于这些技术我都会做总结。我尽量用最简洁的语言来做阐述，帮助我的合作伙伴解决技术疑惑。</p><a id="more"></a><h1 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h1><p>上面一堆屁话，让人云里雾里心生恐惧，为什么一个小型项目需要这么多的技术支持！！先解释一下，一个多终端设备并且以网络用户作为企业交互人群的项目公司都可以成为互联网企业，首先做一个略微完整的项目需要的最小项目软硬件架构是什么，首先先做下分析：</p><p>首先根据你的产品预估你的访问量和人数大概在什么位置：</p><p>网站统计中的PV(访问量)：UV(独立访客)：IP(独立IP)的定义与区别（名词解释）</p><p>PV(访问量)：即Page View, 即页面浏览量或点击量，用户每次刷新即被计算一次。</p><p>UV(独立访客)：即Unique Visitor,访问您网站的一台电脑客户端为一个访客。00:00-24:00内相同的客户端只被计算一次。</p><p>IP(独立IP)：即Internet Protocol,指独立IP数。00:00-24:00内相同IP地址之被计算一次。</p><p>QPS：每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。</p><p>要想分析自己的产品大概需求是什么样的，可以看“日PV”这个数据，就是说网站在各种终端中累计点击多少次，打个比喻，你的产品拥有完整的各终端接口服务，一天有100个手机用户点击你的软件，每人点击数量不一致，可预估取中间值也就是20次刷新页面（考虑到现在的异步更新功能以减少页面刷新提高用户体验的技术，取20次），而手机系统分为IOS和Android，结果乘2,100<em>20</em>2=4000次页面访问，web端属于PC端页面服务，考虑到现在移动端使用频繁于WEB端，所以取1000点击，那么你的软件日PV就是5000的访问量级。</p><p>目前互联网中如果某个系统的日pv在千万级别以上,他就可能是一个高并发的系统，中小型的互联网企业的日均PV在10w~300w这个级别。<br>我们的项目系统不只有用户在访问，还有企业的访问量，开发的访问量等等，以这个区间作为系统搭建的参数。</p><p>下面贴出我去年做的软硬件系统拓展的流程图：可以看下互联网硬件为了应付日益增多的用户应该如何做好技术选型的</p><p><img src="/2018/03/26/从无到有搭建01/p1.jpg" alt="logo"><br><img src="/2018/03/26/从无到有搭建01/p2.jpg" alt="logo"><br><img src="/2018/03/26/从无到有搭建01/p3.jpg" alt="logo"><br><img src="/2018/03/26/从无到有搭建01/p4.jpg" alt="logo"></p><p>如果我们按照中小型互联网的PV参数作为技术选型标准的话，该从什么方面去选择硬件。</p><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>首先一个企业的核心是一台交互处理所有信息的主机，也就是服务器，所有移动端接口都对接到这里，数据库也对接到这里，网站也对接这里，处理数据，储存数据，展示数据，页面访问控制，业务需要和所有的功能实现都要在一个服务器里实现。</p><p>这里有4个方案：（除了物理服务器是真实可见的，其他三个都升虚拟的）</p><p>1.云服务器<br>2.物理服务器（前期转中期）<br>3.VPS<br>4.虚拟主机</p><h3 id="区别和解释"><a href="#区别和解释" class="headerlink" title="区别和解释"></a>区别和解释</h3><ul><li>什么是云服务器</li></ul><p>云服务器是在一组集群服务器上虚拟出多个类似独立服务器的部分，集群中每个服务器上都有云服务器的一个镜像，从而大大提高了虚拟服务器的安全稳定性，除非所有的集群内服务器全部出现问题，云服务器才会无法访问。</p><p>云主机是一群服务器做镜像然后分割的虚拟机，价格适中，但是很稳定，基本没有宕机。<br>宕机，指操作系统无法从一个严重系统错误中恢复过来，或系统硬件层面出问题，以致系统长时间无响应，而不得不重新启动计算机的现象。它属于电脑运作的一种正常现象，任何电脑都会出现这种情况。</p><p>云服务器就是将多个传统的服务器连接在一起，形成一个大的超级计算机，这个超级计算机里有多个类似独立服务器的部分，可以根据用户的需求提供给予其使用。由于可以按需付费，并且可以弹性伸缩，所以成本低廉，是现在很多企业倾向于选择的一种方式。而且现在做云服务器提供商越来越多，这也是市场的需求和选择，最著名的肯定就是BAT，还有一些专业型的比如小鸟云计算这一类公司，所以个人认为，这应该是一种时代趋势吧。</p><ul><li>什么是物理服务器 （也叫独立服务器）</li></ul><p>独立服务器是客户拥有整台服务器的软硬件资源，可以自行配置或通过主机管理工具实现web、mail、ftp等多种网络服务。由于整台服务器只有一个用户使用，在服务器硬件资源以及带宽资源上都得到了极大的保障。  优势/适用范围：稳定安全、独享带宽、可绑定多个IP地址、可单独设置防火墙，可扩展硬件等。适用于中高端用户。</p><p>服务器就是一台主机，你自己买自己用，没有专业维护人员的话要托管，费用比较高。一般公司不推荐。涉及到专业服务器硬件托管公司。</p><ul><li>什么是VPS主机</li></ul><p>VPS主机是在强大的 互联网服务器集群上，利用虚拟化及集中存储等技术构建的主机租用产品，每个VPS主机都是一台虚拟独立的服务器，具有完整的服务器功能，并且比同配置的物理服务器更灵活，具有更安全更稳定的性能。</p><p>具有完整的物理服务器 功能，同时具有高性价比、高安全性、高灵活性。适用于业务快速成长的的商业运营公司/需要各地分支机构共享内部资源筹建信息化服务平台的大中型行业门户网站。  vps是一台主机虚拟出来的，和人家合用一台机器，见不到物理的机器，但是可以挂自己的网站，价格便宜但是不稳定。</p><ul><li>什么是虚拟主机</li></ul><p>所谓虚拟主机，也叫“网站空间”，即把一台运行在互联网上的服务器划分成多个具有一定大小的硬盘空间，每个空间都给予相应的FTP权限和Web访问权限，以用于网站发布。</p><p>低成本高利用率，是中小企业提高企业竞争力的重要手段。适用于个人网站或中小型网站。</p><h3 id="如何选型"><a href="#如何选型" class="headerlink" title="如何选型"></a>如何选型</h3><p>既然初创产业没那么多资金，物理服务器当然不需要考虑，而且没有这么多当量的数据量，购买或租用独立服务器的成本在创业预算范围之外。<br>另外虚拟主机的局限性也有，只适合做门户网站，对于响应的业务处理没有两者优。</p><p>考虑云服务或者VPS。。。<br>1.如果同台服务器的1台VPS被攻击，将直接影响其他的所有VPS无法运行。同等情况下云服务器只影响被攻击云计算服务器，其他同服务器的云计算服务器不受影响。  </p><p>2.云计算服务器运行前会预先将硬件内存分配好,如果服务器上有4G内存绝不能分配出5G的内存出来,而VPS服务器自生拥有4G内存可以虚拟100G的内存，并分配给100个独立操作系统。  </p><p>3.在同等性能的前提下,降低你在数据中心消费成本的一半以上  </p><p>4.vps对运营商来说成本较低,因为1台服务器可以虚拟上数十个VPS主机,云计算服务器对运营商来说相当于独立服务器出租。成本略低于独立服务器出租,需要有相当实力的运营商才能提供。  目前提供云服务的国外亚马逊比较牛叉，国内的话有腾讯云、阿里云、盛大云等大企业。</p><p>产品选型建议选择云计算服务器，均衡性能</p><h3 id="关于市面上的云计算产品的报价"><a href="#关于市面上的云计算产品的报价" class="headerlink" title="关于市面上的云计算产品的报价"></a>关于市面上的云计算产品的报价</h3><p>阿里云计算各项产品（报价均衡在每个月200到500不等）</p><p><img src="/2018/03/26/从无到有搭建01/p5.png" alt="logo"><br><img src="/2018/03/26/从无到有搭建01/p6.png" alt="logo"><br><img src="/2018/03/26/从无到有搭建01/p7.png" alt="logo"></p><p>还有阿里的全套产品线</p><p><img src="/2018/03/26/从无到有搭建01/p8.png" alt="logo"></p><p>腾讯云计算各项产品</p><h1 id="移动端开发"><a href="#移动端开发" class="headerlink" title="移动端开发"></a>移动端开发</h1><p>一个项目计划若想要加入移动端数据支持，那么需要多少成本来筹建到完成产品呢？</p><p>就大部分的App项目而言，开发一个app标配的项目需要开发一套后台管理系统（CMS） + 安卓客户端 + iOS客户端，大多数项目的开发成本在12 - 25万不等，具体需要根据App的功能复杂度，质量要求，开发哪些平台等因素来确定具体的价格。另外，个人兼职，团队或工作室，或者专业的app开发公司，报价的成本会有比较大的差距，开发出来的质量也会有比较大的差距，一般报价的成本：个人 &lt; 团队 &lt; 公司，而质量也是跟价格成正比：个人兼职 &lt; 团队 &lt; 公司。</p><p>接下来分析如果一个初创公司若想实现移动端，无非就是两种开发手段</p><p>1.自建团队<br>2.外包项目</p><p>首先初创公司想要召集一批人来做移动端实现，那么需要哪些人</p><ol><li><p>开发一个App项目的人员配置比较复杂。开发网站只需要一个端的开发人员即可以了，而开发app需要三个端的开发人员，通常也相对同样功能的网站开发成本的三倍工作量。App项目的人员基本配置有：产品经理，项目经理一名，UI设计师一名，后台开发工程师两名，安卓开发工程师两名，iOS开发工程师两名，测试人员两名。这里是对专业的App开发公司而言，一般个人或团队可能一个人会身兼多职，所以开发出来的项目质量也不能得到保证； </p></li><li><p>App开发的人工成本相对网站要高一些。通常一个有一两年安卓或iOS开发经验的开发人员，人工成本就要达到1万左右（由于当前的市场环境对开发人才的需求较高，使得技术开发的人工成本也较高）。通常一个app项目的基本人工成本达到2-5来万，再加上员工福利，设备，场地，人员管理，营销成本和商务沟通成本，基本上一个app项目的基本投入成本就要去到8-10万左右。这个暂且不计人员的空档期，招聘的成本，项目的风险等因素。这是对于一个已经具备成熟App开发团队的公司所需要付出的价位，对于完全没有App开发团队和相关开发经验的公司而言，这个成本估计至少需要翻一倍，开发周期要拉很长，基本才能达到前者类似的效果。</p></li></ol><p>开发一个app需要多少钱，需要综合评估app的功能需求，质量要求，需要开发哪些平台端，以此评估出需要投入多少的人工设计和开发量，即可基本测算出app的开发成本。</p><p>自建团队的优点：</p><ol><li><p>沟通高效：由于都在同个办公室，沟通方便，随时可以面对面交流，可以快速讨论出解决方案并执行；</p></li><li><p>需求把握更准确：选择开发公司合作，通常开发成本都需要在合同签订前就确定下来，所以设计通常也被预算所限定，一旦设计确定下来后，就不允许频繁地变更需求，除非只是一是很小的调整，或者额外追加开发的成本。而自建团队的话，通常开发过程中有一些不理想或不合理的设计，调整和优化的灵活度会高很多，可以更纯粹地考虑产品项目本身的合理性和用户体验性，弱化开发成本的控制；</p></li><li><p>可以充分配合实际的项目运营：比如后期项目需要做活动，或者临时有一些额外的需求需要增加，自建团队可以在极短的时间内讨论出方案并执行，而跟第三方技术团队合作，则前期需要沟通需求，评估开发成本，还有安排开发时间等等工作，通常需要好多个来回的沟通，导致浪费了好多时间；</p></li></ol><p>自建团队的缺点：</p><ol><li><p>开发周期长：创业前期需要组建团队，磨合，且人手经常不够用，导致开发周期会被拉长；</p></li><li><p>需要解决人员招聘，人员流动性等问题，特别是非技术基因的团队，很难招聘或留住技术人才；</p></li><li><p>需要分散很多的精力放在技术上面，特别是在项目启动前期，需要投入非常多的精力开发系统；</p></li><li><p>项目管理成本高：由于开发一套系统，在不同的时间点，需要不同的专业技能，且任务有前后置的衔接关系，这会导致经常在某个专业领域缺人，无法执行后续的开发，或者执行完某个任务后，就会空出一些人手暂时用不上，导致管理成本非常高。相对而言，技术公司由于同时会进行多个项目，所以可以最大程度减少人力成本的浪费，减少管理成本；</p></li></ol><p>那么回归到我们这个问题本身：应该采用自建团队开发，还是找技术公司合作的方案呢？我觉得这个问题的核心关键点需要看创始团队的人员配置。</p><p>1.偏技术型团队：通常创始团队大都比较擅长技术，并且拥有丰富的开发经验。那么，自建技术团队开发是最省成本，也是最合适的方案。这里面存在两种情况：一是技术方面只有一个核心骨干，或只擅长其中的某一部分（如整套系统涵盖app开发和网站开发，但技术创始人只擅长web端的开发），这时会导致系统前期的开发周期会拉长，可以采取招聘其他的技术人才，或众包的方式；二是技术团队很强大，基本可以开发整套系统，那么基本可以自行搞定开发完整套系统。但通常技术类型的团队前期很容易犯的一个错误是，把大多数的时间投入在技术和系统的开发方面，却忽视了设计，营销推广等领域的积累和学习，导致一些项目开发出来后，却没能运营推广起来，最终导致项目半路夭折（比如我们团队初期就犯过这样一个错误）。</p><p>2.偏运营型团队：这种类型的团队比较擅长运营及营销推广这个领域，但不具备技术的基因。通常运营团队的创业项目核心在运营层面，技术相对次要，所以建议还是找一家技术开发公司合作，把技术相关的开发工作交给技术合作公司搞定，团队专攻运营领域。有些创业者由于预算有限，技术公司的开发成本又太高，可能会觉得自己搭建一个技术团队会更省成本，更高效。我觉得这是一个错误的认知。首先，运营型的团队通常不在技术这个圈子，认识的技术人才非常有限，加上创业前期招聘人才本身就比较困难，通常需要很长的时间才能招聘到相应的技术人才，可能还不是优秀的技术人才；其次，开发一个IT系统需要的专业人才比较多，比如开发一个app，按照专业开发公司的配置，需要产品经理，UI设计师，安卓，iOS，后台开发工程师，测试工程师等专业人才，创业型公司不可能会有这么豪华的人才配置，通常都是一人当几个人用，而这样导致的结果是开发出来的系统质量一般；再者，通常系统的启动初期，对技术人才是一个比较大的缺口，但一旦系统开发完成，后期只需要较少量的运维工作，并不需要这么多的技术人员，所以可能会导致人员和成本浪费，这也是一块比较大的成本损失。当然，如果找技术公司合作的话，能否找到靠谱的合作团队，是这个项目成败的一个非常关键的要点。这方面建议多一点慎重的考量，不要为了节省小额的开发成本，而忽视了对项目质量，以及技术团队的要求。</p><p>3.综合配置型团队：相对而言，这种类型的创业团队人员配置较为合理，既有技术人才，也有运营和营销专长，各个领域也有相应的人才资源和圈子，所以项目的成活率也会高很多。这种类型的团队可以考虑找技术公司合作，也可以自己招聘技术人才自行开发，两个方案的可行性都比较高。从长远的角度看，如果要真正做好一个项目，最终还是需要建立自己的技术团队，这样才能减少沟通的成本，严格把控好每一个需求点，并打磨好项目的每一个细节。但这个可能需要基于团队有技术基因，或者资金允许的情况下。这需要一个过程，毕竟技术团队的招聘，搭建，磨合，开发流程的优化等等都需要有一段路要走，特别是对于没有技术基因的团队，可能是一个需要用很多精力和时间投入才能去克服的一个问题。除了创始团队的配置外，项目的类型（比如是偏技术型项目，像今日头条，还是偏运营的项目，像大多数自建的电商平台），也是其中的一个重点考量因素。创业者需要根据自身的团队的优劣势，人员的配置情况，项目类型，以及对于各个领域的人才需求情况做一个整体的评估，再决定是否需要自建一支技术团队。术业有专攻，创业初期，务必要把最核心的资源和力量，放在刀刃上面，并懂得借助第三方的资源和力量。因为第三方的资源和技术本身就是为了顺应创业市场的要求而出现的。</p><p>市场经验：（我们的项目属于综合配置型团队）</p><p>案例一：（有技术合伙人，对软件开发流程有详细认知，可维护，可选择外包后拿回源码自己改，后期迭代升级组建团队）</p><p>我公司这边也有不少项目是外包出去的。在初期，为了快速实现，把项目外包出去是一个好的选择，毕竟自建团队需要投入的资金和时间，还有管理都是很庞大的。但是慢慢的，问题也随之而来。对于外包项目，外包公司使用的是最简单最快实现的框架去做，对于各种情况诸如兼容性（此问题手机端尤其突出）、扩展性、软件访问效率等问题都不会考虑，他们只负责交付给你一个能用的产品，而不是可用的产品，并帮你维护一段时间，合约便结束了。而且在维护期内，如果你有什么其他需求或改动，都是需要另收费的，很麻烦，有时候即使你反应了问题，也不会立刻帮你修改，而是要等。更为麻烦的是，在之后，你还是需要找人去接手这个项目，拿回源码自己去做修改自己去做开发。所以，我的建议是，自建团队是最好的。我们公司的初期项目，为了市场推广的需要，先是找了外包公司做了webview，我们自己开发网页端嵌入，这样就能进行快速迭代，满足市场需要，所以页面的变动都是在网页端，而不需要经过外包公司和上架审核。然后在这段时间内自建ios和android团队，拿回外包的源码自己维护，以及自己开发真正的app，因为经过市场反馈，我们app需要的功能也很明确，之前的接口都是可用，所以开发可以很快.然后替换掉webview..</p><p>案例二：（纯外包，没有技术合伙人，闹得很尴尬）</p><p>客户A：传统招聘行业，老板准备投几百万嫁装互联网的招聘平台，在朋友推荐下跟一家软件公司合作，以远超行业价格的费用签约，原本按行业水平三个月能开发好的系统，硬是拖了半年才完成，但功能简陋，设计毫无美观，项目因为不达标一直没有上线。一年后，准备投第二笔钱做项目的迭代优化，原先的供应商又报了一个离谱的价格。老板无奈之下重新选择了供应商，由于原开发的项目代码混乱，设计糟糕，把之前的项目推翻从零再次开发，但已错过了互联网项目最佳的推广时期；<br>客户B：法律行业，拿了天使投资准备开发一个互联网法律服务平台，创始团队有律师背景，产品经理，运营人才，只差一个技术合伙人。在没有技术基础的情况下，选择自建技术团队，前前后后招聘技术人才花了不少时间（2014年互联网人才非常紧缺），后经过长达一年的项目开发，把一个一流的设计方案，开发出了三流的山寨效果，项目因为质量原因，迟迟不能上线，也基本把项目的所有开发预算耗完。后请求投资人意见，希望再度投钱重新启动开发项目；<br>客户C：教育行业，由于朋友公司刚好有技术团队有空档，整个项目外包给朋友的技术开发团队，因技术负责人不懂产品设计，不擅沟通，且没有做好项目进度和质量管控，项目严重延期，且质量远远达不到预期。客户C无奈下，选择终止合作，但经过长达半个多月的交涉，才完成项目交接，且双方也闹得不太愉快。</p><p>如何找一个给力且满意的技术第三方？</p><p>靠谱的技术服务商需要具备哪些条件？<br>通过哪些渠道可以找到比较高质量的技术服务商？<br>如何在锁定的几家技术服务商中选择一个最适合的团队合作？</p><p>靠谱的技术服务商需要具备哪些条件？</p><p>甲方–我们公司        乙方–第三方技术提供方</p><p>1.做事诚信靠谱：这个是首要考虑的条件，做事靠谱是最重要的，不然在后续的合作过程中会出现很多坑。比如价格低开高走，为了追求利润而进行错误的引导，提出的问题拖着不解决，各种不配合，设置系统的后门等等。有很多人咨询过关于合同制订的问题，怕合同里面有什么不合理的条约，我觉得合同这些都是次要的，在中国这样的人情社会，合同对于乙方的约束并不大，而且诉讼流程漫长而繁琐。核心的关键点还是在于乙方的靠谱程度，即使在合同约束范围外的问题，靠谱的服务商也会尽心尽力地去帮甲方解决问题；</p><p>2.专业能力强：这方面主要考察专业的深度问题，通常项目开发的成败主要是技术和设计这两方面决定的，设计决定了项目的呈现效果和交互体验，技术决定了项目的最终质量，稳定性和实际体验，所以需要重点对技术和设计的深度做了解。由于对接人一般是业务或产品经理，并不能对这方面有一个深入的了解，一般只能通过公司过往的实际案例，团队的基因，工作经验年限，公司的一些原创文章去做了解和判断。</p><p>3.综合能力全面：一个完整的项目开发流程不单单只是技术，还牵涉到设计，管理，测试等环节，如果在某一些环节上面出现严重的短板，务必对项目的最终效果会产生很大的影响。这里牵涉到专业能力的广度问题，涉及到的能力范畴有：商务的对接能力，需求的梳理能力，业务的理解能力，产品的设计能力，UI的设计能力，技术的开发能力，项目的管理能力，质量把控的测试能力。对于任意一家服务商，都有他们擅长的领域，通常创始团队的基因决定了公司擅长的领域，比如业务型的团队擅长营销，技术型的团队技术上面很有优势，而设计出身的团队能产出更好的设计方案。一般都没有面面俱全的公司，需要评估公司的综合能力，避免在某个领域存在致命的短板；</p><p>通过哪些渠道可以找到比较高质量的技术服务商？</p><p>找行业内专业的朋友推荐（靠谱指数：5星）：这个是找服务商的首选方式，但朋友一定是专业，并且懂行的人，这个非常重要，因为他会帮你做初步的筛选和甄别，并且会站在客观的立场帮你做分析，推荐合适的公司或开发团队；</p><p>通过高质量的文章查找服务商（靠谱指数：4星）：通过知乎，微信，论坛，新媒体等平台，查找一些跟项目相关的高质量文章，如搜索”APP开发”，”微信开发”，”网站开发”之类的业务关键词，然后找到里面的一些高质量高水平的文章（硬广的广告一律pass掉），通常文章里面会留有作者或公司的一些联系方式，尝试跟这个领域的专家勾搭联系，然后让他（她）通过自荐或推荐的方式，找到匹配的技术服务商；</p><p>通过搜索引擎查找服务商（靠谱指数：3星）：相对前两种方式，通过这种方式可以快速地找到几百上千家技术服务商，这类公司通常知名度较高，但基本都是非常擅长投放百度竞价或SEO优化的公司，营销和市场能力较强，但技术和设计能力反而不是特别出色。由于业务量和咨询人数较多，做得好的公司有一定人数规模，收费相对而言也比较贵，性价比总体而言不高；</p><p>通过众包平台查找服务商（靠谱指数：3星）：比如通过程序员客栈，码市等众包平台寻找接包方。这类平台相对而言，聚焦了一批相对优质的个人开发者，价格相对猪八戒等平台要偏高一些，但相对整包给公司，价格要少一些。优点是质量相对可控，有一定的成本优势，缺点是由于项目的开发人员都通过远程协助开发的方式，且没有经过长期的团队配合，有些开发人员是兼职开发，对于项目周期及开发人员比较难把控，适合有技术合伙人的公司去对接零散的异地开发人员；</p><p>通过一些中介平台查找服务商（靠谱指数：2星）：比如猪八戒，一品威客，智城等。这类平台汇集了比较多的低端开发者和公司，价格便宜，但服务和项目质量低，适合一些小项目或对质量要求不高，价格敏感的创业者。</p><p>如何在锁定的几家技术服务商中选择一个最适合的团队合作？<br>经过前面一轮初步的筛选和沟通，最终可以锁定了几家技术服务商，并经过细致的沟通后拿到了各个服务商的报价方案。那么，在最终选择服务商的时候，应该怎么选择最合适并且匹配的服务商呢？这里面牵涉到很多专业性的判断和技巧，如果身边有专业的朋友，建议咨询一下朋友的专业意见，从报价的合理性，服务商的技术，设计能力，需求梳理规划的合理性提供一些参考意见。</p><p>以下提供一些不需要专业技能进行判断选择的方法：</p><p>项目与服务商的匹配度：如果只是做做一个很小的app项目，比如开发一个计算器之类的小应用，找一个兼职的设计师和一个兼职的APP开发人员，或者一个小的开发团队即可完成这个项目；如果你的预算不多，对质量要求也不高，但牵涉到多个端的开发的话，找一个报价低，专业能力一般的小公司开发就足以应付这个项目；如果你项目较大，质量要求高，且牵涉到有一定技术难点的应用，如AR功能，就需要找专业的开发公司来开发了，价格肯定也不会比较贵。有些创业者只有几万的预算，却总想着找一个专业能力强，牛人多，且开发一个复杂的应用，这个时候就只能去购买标准的产品了，而不是走定制的方向，能力越强，规模越大的公司，收费也越贵。如果预算方面比较充裕，请忽略这一点；</p><p>价格的比较：相信很多人拿到多份报价方案的时候，一脸茫然，不知道怎么去进行对比，每家公司报的价格出入很大，而且需求描述，功能规划也不尽相同，采用什么技术方案也没有说明，没有一个标准的对比性。这时对于非专业的人来说可能只看最终的价格，这是很大的一个误区。理想的情况下，作为甲方，应该尽可能地把自己的需求描述清楚，最好写一份文字说明文档，并多一些耐心跟每一个服务商沟通清楚，确定大家对于需求理解上的一致。其次，尽可能套出每个供应商的能接受的最低价格。如果大家的理解都是准确的话，拿到报价后对功能进行逐一对比就有了标准需求的参照，这时需要特别留意报价方案上面有没有遗漏的功能点，或者在某些需求描述上面含糊不清，这个对最终的价格也有很大的影响。一般价格选择上面，会更偏向于中等或中等偏上的供应商。</p><p>最终的选择：结合上面提到的诚信靠谱度，专业能力，综合能力这三个维度，对每一个供应商进行一个综合的打分。如果供应商有开发过类似行业的应用，或者类似的功能，是一个加分项。最后结合价格做一个最终的权衡，基本就可以得出应该要选哪个供应商了。</p><p>当然，权衡利弊，若要自己选择搭建可靠地团队，需要付出的是开发时间成本，但是产品的走向可以根据自己的来，质量完全由自己控制，还有人力资源，因为若想要自己筹建团队来搞这个项目，首先你要招人，这些招聘开销以及人员的工资，让一个项目从零到1开发出来，时间不固定，若是有完整可靠地开发团队想跟你走这个创业的道路当然是最好。<br>若是选择外包，质量永远不可能像自己写的这么好，而且项目一旦在谈产品需求报价确定后，是不可能进行频繁修改的，这其中也有很高的联系成本，产品开发出来是什么样就是什么样了，只能自己维护，当然外包也有好处，就是交由第三方先把总体框架写出来，上线快，可以很快的投入使用，因为外包公司做项目，里面肯定有一些已经现成做好的功能，只需要作为模块添加到你的产品组装即可，开发时间较快。</p><p>综合考虑，若是要拿出具体的成品再来谈风投的话，可以选择自己筹钱去谈外包，把外部框架快速做好再取跟风投谈。<br>若是没有成品的前提下要去谈风投的话，则等到风投钱到位后，召集人马自己搭建团队做项目即可。这无疑是最好的办法。</p><p>IT外包对于创业公司来说，又爱又恨，不得已而为之者居多。初创公司，有多少是在跑DEMO，因此预算控制，是最重要的一件事。预算有多少，就去做多大的事，量力而行，活在当下，摸着石头过河，是期待问题，而不是技术实现问题。因此，创业公司CEO首先应该做的是根据目前的情况，计算可靠预算，同时，管理自己的期望，做好市场预期规划。而不是，好大喜功，妄图花小钱办大事，世界上没有免费的午餐，即使如此，占得一时便宜，也绝不具有持续性。</p><p>IT外包能够最快最大限度实现产品和服务的落地，成本低廉，但是产品质量和后续维护的坑多到难以置信，让你”万万想不到”！</p><p>最常见的坑是：</p><p>1.项目需求对接不清，成本差异过大，技术公司要求追加高昂费用，烂尾机率很大</p><p>2.因为语言不统一，项目按人工时间成本计算价格，重新学习他人语言逻辑时间成本耗时费力，一般项目难以找到接盘侠，大概率推翻重做，前期投入均为空</p><p>3.大外包公司，成本高昂，但服务质量缩水，对创业公司友好度低，有质量得技术基本都在别的大项目组，很可能碰到实习生水平的技术但花着比政府项目还多的钱；</p><p>4.小外包公司，人员素质水平差异大，难以判断，后续支持力不足，长期维护难度大，技术实现风险高………………</p><p>既然如此，建立自己的开发团队是最好的也最长久的选择，但是初创公司自己建立团队的难点在哪儿呢？</p><p>1.初创公司，市场预期不明确，项目风险大，项目是否有良好的盈利能力不能准确预期，如此前提，养着一个开发团队造成现金流巨大压力，可能直接导致项目毙命</p><p>2.IT团队的cto可遇而不可求，寻找合伙人本身就难度很大，与资源和人脉，自身魅力，公司前景，运气都有极大关系，样样具备，难上加难，一个不合格的合伙人也会直接导致团队溃败…………如此，初创公司在钱不多，在跑demo又急于落地，最佳选择，是不存在的！！！但是我们可以有曲线救国的选项！！！控制成本，项目落地，管理预期风险是最重要的生存保障，那么，策略是：管理预期需求，提升it技术知识经验，在成本控制范围内寻找靠谱的外包公司实现核心需求的落地。随着项目落地，有一定变现能力，寻找投资，搭建技术团队，推倒重建，进行迭代。</p><p>我的想法：</p><p>若是我们有一定的资金但是没有风投又急于快速占领市场，可以选择快速外包，然后合伙人部分做维护，同时让产品快速进入运营期以补贴亏损，一旦赚到钱或者获得风投，迅速招人，广纳良将，作为初创公司的第一批技术储备力量，从外包公司的源码做升级迭代优化，甚至完全替换。</p><p>若是以项目完整度拿到风投资金，则完全不考虑外包或者可以考虑部分外包，只做框架，或者我们招美工去设计，由自己掌控，让产品快速上线。</p><h2 id="国内外包移动端服务公司数据收集及评定"><a href="#国内外包移动端服务公司数据收集及评定" class="headerlink" title="国内外包移动端服务公司数据收集及评定"></a>国内外包移动端服务公司数据收集及评定</h2><p>先列出网络数据源收集的公司，之后我再做系统的综合评定。。。</p><p>可以选择知名公司去做（安全稳定，但是报价高），可以选择新外包企业（因为也不排除一些新公司想通过质量去赢得市场），主要是看运气，能不能找到一家质量高又价钱合理的公司，因为做生意总想着找便宜又质量好的东西。</p><p>1.广州微匠互联网科技有限公司<br>广州市海珠区新港中路浩蕴大厦1105房（地铁客村D出口，TIT创意园正对面）<br>致力于互联网移动端项目从0到1一站式开发，新公司，案例少，但是质量有可能较高。</p><p>2.</p><p>资源收集：<br><a href="https://www.zhihu.com/question/31155811" target="_blank" rel="noopener">https://www.zhihu.com/question/31155811</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中小型互联网企业的技术支持到底有哪些（数据来源于网络爬虫及本人总结），项目包括多终端接口（WEB,IOS,Android），接入微服务架构，服务端软件层面主要语言为JAVA开发，考虑架构稳定性以及可拓展性，灵活性，硬件层面包括完整的企业级应用主机服务器，服务器商业托管服务，数据管理中心，云计算，大数据，OA系统，ERP软件，数据库储存方案等等，企业对接服务包括400电话，企业邮箱，企业公众号等等，关于这些技术我都会做总结。我尽量用最简洁的语言来做阐述，帮助我的合作伙伴解决技术疑惑。&lt;/p&gt;
    
    </summary>
    
      <category term="创业之路" scheme="http://yoursite.com/categories/%E5%88%9B%E4%B8%9A%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="创业" scheme="http://yoursite.com/tags/%E5%88%9B%E4%B8%9A/"/>
    
      <category term="技术支持" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E6%94%AF%E6%8C%81/"/>
    
      <category term="平台搭建" scheme="http://yoursite.com/tags/%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot之路(四)--Swagger2（RESTful API统一文档）</title>
    <link href="http://yoursite.com/2018/03/24/springboot04/"/>
    <id>http://yoursite.com/2018/03/24/springboot04/</id>
    <published>2018-03-24T09:22:09.000Z</published>
    <updated>2018-03-25T16:26:02.200Z</updated>
    
    <content type="html"><![CDATA[<p>现如今的互联网开发，一款成熟的产品往往不只有Web作为前端，有可能要面对多个开发人员或多个开发团队：IOS开发、Android开发或是Web开发等等，现在的多终端时代，有可能我们需要开发所有市面的终端设备。</p><p>由于Spring Boot能够快速开发、便捷部署等特性，相信有很大一部分Spring Boot的用户会用来构建RESTful API。而我们构建RESTful API的目的通常都是由于多终端的原因，这些终端会共用很多底层业务逻辑，因此我们会抽象出这样一层来同时服务于多个移动端或者Web前端。</p><p>随着互联网技术的发展，现在的网站架构基本都由原来的后端渲染，变成了：前端渲染、先后端分离的形态，而且前端技术和后端技术在各自的道路上越走越远。<br>前端和后端的唯一联系，变成了API接口；API文档变成了前后端开发人员联系的纽带，变得越来越重要，swagger就是一款让你更好的书写API文档的框架。</p><p>这样一来，我们的RESTful API就有可能要面对多个开发人员或多个开发团队：IOS开发、Android开发或是Web开发等。为了减少与其他团队平时开发期间的频繁沟通成本，传统做法我们会创建一份RESTful API文档来记录所有接口细节，然而这样的做法有以下几个问题：</p><a id="more"></a><p>1.由于接口众多，并且细节复杂（需要考虑不同的HTTP请求类型、HTTP头部信息、HTTP请求内容等），高质量地创建这份文档本身就是件非常吃力的事，下游的抱怨声不绝于耳。</p><p>2.随着时间推移，不断修改接口实现的时候都必须同步修改接口文档，而文档与代码又处于两个不同的媒介，除非有严格的管理机制，不然很容易导致不一致现象。</p><p>如何在开发团队中实现一个RESTful API的接口统一文档？</p><h1 id="Swagger2"><a href="#Swagger2" class="headerlink" title="Swagger2"></a>Swagger2</h1><p>使用Swagger之前我们先需要构建一个RESTful API来做准备。</p><p>RESTful API具体设计如下：</p><p><img src="/2018/03/24/springboot04/p1.png" alt="logo"></p><p>User实体定义：</p><pre><code>public class User {     private Long id;     private String name;     private Integer age;     // 省略setter和getter }</code></pre><p>实现对User对象的操作接口：</p><pre><code>@RestController @RequestMapping(value=&quot;/users&quot;)     // 通过这里配置使下面的映射都在/users下 public class UserController {     // 创建线程安全的Map     //利用Collections工具类中的synchronizedMap方法来构建同步Map    //SynchronizedMap类是定义在Collections中的一个静态内部类。    //它实现了Map接口，并对其中的每一个方法实现，通过synchronized关键字进行了同步控制    //这样的好处在于Map不会产生混乱，当有并发请求时这个Map会进行同步锁。    static Map&lt;Long, User&gt; users = Collections.synchronizedMap(new HashMap&lt;Long, User&gt;());     @RequestMapping(value=&quot;/&quot;, method=RequestMethod.GET)     public List&lt;User&gt; getUserList() {         // 处理&quot;/users/&quot;的GET请求，用来获取用户列表         // 还可以通过@RequestParam从页面中传递参数来进行查询条件或者翻页信息的传递        //users.Values()获取用户信息的所有值并传递给一个List集合，然后通过返回集合呈现过我们         List&lt;User&gt; r = new ArrayList&lt;User&gt;(users.values());         return r;     }     @RequestMapping(value=&quot;/&quot;, method=RequestMethod.POST)     public String postUser(@ModelAttribute User user) {         // 处理&quot;/users/&quot;的POST请求，用来创建User         // 除了@ModelAttribute绑定参数之外，还可以通过@RequestParam从页面中传递参数         users.put(user.getId(), user);         return &quot;success&quot;;     }     @RequestMapping(value=&quot;/{id}&quot;, method=RequestMethod.GET)     public User getUser(@PathVariable Long id) {         // 处理&quot;/users/{id}&quot;的GET请求，用来获取url中id值的User信息         // url中的id可通过@PathVariable绑定到函数的参数中         return users.get(id);     }     @RequestMapping(value=&quot;/{id}&quot;, method=RequestMethod.PUT)     public String putUser(@PathVariable Long id, @ModelAttribute User user) {         // 处理&quot;/users/{id}&quot;的PUT请求，用来更新User信息         User u = users.get(id);         u.setName(user.getName());         u.setAge(user.getAge());         users.put(id, u);         return &quot;success&quot;;     }     @RequestMapping(value=&quot;/{id}&quot;, method=RequestMethod.DELETE)     public String deleteUser(@PathVariable Long id) {         // 处理&quot;/users/{id}&quot;的DELETE请求，用来删除User         users.remove(id);         return &quot;success&quot;;     } }</code></pre><p>下面针对该Controller编写测试用例验证正确性，具体如下。当然也可以通过浏览器插件等进行请求提交验证。</p><pre><code>@RunWith(SpringJUnit4ClassRunner.class) //@SpringApplicationConfiguration(classes = MockServletContext.class) @WebAppConfiguration public class ApplicationTests {     private MockMvc mvc;     @Before     public void setUp() throws Exception {         mvc = MockMvcBuilders.standaloneSetup(new UserController()).build();     }     @Test     public void testUserController() throws Exception {         // 测试UserController         RequestBuilder request = null;         // 1、get查一下user列表，应该为空         request = get(&quot;/users/&quot;);         mvc.perform(request)                 .andExpect(status().isOk())                 .andExpect(content().string(equalTo(&quot;[]&quot;)));         // 2、post提交一个user         request = post(&quot;/users/&quot;)                 .param(&quot;id&quot;, &quot;1&quot;)                 .param(&quot;name&quot;, &quot;测试大师&quot;)                 .param(&quot;age&quot;, &quot;20&quot;);         mvc.perform(request)                 .andExpect(content().string(equalTo(&quot;success&quot;)));         // 3、get获取user列表，应该有刚才插入的数据         request = get(&quot;/users/&quot;);         mvc.perform(request)                 .andExpect(status().isOk())                 .andExpect(content().string(equalTo(&quot;[{\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;测试大师\&quot;,\&quot;age\&quot;:20}]&quot;)));         // 4、put修改id为1的user         request = put(&quot;/users/1&quot;)                 .param(&quot;name&quot;, &quot;测试终极大师&quot;)                 .param(&quot;age&quot;, &quot;30&quot;);         mvc.perform(request)                 .andExpect(content().string(equalTo(&quot;success&quot;)));         // 5、get一个id为1的user         request = get(&quot;/users/1&quot;);         mvc.perform(request)                 .andExpect(content().string(equalTo(&quot;{\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;测试终极大师\&quot;,\&quot;age\&quot;:30}&quot;)));         // 6、del删除id为1的user         request = delete(&quot;/users/1&quot;);         mvc.perform(request)                 .andExpect(content().string(equalTo(&quot;success&quot;)));         // 7、get查一下user列表，应该为空         request = get(&quot;/users/&quot;);         mvc.perform(request)                 .andExpect(status().isOk())                 .andExpect(content().string(equalTo(&quot;[]&quot;)));     } }</code></pre><p>测试Console内容：</p><pre><code>2018-03-25 23:25:23.827  INFO 7832 --- [           main] com.didispace.ApplicationTests           : Starting ApplicationTests on DX-20170223SFUP with PID 7832 (F:\SpringBoot-Learning\Chapter3-1-1\target\test-classes started by Administrator in F:\SpringBoot-Learning\Chapter3-1-1)2018-03-25 23:25:23.829  INFO 7832 --- [           main] com.didispace.ApplicationTests           : No active profile set, falling back to default profiles: default2018-03-25 23:25:24.217  INFO 7832 --- [           main] o.s.w.c.s.GenericWebApplicationContext   : Refreshing org.springframework.web.context.support.GenericWebApplicationContext@6d2a209c: startup date [Sun Mar 25 23:25:24 CST 2018]; root of context hierarchy2018-03-25 23:25:25.640  INFO 7832 --- [           main] com.didispace.ApplicationTests           : Started ApplicationTests in 3.468 seconds (JVM running for 6.448)2018-03-25 23:25:26.400  INFO 7832 --- [           main] ilder$StaticRequestMappingHandlerMapping : Mapped &quot;{[/hello]}&quot; onto public java.lang.String com.didispace.web.HelloController.index()2018-03-25 23:25:26.431  INFO 7832 --- [           main] ilder$StaticRequestMappingHandlerMapping : Mapped &quot;{[/users/],methods=[GET]}&quot; onto public java.util.List&lt;com.didispace.domain.User&gt; com.didispace.web.UserController.getUserList()2018-03-25 23:25:26.432  INFO 7832 --- [           main] ilder$StaticRequestMappingHandlerMapping : Mapped &quot;{[/users/],methods=[POST]}&quot; onto public java.lang.String com.didispace.web.UserController.postUser(com.didispace.domain.User)2018-03-25 23:25:26.432  INFO 7832 --- [           main] ilder$StaticRequestMappingHandlerMapping : Mapped &quot;{[/users/{id}],methods=[GET]}&quot; onto public com.didispace.domain.User com.didispace.web.UserController.getUser(java.lang.Long)2018-03-25 23:25:26.432  INFO 7832 --- [           main] ilder$StaticRequestMappingHandlerMapping : Mapped &quot;{[/users/{id}],methods=[PUT]}&quot; onto public java.lang.String com.didispace.web.UserController.putUser(java.lang.Long,com.didispace.domain.User)2018-03-25 23:25:26.433  INFO 7832 --- [           main] ilder$StaticRequestMappingHandlerMapping : Mapped &quot;{[/users/{id}],methods=[DELETE]}&quot; onto public java.lang.String com.didispace.web.UserController.deleteUser(java.lang.Long)2018-03-25 23:25:27.204  INFO 7832 --- [           main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.test.web.servlet.setup.StubWebApplicationContext@44a7bfbc2018-03-25 23:25:27.498  INFO 7832 --- [           main] o.s.mock.web.MockServletContext          : Initializing Spring FrameworkServlet &apos;&apos;2018-03-25 23:25:27.499  INFO 7832 --- [           main] o.s.t.web.servlet.TestDispatcherServlet  : FrameworkServlet &apos;&apos;: initialization started2018-03-25 23:25:27.500  INFO 7832 --- [           main] o.s.t.web.servlet.TestDispatcherServlet  : FrameworkServlet &apos;&apos;: initialization completed in 1 ms2018-03-25 23:25:27.890  INFO 7832 --- [           main] ilder$StaticRequestMappingHandlerMapping : Mapped &quot;{[/hello]}&quot; onto public java.lang.String com.didispace.web.HelloController.index()2018-03-25 23:25:27.896  INFO 7832 --- [           main] ilder$StaticRequestMappingHandlerMapping : Mapped &quot;{[/users/],methods=[GET]}&quot; onto public java.util.List&lt;com.didispace.domain.User&gt; com.didispace.web.UserController.getUserList()2018-03-25 23:25:27.896  INFO 7832 --- [           main] ilder$StaticRequestMappingHandlerMapping : Mapped &quot;{[/users/],methods=[POST]}&quot; onto public java.lang.String com.didispace.web.UserController.postUser(com.didispace.domain.User)2018-03-25 23:25:27.897  INFO 7832 --- [           main] ilder$StaticRequestMappingHandlerMapping : Mapped &quot;{[/users/{id}],methods=[GET]}&quot; onto public com.didispace.domain.User com.didispace.web.UserController.getUser(java.lang.Long)2018-03-25 23:25:27.897  INFO 7832 --- [           main] ilder$StaticRequestMappingHandlerMapping : Mapped &quot;{[/users/{id}],methods=[PUT]}&quot; onto public java.lang.String com.didispace.web.UserController.putUser(java.lang.Long,com.didispace.domain.User)2018-03-25 23:25:27.897  INFO 7832 --- [           main] ilder$StaticRequestMappingHandlerMapping : Mapped &quot;{[/users/{id}],methods=[DELETE]}&quot; onto public java.lang.String com.didispace.web.UserController.deleteUser(java.lang.Long)2018-03-25 23:25:27.920  INFO 7832 --- [           main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.test.web.servlet.setup.StubWebApplicationContext@61fe302018-03-25 23:25:27.927  INFO 7832 --- [           main] o.s.mock.web.MockServletContext          : Initializing Spring FrameworkServlet &apos;&apos;2018-03-25 23:25:27.927  INFO 7832 --- [           main] o.s.t.web.servlet.TestDispatcherServlet  : FrameworkServlet &apos;&apos;: initialization started2018-03-25 23:25:27.927  INFO 7832 --- [           main] o.s.t.web.servlet.TestDispatcherServlet  : FrameworkServlet &apos;&apos;: initialization completed in 0 ms2018-03-25 23:25:27.952  INFO 7832 --- [       Thread-1] o.s.w.c.s.GenericWebApplicationContext   : Closing org.springframework.web.context.support.GenericWebApplicationContext@6d2a209c: startup date [Sun Mar 25 23:25:24 CST 2018]; root of context hierarchy</code></pre><p>这个是用MockMVC来做数据分析，当然我们也可以直接用浏览器发送请求来实战测试，这就需要浏览器发送GET请求和POST请求<br>那么按照我们常规的方法是编写一个网站来发送POST请求（因为POST请求是不直接表达在URL上的）<br>所以这就需要借助浏览器的一些插件来实现发送POST请求</p><p>我们开发的工具是Google的Chrome浏览器，我们通过应用市场下载POSTMAN插件就可以实现浏览器发送POST请求<br>做WEB端开发的人员必须要下载这个插件作为调试页面访问请求的数据显示。</p><h2 id="Postman插件概述"><a href="#Postman插件概述" class="headerlink" title="Postman插件概述"></a>Postman插件概述</h2><p>Postman插件是什么？postman插件是一款chrome插件，是谷歌浏览器的网页调试插件，这款插件可以利用Chrome插件的形式把各种模拟用户HTTP请求的数据发送到服务器，以便开发人员能够及时地作出正确的响应，或者是对产品发布之前的错误信息提前处理，进而保证产品上线之后的稳定性和安全性。Postman是一种网页调试与发送网页http请求的chrome插件。我们可以用来很方便的模拟get或者post或者其他方式的请求来调试接口。</p><ul><li>Postman插件功能介绍</li></ul><p>当开发人员需要调试一个网页是否运行正常，并不是简简单单地调试网页的HTML、CSS、脚本等信息是否运行正常，更加重要的是网页能够正确是处理各种HTTP请求，毕竟网页的HTTP请求是网站与用户之间进行交互的非常重要的一种方式，在动态网站中，用户的大部分数据都需要通过HTTP请求来与服务器进行交互。可以利用Chrome插件的形式把各种模拟用户HTTP请求的数据发送到服务器，以便开发人员能够及时地作出正确的响应，或者是对产品发布之前的错误信息提前处理，进而保证产品上线之后的稳定性和安全性。</p><p>POSTman教程及安装：<a href="http://www.cnplugins.com/devtool/postman/" target="_blank" rel="noopener">http://www.cnplugins.com/devtool/postman/</a></p><p>它可以轻松的整合到Spring Boot中，并与Spring MVC程序配合组织出强大RESTful API文档。它既可以减少我们创建文档的工作量，同时说明内容又整合入实现代码中，让维护文档和修改代码整合为一体，可以让我们在修改代码逻辑的同时方便的修改文档说明。另外Swagger2也提供了强大的页面测试功能来调试每个RESTful API。具体效果如下图所示：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现如今的互联网开发，一款成熟的产品往往不只有Web作为前端，有可能要面对多个开发人员或多个开发团队：IOS开发、Android开发或是Web开发等等，现在的多终端时代，有可能我们需要开发所有市面的终端设备。&lt;/p&gt;
&lt;p&gt;由于Spring Boot能够快速开发、便捷部署等特性，相信有很大一部分Spring Boot的用户会用来构建RESTful API。而我们构建RESTful API的目的通常都是由于多终端的原因，这些终端会共用很多底层业务逻辑，因此我们会抽象出这样一层来同时服务于多个移动端或者Web前端。&lt;/p&gt;
&lt;p&gt;随着互联网技术的发展，现在的网站架构基本都由原来的后端渲染，变成了：前端渲染、先后端分离的形态，而且前端技术和后端技术在各自的道路上越走越远。&lt;br&gt;前端和后端的唯一联系，变成了API接口；API文档变成了前后端开发人员联系的纽带，变得越来越重要，swagger就是一款让你更好的书写API文档的框架。&lt;/p&gt;
&lt;p&gt;这样一来，我们的RESTful API就有可能要面对多个开发人员或多个开发团队：IOS开发、Android开发或是Web开发等。为了减少与其他团队平时开发期间的频繁沟通成本，传统做法我们会创建一份RESTful API文档来记录所有接口细节，然而这样的做法有以下几个问题：&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://yoursite.com/categories/springboot/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
      <category term="springboot" scheme="http://yoursite.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot之路(三)--Thymeleaf模板引擎</title>
    <link href="http://yoursite.com/2018/03/24/springboot03/"/>
    <id>http://yoursite.com/2018/03/24/springboot03/</id>
    <published>2018-03-24T05:23:22.000Z</published>
    <updated>2018-03-24T18:35:30.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h1><p>在实际的公司开发中，传统的JSP技术由于前段后端结合太过紧密，而且后端人员需要随时测试数据能不能渲染在界面上，这就需要前端与后端部门过于紧耦合，不利于实际开发，反而是模板引擎用的较多（当然也不排除一些老的公司需要维护公司以前的动态JSP网页）</p><p>thymeleaf最大的优势后缀为html,就是只需要浏览器就可以展现页面了,还有就是thymeleaf可以很好的和spring集成.</p><p>Thymeleaf是一个XML/XHTML/HTML5模板引擎，可用于Web与非Web环境中的应用开发。它是一个开源的Java库，基于Apache License 2.0许可，由Daniel Fernández创建，该作者还是Java加密库Jasypt的作者。</p><a id="more"></a><p>Thymeleaf提供了一个用于整合Spring MVC的可选模块，在应用开发中，你可以使用Thymeleaf来完全代替JSP或其他模板引擎，如Velocity、FreeMarker等。Thymeleaf的主要目标在于提供一种可被浏览器正确显示的、格式良好的模板创建方式，因此也可以用作静态建模。你可以使用它创建经过验证的XML与HTML模板。相对于编写逻辑或代码，开发者只需将标签属性添加到模板中即可。接下来，这些标签属性就会在DOM（文档对象模型）上执行预先制定好的逻辑。</p><h1 id="静态资源访问"><a href="#静态资源访问" class="headerlink" title="静态资源访问"></a>静态资源访问</h1><p>在我们开发Web应用的时候，需要引用大量的js、css、图片等静态资源。</p><h1 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h1><p>Spring Boot默认提供静态资源目录位置需置于classpath下，目录名需符合如下规则：</p><pre><code>/static/public/resources/META-INF/resources</code></pre><p>举例：我们可以在src/main/resources/目录下创建static，在该位置放置一个图片文件。启动程序后，尝试访问<a href="http://localhost:8088/D.jpg。如能显示图片，配置成功。" target="_blank" rel="noopener">http://localhost:8088/D.jpg。如能显示图片，配置成功。</a></p><p>在之前的示例中，我们都是通过@RestController来处理请求，所以返回的内容为json对象。那么如果需要渲染html页面的时候，要如何实现呢？</p><p>在动态HTML实现上Spring Boot依然可以完美胜任，并且提供了多种模板引擎的默认配置支持，所以在推荐的模板引擎下，我们可以很快的上手开发动态网站。</p><p>Spring Boot提供了默认配置的模板引擎（抛弃传统的JSP动态网页）主要有以下几种：</p><p>Thymeleaf<br>FreeMarker<br>Velocity<br>Groovy<br>Mustache</p><p>Spring Boot建议使用这些模板引擎，避免使用<strong>JSP</strong>，若一定要使用JSP将无法实现Spring Boot的多种特性，具体可见后文：支持JSP的配置</p><p>当你使用上述模板引擎中的任何一个，它们默认的模板配置路径为：src/main/resources/templates。当然也可以修改这个路径，具体如何修改，可在后续各模板引擎的配置属性中查询并修改。</p><p>示例：</p><pre><code>&lt;table&gt;  &lt;thead&gt;    &lt;tr&gt;      &lt;th th:text=&quot;#{msgs.headers.name}&quot;&gt;Name&lt;/td&gt;      &lt;th th:text=&quot;#{msgs.headers.price}&quot;&gt;Price&lt;/td&gt;    &lt;/tr&gt;  &lt;/thead&gt;  &lt;tbody&gt;    &lt;tr th:each=&quot;prod : ${allProducts}&quot;&gt;      &lt;td th:text=&quot;${prod.name}&quot;&gt;Oranges&lt;/td&gt;      &lt;td th:text=&quot;${#numbers.formatDecimal(prod.price,1,2)}&quot;&gt;0.99&lt;/td&gt;    &lt;/tr&gt;  &lt;/tbody&gt;&lt;/table&gt;</code></pre><p>可以看到Thymeleaf主要以<strong>属性</strong>的方式加入到html标签中，浏览器在解析html时，当检查到没有的属性时候会忽略，所以Thymeleaf的模板可以通过浏览器直接打开展现，这样非常有利于前后端的分离。</p><p>在Spring Boot中使用Thymeleaf，只需要引入下面依赖，并在默认的模板路径src/main/resources/templates下编写模板文件即可完成。</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>在完成配置之后，举一个简单的例子，在快速入门工程的基础上，举一个简单的示例来通过Thymeleaf渲染一个页面。</p><pre><code>package com.example.springboot.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class IndexController {    @RequestMapping(&quot;/index&quot;)    public String index(ModelMap map){        map.addAttribute(&quot;hello&quot;, &quot;i love you@com&quot;);        return &quot;index&quot;;    }}</code></pre><p>相应的index.html界面代码为</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/meta&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1 th:text=&quot;${hello}&quot;&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>启动程序后，页面输入<a href="http://localhost:8088/index，所出现的显示数据是：i" target="_blank" rel="noopener">http://localhost:8088/index，所出现的显示数据是：i</a> love you@com，并没有出现Hello World<br>展现的是IndexController中的hello的属性值，做到了不破坏HTML自身内容的数据逻辑分离。</p><p>注意：我们建立模板测试或者是实际开发中，我们都需要严格遵守thymeleaf的HTML5页面规范，不然会报错<br>包括我上面写的<meta>标签则需要双标签来自正常结束才可以，否则页面将出现错误，你可以使用严格的标签，也就是每个标签都有结束标签，这种可能比较麻烦。</p><p>那么如何在thymeleaf中声明使用非严格的html5规范呢？</p><p>maven添加依赖</p><pre><code>&lt;dependency&gt;        &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt;        &lt;artifactId&gt;nekohtml&lt;/artifactId&gt;        &lt;version&gt;1.9.22&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>application.properties属性文件中添加</p><p>spring.thymeleaf.mode = LEGACYHTML5</p><p>声明thymeleaf使用非严格的html即可。最后更新下maven仓库即可生效。</p><h1 id="关于Thymeleaf的默认参数配置"><a href="#关于Thymeleaf的默认参数配置" class="headerlink" title="关于Thymeleaf的默认参数配置"></a>关于Thymeleaf的默认参数配置</h1><p>如有需要修改默认配置的时候，只需复制下面要修改的属性到application.properties中，并修改成需要的值，如修改模板文件的扩展名，修改默认的模板路径等。</p><p>-Enable template caching.<br>spring.thymeleaf.cache=true<br>-Check that the templates location exists.<br>spring.thymeleaf.check-template-location=true<br>-Content-Type value.<br>spring.thymeleaf.content-type=text/html<br>-Enable MVC Thymeleaf view resolution.<br>spring.thymeleaf.enabled=true<br>-Template encoding.<br>spring.thymeleaf.encoding=UTF-8<br>-Comma-separated list of view names that should be excluded from resolution.<br>spring.thymeleaf.excluded-view-names=<br>-Template mode to be applied to templates. See also StandardTemplateModeHandlers.<br>spring.thymeleaf.mode=HTML5<br>-Prefix that gets prepended to view names when building a URL.<br>spring.thymeleaf.prefix=classpath:/templates/<br>-Suffix that gets appended to view names when building a URL.<br>spring.thymeleaf.suffix=.html  spring.thymeleaf.template-resolver-order= # Order of the template resolver in the chain. spring.thymeleaf.view-names= # Comma-separated list of view names that can be resolved.</p><h1 id="关于Thymeleaf语法"><a href="#关于Thymeleaf语法" class="headerlink" title="关于Thymeleaf语法"></a>关于Thymeleaf语法</h1><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>对于Thymeleaf语法来说，很多资料中会写应用Thymeleaf语法需要先在<html>标签中引入<br>在html中引入此命名空间，可避免编辑器出现html验证错误，虽然加不加命名空间对Thymeleaf的功能没有任何影响。</html></p><pre><code>&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</code></pre><p>才可以使用Thymeleaf语法，但是我在上面的案例中并没有声明html标签的属性也可以用，也让我很费解。（不过为了一些不必要的麻烦还是把这个声明加上）</p><h2 id="输出内容"><a href="#输出内容" class="headerlink" title="输出内容"></a>输出内容</h2><p>例如:</p><pre><code>Controller:    map.addAttribute(&quot;hello&quot;, &quot;i love you@com&quot;);HTML:    &lt;h1 th:text=&quot;${hello}&quot;&gt;Hello World&lt;/h1&gt;1. th:text  用来将内容输出到所在标签的body中。2. ${hello} 用来引用hello属性值3. 可以用th:utext 用来显示“unescaped ” 的html内容。(unescaped即非转义字符)</code></pre><p>例如：</p><pre><code>&lt;p th:text=&quot;#{home.welcome}&quot;&gt;Welcome to our grocery store!&lt;/p&gt;`#{home.welcome} 用来引入数据home对象中的 welcome属性。`</code></pre><h2 id="标准表达式语法"><a href="#标准表达式语法" class="headerlink" title="标准表达式语法"></a>标准表达式语法</h2><p>它们分为四类：</p><p>1.变量表达式<br>2.选择或星号表达式<br>3.文字国际化表达式<br>4.URL表达式</p><h3 id="变量表达式"><a href="#变量表达式" class="headerlink" title="变量表达式"></a>变量表达式</h3><p>变量表达式即OGNL表达式或Spring EL表达式(在Spring术语中也叫model attributes)。如下所示：</p><p>${session.user.name}<br>${hello}</p><p>它们将以HTML标签的一个属性来表示：</p><pre><code>&lt;span th:text=&quot;${book.author.name}&quot;&gt;  &lt;li th:each=&quot;book : ${books}&quot;&gt;  </code></pre><h3 id="选择-星号-表达式"><a href="#选择-星号-表达式" class="headerlink" title="选择(星号)表达式"></a>选择(星号)表达式</h3><p>选择表达式很像变量表达式，不过它们用一个预先选择的对象来代替上下文变量容器(map)来执行，如下：</p><p>*{customer.name}</p><p>被指定的object由th:object属性定义：</p><pre><code>&lt;div th:object=&quot;${book}&quot;&gt;    ...    &lt;span th:text=&quot;*{title}&quot;&gt;...&lt;/span&gt;    ...  &lt;/div&gt;  </code></pre><h3 id="文字国际化表达式"><a href="#文字国际化表达式" class="headerlink" title="文字国际化表达式"></a>文字国际化表达式</h3><p>文字国际化表达式允许我们从一个外部文件获取区域文字信息(.properties)，用Key索引Value，还可以提供一组参数(可选).</p><pre><code>`#{main.title} ``#{message.entrycreated(${entryId})} `</code></pre><p>可以在模板文件中找到这样的表达式代码：</p><pre><code>&lt;table&gt;    ...    &lt;th th:text=&quot;#{header.address.city}&quot;&gt;...&lt;/th&gt;    &lt;th th:text=&quot;#{header.address.country}&quot;&gt;...&lt;/th&gt;    ...  &lt;/table&gt; </code></pre><h3 id="URL表达式"><a href="#URL表达式" class="headerlink" title="URL表达式"></a>URL表达式</h3><p>URL表达式指的是把一个有用的上下文或回话信息添加到URL，这个过程经常被叫做URL重写。<br>@{/order/list}</p><p>URL还可以设置参数：<br>@{/order/details(id=${orderId})}</p><p>相对路径：<br>@{../documents/report}</p><p>让我们看这些表达式：</p><pre><code>&lt;form th:action=&quot;@{/createOrder}&quot;&gt;  &lt;a href=&quot;main.html&quot; th:href=&quot;@{/main}&quot;&gt;</code></pre><p>变量表达式和星号表达有什么区别吗？</p><p>如果不考虑上下文的情况下，两者没有区别；星号语法评估在选定对象上表达，而不是整个上下文<br>什么是选定对象？就是父标签的值，如下：（相当于星号表达式会去全局中找这个属性，如果找不到则默认不显示）</p><pre><code>&lt;div th:object=&quot;${session.user}&quot;&gt;   &lt;p&gt;Name: &lt;span th:text=&quot;*{firstName}&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;   &lt;p&gt;Surname: &lt;span th:text=&quot;*{lastName}&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;   &lt;p&gt;Nationality: &lt;span th:text=&quot;*{nationality}&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt;</code></pre><p>完全等价于</p><pre><code>&lt;div th:object=&quot;${session.user}&quot;&gt;     &lt;p&gt;Name: &lt;span th:text=&quot;${session.user.firstName}&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;     &lt;p&gt;Surname: &lt;span th:text=&quot;${session.user.lastName}&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;     &lt;p&gt;Nationality: &lt;span th:text=&quot;${session.user.nationality}&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt;</code></pre><p>当然，美元符号和星号语法可以混合使用：</p><pre><code>&lt;div th:object=&quot;${session.user}&quot;&gt;      &lt;p&gt;Name: &lt;span th:text=&quot;*{firstName}&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;      &lt;p&gt;Surname: &lt;span th:text=&quot;${session.user.lastName}&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;      &lt;p&gt;Nationality: &lt;span th:text=&quot;*{nationality}&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt;</code></pre><h2 id="表达式支持的语法"><a href="#表达式支持的语法" class="headerlink" title="表达式支持的语法"></a>表达式支持的语法</h2><ul><li>字面（Literals）</li></ul><p>文本文字（Text literals）: ‘one text’, ‘Another one!’,…<br>数字文本（Number literals）: 0, 34, 3.0, 12.3,…<br>布尔文本（Boolean literals）: true, false<br>空（Null literal）: null<br>文字标记（Literal tokens）: one, sometext, main,…</p><ul><li>文本操作（Text operations）</li></ul><p>字符串连接(String concatenation): +<br>文本替换（Literal substitutions）: |The name is ${name}|</p><ul><li>算术运算（Arithmetic operations）</li></ul><p>二元运算符（Binary operators）: +, -, *, /, %<br>减号（单目运算符）Minus sign (unary operator): -</p><ul><li>布尔操作（Boolean operations）</li></ul><p>二元运算符（Binary operators）:and, or<br>布尔否定（一元运算符）Boolean negation (unary operator):!, not</p><ul><li>比较和等价(Comparisons and equality)</li></ul><p>比较（Comparators）: &gt;, &lt;, &gt;=, &lt;= (gt, lt, ge, le)<br>等值运算符（Equality operators）:==, != (eq, ne)</p><ul><li>条件运算符（Conditional operators）</li></ul><p>If-then: (if) ? (then)<br>If-then-else: (if) ? (then) : (else)<br>Default: (value) ?: (defaultvalue)</p><p>所有这些特征可以被组合并嵌套：</p><pre><code>&apos;User is of type &apos; + (${user.isAdmin()} ? &apos;Administrator&apos; : (${user.type} ?: &apos;Unknown&apos;))</code></pre><h2 id="常用th标签都有那些？"><a href="#常用th标签都有那些？" class="headerlink" title="常用th标签都有那些？"></a>常用th标签都有那些？</h2><p><img src="/2018/03/24/springboot03/p1.png" alt="logo"><br><img src="/2018/03/24/springboot03/p2.png" alt="logo"><br><img src="/2018/03/24/springboot03/p3.png" alt="logo"></p><h2 id="几种常用的使用方法"><a href="#几种常用的使用方法" class="headerlink" title="几种常用的使用方法"></a>几种常用的使用方法</h2><p>几种Thymeleaf在实际开发中的应用（需要掌握的）</p><ul><li><p>赋值、字符串拼接</p><p>  </p><p th:text="${collect.description}">description</p><br>  <span th:text="'Welcome to our application, ' + ${user.name} + '!'"><p></p></span></li></ul><p>注意：th:text=””,双引号里面才是正确输出的内容，拼接的字符串要用‘’单引号，<br>也有更加简易的拼接字符串的方法，用||符号</p><pre><code>&lt;h1 th:text=&quot;|hello,*{hello}|&quot;&gt;Hello World&lt;/h1&gt;</code></pre><ul><li>条件判断 If/Unless</li></ul><p>Thymeleaf中使用th:if和th:unless属性进行条件判断，下面的例子中，<a>标签只有在th:if中条件成立时才显示：</a></p><pre><code>&lt;a th:if=&quot;${myself==&apos;yes&apos;}&quot; &gt;&lt;/a&gt;&lt;a th:unless=${session.user != null} th:href=&quot;@{/login}&quot; &gt;Login&lt;/a&gt;</code></pre><p>th:unless于th:if恰好相反，只有表达式中的条件不成立，才会显示其内容。</p><p>也可以使用 (if) ? (then) : (else) 这种语法来判断显示的内容</p><ul><li><p>for 循环</p><pre><code>&lt;tr  th:each=&quot;collect,iterStat : ${collects}&quot;&gt;    &lt;th scope=&quot;row&quot; th:text=&quot;${collect.id}&quot;&gt;1&lt;/th&gt;   &lt;td &gt;      &lt;img th:src=&quot;${collect.webLogo}&quot;/&gt;   &lt;/td&gt;   &lt;td th:text=&quot;${collect.url}&quot;&gt;Mark&lt;/td&gt;   &lt;td th:text=&quot;${collect.title}&quot;&gt;Otto&lt;/td&gt;   &lt;td th:text=&quot;${collect.description}&quot;&gt;@mdo&lt;/td&gt;   &lt;td th:text=&quot;${terStat.index}&quot;&gt;index&lt;/td&gt;&lt;/tr&gt;</code></pre></li></ul><p>iterStat称作状态变量，属性有：</p><p>index:当前迭代对象的index（从0开始计算）<br>count: 当前迭代对象的index(从1开始计算)<br>size:被迭代对象的大小<br>current:当前迭代变量<br>even/odd:布尔值，当前循环是否是偶数/奇数（从0开始计算）<br>first:布尔值，当前循环是否是第一个<br>last:布尔值，当前循环是否是最后一个</p><ul><li>URL</li></ul><p>URL在Web应用模板中占据着十分重要的地位，需要特别注意的是Thymeleaf对于URL的处理是通过语法@{…}来处理的。<br>如果需要Thymeleaf对URL进行渲染，那么务必使用th:href，th:src等属性，下面是一个例子</p><pre><code>&lt;!-- Will produce &apos;http://localhost:8080/standard/unread&apos; (plus rewriting) --&gt; &lt;a  th:href=&quot;@{/standard/{type}(type=${type})}&quot;&gt;view&lt;/a&gt;&lt;!-- Will produce &apos;/gtvg/order/3/details&apos; (plus rewriting) --&gt;&lt;a href=&quot;details.html&quot; th:href=&quot;@{/order/{orderId}/details(orderId=${o.id})}&quot;&gt;view&lt;/a&gt;</code></pre><p>设置背景</p><pre><code>&lt;div th:style=&quot;&apos;background:url(&apos; + @{/&lt;path-to-image&gt;} + &apos;);&apos;&quot;&gt;&lt;/div&gt;</code></pre><p>根据属性值改变背景</p><pre><code>&lt;div class=&quot;media-object resource-card-image&quot;  th:style=&quot;&apos;background:url(&apos; + @{(${collect.webLogo}==&apos;&apos; ? &apos;img/favicon.png&apos; : ${collect.webLogo})} + &apos;)&apos;&quot; &gt;&lt;/div&gt;</code></pre><p>几点说明：</p><p>上例中URL最后的(orderId=${o.id}) 表示将括号内的内容作为URL参数处理，该语法避免使用字符串拼接，大大提高了可读性<br>@{…}表达式中可以通过{orderId}访问Context中的orderId变量<br>@{/order}是Context相关的相对路径，在渲染时会自动添加上当前Web应用的Context名字，假设context名字为app，那么结果应该是/app/order</p><ul><li>内联js</li></ul><p>内联文本：[[…]]内联文本的表示方式，使用时，必须先用th:inline=”text/javascript/none”激活，th:inline可以在父级标签内使用，甚至作为body的标签。内联文本尽管比th:text的代码少，不利于原型显示。</p><pre><code>&lt;script th:inline=&quot;javascript&quot;&gt;/*&lt;![CDATA[*/...var username = /*[[${sesion.user.name}]]*/ &apos;Sebastian&apos;;var size = /*[[${size}]]*/ 0;.../*]]&gt;*/&lt;/script&gt;</code></pre><p>js附加代码：</p><pre><code>/*[+var msg = &apos;This is a working application&apos;; +]*/</code></pre><p>js移除代码：</p><pre><code>/*[- */var msg = &apos;This is a non-working template&apos;;/* -]*/</code></pre><ul><li>内嵌变量</li></ul><p>为了模板更加易用，Thymeleaf还提供了一系列Utility对象（内置于Context中），可以通过#直接访问：</p><p>dates ： java.util.Date的功能方法类。<br>calendars : 类似#dates，面向java.util.Calendar<br>numbers : 格式化数字的功能方法类<br>strings : 字符串对象的功能类，contains,startWiths,prepending/appending等等。<br>objects: 对objects的功能类操作。<br>bools: 对布尔值求值的功能方法。<br>arrays：对数组的功能类方法。<br>lists: 对lists功能类方法<br>sets<br>maps<br>…<br>下面用一段代码来举例一些常用的方法：</p><p>1.dates</p><pre><code>/* * Format date with the specified pattern * Also works with arrays, lists or sets */${#dates.format(date, &apos;dd/MMM/yyyy HH:mm&apos;)}${#dates.arrayFormat(datesArray, &apos;dd/MMM/yyyy HH:mm&apos;)}${#dates.listFormat(datesList, &apos;dd/MMM/yyyy HH:mm&apos;)}${#dates.setFormat(datesSet, &apos;dd/MMM/yyyy HH:mm&apos;)}/* * Create a date (java.util.Date) object for the current date and time */${#dates.createNow()}/* * Create a date (java.util.Date) object for the current date (time set to 00:00) */${#dates.createToday()}</code></pre><p>2.strings</p><pre><code>/* * Check whether a String is empty (or null). Performs a trim() operation before check * Also works with arrays, lists or sets */${#strings.isEmpty(name)}${#strings.arrayIsEmpty(nameArr)}${#strings.listIsEmpty(nameList)}${#strings.setIsEmpty(nameSet)}/* * Check whether a String starts or ends with a fragment * Also works with arrays, lists or sets */${#strings.startsWith(name,&apos;Don&apos;)}                  // also array*, list* and set*${#strings.endsWith(name,endingFragment)}           // also array*, list* and set*/* * Compute length * Also works with arrays, lists or sets */${#strings.length(str)}/* * Null-safe comparison and concatenation */${#strings.equals(str)}${#strings.equalsIgnoreCase(str)}${#strings.concat(str)}${#strings.concatReplaceNulls(str)}/* * Random */${#strings.randomAlphanumeric(count)}</code></pre><ul><li>使用thymeleaf布局</li></ul><p>使用thymeleaf布局非常的方便</p><p>定义代码片段</p><pre><code>&lt;footer th:fragment=&quot;copy&quot;&gt; &amp;copy; 2016&lt;/footer&gt;</code></pre><p>在页面任何地方引入：</p><pre><code>&lt;body&gt;   &lt;div th:include=&quot;footer :: copy&quot;&gt;&lt;/div&gt;  &lt;div th:replace=&quot;footer :: copy&quot;&gt;&lt;/div&gt; &lt;/body&gt;‘</code></pre><p>th:include 和 th:replace区别，include只是加载，replace是替换</p><p>返回的HTML如下：</p><pre><code>&lt;body&gt;    &lt;div&gt; &amp;copy; 2016 &lt;/div&gt;   &lt;footer&gt;&amp;copy; 2016 &lt;/footer&gt; &lt;/body&gt;</code></pre><p>下面是一个常用的后台页面布局，将整个页面分为头部，尾部、菜单栏、隐藏栏，点击菜单只改变content区域的页面</p><pre><code>&lt;body class=&quot;layout-fixed&quot;&gt;  &lt;div th:fragment=&quot;navbar&quot;  class=&quot;wrapper&quot;  role=&quot;navigation&quot;&gt;    &lt;div th:replace=&quot;fragments/header :: header&quot;&gt;Header&lt;/div&gt;    &lt;div th:replace=&quot;fragments/left :: left&quot;&gt;left&lt;/div&gt;    &lt;div th:replace=&quot;fragments/sidebar :: sidebar&quot;&gt;sidebar&lt;/div&gt;    &lt;div layout:fragment=&quot;content&quot; id=&quot;content&quot; &gt;&lt;/div&gt;    &lt;div th:replace=&quot;fragments/footer :: footer&quot;&gt;footer&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;</code></pre><p>任何页面想使用这样的布局值只需要替换中见的 content模块即可</p><pre><code>&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot; layout:decorator=&quot;layout&quot;&gt;  &lt;body&gt;     &lt;section layout:fragment=&quot;content&quot;&gt;   ...</code></pre><p>也可以在引用模版的时候传参</p><pre><code>&lt;head th:include=&quot;layout :: htmlhead&quot; th:with=&quot;title=&apos;Hello&apos;&quot;&gt;&lt;/head&gt;</code></pre><p>layout 是文件地址，如果有文件夹可以这样写 fileName/layout:htmlhead<br>htmlhead 是指定义的代码片段 如 th:fragment=”copy”</p><p>开源云收藏项目的github源码：<a href="https://github.com/cloudfavorites/favorites-web" target="_blank" rel="noopener">https://github.com/cloudfavorites/favorites-web</a><br>里面用的技术包括springboot集成了tomcat和thymeleaf，源码测试里都是详细的项目功能介绍。</p><p>还有就是Springboot虽然不建议使用JSP技术，但是若有相应的要求也可以使用。具体自查。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Thymeleaf&quot;&gt;&lt;a href=&quot;#Thymeleaf&quot; class=&quot;headerlink&quot; title=&quot;Thymeleaf&quot;&gt;&lt;/a&gt;Thymeleaf&lt;/h1&gt;&lt;p&gt;在实际的公司开发中，传统的JSP技术由于前段后端结合太过紧密，而且后端人员需要随时测试数据能不能渲染在界面上，这就需要前端与后端部门过于紧耦合，不利于实际开发，反而是模板引擎用的较多（当然也不排除一些老的公司需要维护公司以前的动态JSP网页）&lt;/p&gt;
&lt;p&gt;thymeleaf最大的优势后缀为html,就是只需要浏览器就可以展现页面了,还有就是thymeleaf可以很好的和spring集成.&lt;/p&gt;
&lt;p&gt;Thymeleaf是一个XML/XHTML/HTML5模板引擎，可用于Web与非Web环境中的应用开发。它是一个开源的Java库，基于Apache License 2.0许可，由Daniel Fernández创建，该作者还是Java加密库Jasypt的作者。&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://yoursite.com/categories/springboot/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
      <category term="springboot" scheme="http://yoursite.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot之路(二)--Nosql支持</title>
    <link href="http://yoursite.com/2018/03/23/springboot02/"/>
    <id>http://yoursite.com/2018/03/23/springboot02/</id>
    <published>2018-03-23T08:49:42.000Z</published>
    <updated>2018-03-23T18:25:07.681Z</updated>
    
    <content type="html"><![CDATA[<p>在SpringBoot中对常用的数据库支持外，对nosql 数据库也进行了封装自动化。</p><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。<br>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。<br>它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><a id="more"></a><p>Redis学习手册：<a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/redis/redis-tutorial.html</a></p><p>Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。<br>Redis 与其他 key - value 缓存产品有以下三个特点：</p><p>1.Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。<br>2.Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。<br>3.Redis支持数据的备份，即master-slave模式的数据备份。</p><p>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。<br>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。<br>原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。<br>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</p><p>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。<br>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</p><h2 id="什么是BSD协议？"><a href="#什么是BSD协议？" class="headerlink" title="什么是BSD协议？"></a>什么是BSD协议？</h2><p>BSD开源协议是一个给于使用者很大自由的协议。可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。当你发布使用了BSD协议的代码，或者以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：<br>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。<br>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。<br>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。<br>BSD代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销 售，因此是对商业集成很友好的协议。<br>很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者 二次开发。</p><h2 id="安装及使用"><a href="#安装及使用" class="headerlink" title="安装及使用"></a>安装及使用</h2><p>Windows下的安装教程：</p><p>下载地址（已在Github上开源）：<a href="https://github.com/MSOpenTech/redis/releases" target="_blank" rel="noopener">https://github.com/MSOpenTech/redis/releases</a></p><p>Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，这里我们下载 Redis-x64-xxx.zip压缩包到 F 盘，解压后，将文件夹重新命名为 redis。</p><p>打开一个 cmd 窗口 使用cd命令切换目录到 C:\redis 运行 redis-server.exe redis.windows.conf 。<br>如果想方便的话，可以把 redis 的路径加到系统的环境变量里，这样就省得再输路径了，后面的那个 redis.windows.conf 可以省略，如果省略，会启用默认的。输入之后，会显示如下界面：</p><p><img src="/2018/03/23/springboot02/redis-install1.png" alt="logo"></p><p>这时候另启一个cmd窗口，原来的不要关闭，不然就无法访问服务端了。<br>切换到redis目录下运行 redis-cli.exe -h 127.0.0.1 -p 6379 。<br>设置键值对 set myKey abc<br>取出键值对 get myKey</p><p><img src="/2018/03/23/springboot02/redis-install2.png" alt="logo"></p><p>Redis是目前业界使用最广泛的内存数据存储。相比memcached，Redis支持更丰富的数据结构，例如hashes, lists, sets等，同时支持数据持久化。除此之外，Redis还提供一些类数据库的特性，比如事务，HA，主从库。可以说Redis兼具了缓存系统和数据库的一些特性，因此有着丰富的应用场景。本文介绍Redis在Spring Boot中两个典型的应用场景。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>1、引入 spring-boot-starter-redis</p><pre><code>&lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;  &lt;/dependency&gt;</code></pre><p>2、添加配置文件</p><p>编辑配置<br>你可以通过修改 redis.conf 文件或使用 CONFIG set 命令来修改配置。</p><p>CONFIG SET 命令基本语法：<br>redis 127.0.0.1:6379&gt; CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE</p><p>通过修改application.properties中配置Redis连接信息文件修改如下：</p><ul><li>REDIS (RedisProperties)</li><li>Redis数据库索引（默认为0）<br>spring.redis.database=0  </li><li>Redis服务器地址<br>spring.redis.host=192.168.0.58</li><li>Redis服务器连接端口<br>spring.redis.port=6379  </li><li>Redis服务器连接密码（默认为空）<br>spring.redis.password=  </li><li>连接池最大连接数（使用负值表示没有限制）<br>spring.redis.pool.max-active=8  </li><li>连接池最大阻塞等待时间（使用负值表示没有限制）<br>spring.redis.pool.max-wait=-1  </li><li>连接池中的最大空闲连接<br>spring.redis.pool.max-idle=8  </li><li>连接池中的最小空闲连接<br>spring.redis.pool.min-idle=0  </li><li>连接超时时间（毫秒）<br>spring.redis.timeout=0  </li></ul><p>3、修改项目启动类</p><p>增加注解@EnableCaching，开启缓存功能，如下：</p><pre><code>package springboot;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cache.annotation.EnableCaching;import org.springframework.scheduling.annotation.EnableScheduling;@SpringBootApplication@EnableScheduling@EnableCachingpublic class SpringbootApplication{    public static void main(String[] args) {        SpringApplication.run(SpringbootApplication.class, args);    }}</code></pre><p>4、新建Redis缓存配置类RedisConfig，如下：</p><pre><code>package springboot.config;import org.springframework.beans.factory.annotation.Value;import org.springframework.cache.CacheManager;import org.springframework.cache.annotation.CachingConfigurerSupport;import org.springframework.cache.annotation.EnableCaching;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.cache.RedisCacheManager;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;/** * Redis缓存配置类 * @author szekinwin * */@Configuration@EnableCachingpublic class RedisConfig extends CachingConfigurerSupport{    @Value(&quot;${spring.redis.host}&quot;)    private String host;    @Value(&quot;${spring.redis.port}&quot;)    private int port;    @Value(&quot;${spring.redis.timeout}&quot;)    private int timeout;    //自定义缓存key生成策略//    @Bean//    public KeyGenerator keyGenerator() {//        return new KeyGenerator(){//            @Override//            public Object generate(Object target, java.lang.reflect.Method method, Object... params) {//                StringBuffer sb = new StringBuffer();//                sb.append(target.getClass().getName());//                sb.append(method.getName());//                for(Object obj:params){//                    sb.append(obj.toString());//                }//                return sb.toString();//            }//        };//    }    //缓存管理器    @Bean     public CacheManager cacheManager(@SuppressWarnings(&quot;rawtypes&quot;) RedisTemplate redisTemplate) {        RedisCacheManager cacheManager = new RedisCacheManager(redisTemplate);        //设置缓存过期时间         cacheManager.setDefaultExpiration(10000);        return cacheManager;    }    @Bean    public RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory factory){        StringRedisTemplate template = new StringRedisTemplate(factory);        setSerializer(template);//设置序列化工具        template.afterPropertiesSet();        return template;    }     private void setSerializer(StringRedisTemplate template){            @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })            Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);            ObjectMapper om = new ObjectMapper();            om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);            om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);            jackson2JsonRedisSerializer.setObjectMapper(om);            template.setValueSerializer(jackson2JsonRedisSerializer);     }}</code></pre><p>5、新建UserMapper</p><pre><code>package springboot.dao;import org.apache.ibatis.annotations.Delete;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Param;import org.apache.ibatis.annotations.Select;import org.apache.ibatis.annotations.Update;import org.springframework.cache.annotation.CacheConfig;import org.springframework.cache.annotation.CacheEvict;import org.springframework.cache.annotation.CachePut;import org.springframework.cache.annotation.Cacheable;import springboot.domain.User;@Mapper@CacheConfig(cacheNames = &quot;users&quot;)public interface UserMapper {    @Insert(&quot;insert into user(name,age) values(#{name},#{age})&quot;)    int addUser(@Param(&quot;name&quot;)String name,@Param(&quot;age&quot;)String age);    @Select(&quot;select * from user where id =#{id}&quot;)    @Cacheable(key =&quot;#p0&quot;)     User findById(@Param(&quot;id&quot;) String id);    @CachePut(key = &quot;#p0&quot;)    @Update(&quot;update user set name=#{name} where id=#{id}&quot;)    void updataById(@Param(&quot;id&quot;)String id,@Param(&quot;name&quot;)String name);    //如果指定为 true，则方法调用后将立即清空所有缓存    @CacheEvict(key =&quot;#p0&quot;,allEntries=true)    @Delete(&quot;delete from user where id=#{id}&quot;)    void deleteById(@Param(&quot;id&quot;)String id);}</code></pre><p>@Cacheable将查询结果缓存到redis中，（key=”#p0”）指定传入的第一个参数作为redis的key。</p><p>@CachePut，指定key，将更新的结果同步到redis中</p><p>@CacheEvict，指定key，删除缓存数据，allEntries=true,方法调用后将立即清除缓存</p><h2 id="共享Session-spring-session-data-redis"><a href="#共享Session-spring-session-data-redis" class="headerlink" title="共享Session-spring-session-data-redis"></a>共享Session-spring-session-data-redis</h2><p>分布式系统中，sessiong共享有很多的解决方案，其中托管到缓存中应该是最常用的方案之一，</p><p>多台分布式机器共享Session的解决方案</p><h3 id="如何使用-1"><a href="#如何使用-1" class="headerlink" title="如何使用"></a>如何使用</h3><ul><li><p>引入依赖</p>  <dependency><br>      <groupid>org.springframework.session</groupid><br>      <artifactid>spring-session-data-redis</artifactid><br>  </dependency>　</li><li><p>Session配置</p><p>  @Configuration<br>  @EnableRedisHttpSession(maxInactiveIntervalInSeconds = 86400*30)<br>  public class SessionConfig {<br>  }</p></li></ul><p>maxInactiveIntervalInSeconds: 设置Session失效时间，使用Redis Session之后，原Boot的server.session.timeout属性不再生效</p><ul><li>测试</li></ul><p>添加测试方法获取sessionid</p><pre><code>@RequestMapping(&quot;/uid&quot;)String uid(HttpSession session) {    UUID uid = (UUID) session.getAttribute(&quot;uid&quot;);    if (uid == null) {        uid = UUID.randomUUID();    }    session.setAttribute(&quot;uid&quot;, uid);    return session.getId();}</code></pre><p>登录redis 输入 keys ‘<em>sessions</em>‘ xml t&lt;spring:session:sessions:db031986-8ecc-48d6-b471-b137a3ed6bc4 t(spring:session:expirations:1472976480000  其中 1472976480000为失效时间，意思是这个时间后session失效，db031986-8ecc-48d6-b471-b137a3ed6bc4 为sessionId,登录<a href="http://localhost:8080/uid" target="_blank" rel="noopener">http://localhost:8080/uid</a> 发现会一致，就说明session 已经在redis里面进行有效的管理了。<br>这条session作为数据储存在Redis数据库中。</p><h3 id="如何在两台或者多台中共享session"><a href="#如何在两台或者多台中共享session" class="headerlink" title="如何在两台或者多台中共享session"></a>如何在两台或者多台中共享session</h3><p>其实就是按照上面的步骤在另一个项目中再次配置一次，启动后自动就进行了session共享。</p><p>多台机器可以共享这个Redis数据库，里面自然有Session数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在SpringBoot中对常用的数据库支持外，对nosql 数据库也进行了封装自动化。&lt;/p&gt;
&lt;h1 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。&lt;br&gt;Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。&lt;br&gt;它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://yoursite.com/categories/springboot/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
      <category term="springboot" scheme="http://yoursite.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot之路(一)--概念介绍及注解配置</title>
    <link href="http://yoursite.com/2018/03/22/springboot/"/>
    <id>http://yoursite.com/2018/03/22/springboot/</id>
    <published>2018-03-22T06:13:19.000Z</published>
    <updated>2018-03-23T18:25:07.680Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。也被称为spring的脚手架。<br>该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。</p><p>spring boot 致力于简洁，让开发者写更少的配置，程序能够更快的运行和启动。它是下一代javaweb框架，并且它是spring cloud（微服务）的基础。(spring cloud的基础就是基于spring boot来进行配置)，spring boot就是为了让开发人员从繁重的配置工作解放出来，快速参与开发。</p><ol><li>创建独立的Spring应用程序</li><li>嵌入的Tomcat，无需部署WAR文件</li><li>简化Maven配置</li><li>自动配置Spring</li><li>提供生产就绪型功能，如指标，健康检查和外部配置</li><li>绝对没有代码生成和对XML没有要求配置（由java配置替代XML配置，也就是零XML配置）</li></ol><a id="more"></a><p>从最根本上来讲，Spring Boot就是一些库的集合，它能够被任意项目的构建系统所使用。简便起见，该框架也提供了命令行界面，它可以用来运行和测试Boot应用。框架的发布版本，包括集成的CLI（命令行界面），可以在Spring仓库中手动下载和安装。一种更为简便的方式是使用Groovy环境管理器（Groovy enVironment Manager，GVM），它会处理Boot版本的安装和管理。Boot及其CLI可以通过GVM的命令行gvm install springboot进行安装。</p><p>要进行打包和分发的工程会依赖于像Maven或Gradle这样的构建系统。为了简化依赖图，Boot的功能是模块化的，通过导入Boot所谓的“starter”模块，可以将许多的依赖添加到工程之中。为了更容易地管理依赖版本和使用默认配置，框架提供了一个parent POM，工程可以继承它。</p><h1 id="如何spring-boot快速开发"><a href="#如何spring-boot快速开发" class="headerlink" title="如何spring boot快速开发"></a>如何spring boot快速开发</h1><p>如何进行spring boot的快速开发和学习，以便于熟悉这个框架所带来的方便。<br>最好的办法就是在项目中去参与开发，体验会所带来的FEEL！！</p><p>首先我们需要一个项目以方便我们了解利用spirng boot框架的项目里面到底有什么？</p><h2 id="Test项目下载"><a href="#Test项目下载" class="headerlink" title="Test项目下载"></a>Test项目下载</h2><p>spring官网为我们提供了可方便快速上手体验的Test项目<br><a href="http://start.spring.io/" target="_blank" rel="noopener">http://start.spring.io/</a></p><p>在里面根据自己的选择JDK的版本，项目名和包名等等，点击下方的Switch to the full version可以选择java的版本（还可以引入所依赖的组件，这里我们先下载默认的项目，若是以后有需要的jar包再通过maven导入即可）</p><p>我的选择界面如下：</p><p><img src="/2018/03/22/springboot/p1.png" alt="logo"></p><p>选择好后然后点击Generate Project下载项目压缩包</p><p>解压后，使用eclipse，Import -&gt; Existing Maven Projects -&gt; Next -&gt;选择解压后的文件夹-&gt; Finsh，OK done!</p><h2 id="项目目录结构分析"><a href="#项目目录结构分析" class="headerlink" title="项目目录结构分析"></a>项目目录结构分析</h2><p><img src="/2018/03/22/springboot/p2.png" alt="logo"></p><p>可以看到Spring Boot的基础结构共三个文件</p><p>src/main/java  程序开发以及主程序入口<br>src/main/resources 配置文件<br>src/test/java  测试程序</p><p>这里跟我们平时在eclipse中建立的maven项目目录结构一致</p><p>spingboot建议的目录结果如下（根据你的公司的开发格式要求为重）：</p><p>root package结构：com.example.myproject</p><pre><code>com  +- example    +- myproject      +- Application.java      |      +- domain      |  +- Customer.java      |  +- CustomerRepository.java      |      +- service      |  +- CustomerService.java      |      +- controller      |  +- CustomerController.java      |</code></pre><p>其实也就是分包，按照以往的springmvc的开发模式，Entity中方实体类，也就是数据库与服务端的字段映射POJO，Controller中放控制层（负责页面访问控制），Service中负责处理相关业务逻辑，Dao层负责处理数据库交互，Util负责放入一些工具类，aspect为切面组件，converter为消息转化组件等等。</p><p>而spring boot中建议以java配置取代繁重的XML配置（或者用更简化的Groovy来代替），这个项目用java配置演示。</p><p>1、Application.java  建议放到跟目录下面,主要用于做一些框架配置（java配置文件）</p><p>2、domain  目录主要用于实体（Entity）与数据访问层（Repository）</p><p>3、service  层主要是业务类代码</p><p>4、controller  负责页面访问控制</p><p>采用默认配置可以省去很多配置，当然也可以根据自己的喜欢来进行更改</p><p>最后，启动Application main方法，至此一个java项目搭建好了！</p><h2 id="项目POM-XML"><a href="#项目POM-XML" class="headerlink" title="项目POM.XML"></a>项目POM.XML</h2><p>在项目的POM.xml文件中引入父POM，来初始化一些常用的功能（不用重新去导入其他包，当然也有办法不用这个父POM），项目自动配好了，若是自己编写项目则需要手动配置。</p><pre><code>&lt;!-- Inherit defaults from Spring Boot --&gt;&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;1.5.2.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;    &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;!-- spring-boot-maven-plugin插件 在SpringBoot项目中开启的方式有两种  一种是run java.application 还有一种就是这个插件开启--&gt;&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;&lt;!--支持springboot所需的jar包依赖&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>以上这些就是官网提供项目的POM配置。</p><p>还需要引入一个web模块</p><pre><code>&lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>pom.xml文件中默认有两个模块：</p><p>spring-boot-starter：核心模块，包括自动配置支持、日志和YAML；</p><p>spring-boot-starter-test：测试模块，包括JUnit、Hamcrest、Mockito。</p><p>测试一下页面访问的Controller看看效果</p><pre><code>package com.example.springboot.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;//springboot特有注解，包含@Controller和@ResponseBody//所以这里就相当于控制层组件和输出Json格式字符串，极其方便@RestControllerpublic class HelloController {  @RequestMapping(&quot;/hel&quot;)  public String index(){    return &quot;Hello World&quot;;  }  //测试成功！}</code></pre><p>注意：本机的tomcat端口若是自己设置的，需要在application.properties中去设置端口号，否则将访问不到。</p><p>我的设置是：server.port=8088</p><p>配置完后直接测试 <a href="http://localhost:8088/hel" target="_blank" rel="noopener">http://localhost:8088/hel</a></p><p>出现结果</p><p><img src="/2018/03/22/springboot/p3.png" alt="logo"></p><p>@RestController的意思就是controller里面的方法都以json格式输出，不用再写什么jackjson配置的了！<br>跟我们之前所使用的@ResponseBody一样，向浏览器直接输出Json格式的数据</p><p>当然在这里我贴出一些可能出现问题的解法包括我自己是怎么解决的</p><h2 id="出现的问题及解决方案"><a href="#出现的问题及解决方案" class="headerlink" title="出现的问题及解决方案"></a>出现的问题及解决方案</h2><p>当我们部署完后可以直接run运行这个Test项目看下是否输入路径能否得到这个json字符串<br>这时候可能会出现Whitelabel Error Page的提示，这时候表示这个项目并没运行成功<br>我去网上找找方法，常见的解决方法是去看看SpringbootApplication.java这个类是否放在项目根目录下（目录结构不对的问题）<br>因为springboot是默认加载这个配置文件下的所有子包，我查看了一下我的包结构</p><p><img src="/2018/03/22/springboot/p4.png" alt="logo"><br>发现并没有问题，SpringbootApplication.java配置也放在根目录下了，controller是其子包没错。</p><p>后来发现是springboot项目在运行的时候，eclipse需要你去手动配置springboot的项目以及执行配置的main方法所在类<br>这时候我们可以在所运行的项目下右键–&gt;run Configuations，然后在Main标签上的project中选择你所要执行的springboot项目<br>Main Class位置选择执行配置的main方法所在类，这时候重新运行就生效了，这是因为我之前也有用过springboot框架建了一个项目，这时候以为内原来的配置是上一个项目的，这时候需要我们手动去将项目重新设置。</p><p>另外这是我的解决方法，每个人都可能遇到不同的问题，所以这就是需要我们要去融入问题本身，再加上eclipse的debug模式去发现系统报给我们的错误的真正原因。</p><h2 id="如何做单元测试"><a href="#如何做单元测试" class="headerlink" title="如何做单元测试"></a>如何做单元测试</h2><p>利用我们刚刚做的这个Test类，我们要做个单元测试，将服务端和浏览器的交互数据都给打印出来，包括Springmvc各组件的数据交互。<br>打开的src/test/下的测试入口，编写简单的http请求来测试；使用mockmvc进行，利用MockMvcResultHandlers.print()打印出执行结果。</p><p>注意：@SpringApplicationConfiguration(classes = Application.class) 报错，注解不能导入。</p><pre><code>//springJunit支持，由于引入了Spring-Test框架支持。@RunWith(SpringJUnit4ClassRunner.class)//这个注解在1.5版本后移除了，所以用两个注解就可以实现测试，//@SpringApplicationConfiguration(classes = MockServletContext.class)//由于是web项目，Junit需要模拟ServletContext，需要给测试类加上@WebAppConfiguration注解@WebAppConfigurationpublic class HelloWorldControlerTests {     private MockMvc mvc;        @Before        public void setUp() throws Exception {            mvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();        }        @Test        public void getHello() throws Exception {        mvc.perform(MockMvcRequestBuilders.get(&quot;/hel&quot;).accept(MediaType.APPLICATION_JSON))                    .andExpect(MockMvcResultMatchers.status().isOk())                    .andDo(MockMvcResultHandlers.print())                    .andReturn();        }}</code></pre><p>热启动在正常开发项目中已经很常见了吧，虽然平时开发web项目过程中，改动项目启重启总是报错；但springBoot对调试支持很好，修改之后可以实时生效，需要添加以下的配置：</p><pre><code>&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;   &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;configuration&gt;                &lt;fork&gt;true&lt;/fork&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;   &lt;/plugins&gt;&lt;/build&gt;</code></pre><p>该模块在完整的打包环境下运行的时候会被禁用。如果你使用java -jar启动应用或者用一个特定的classloader启动，它会认为这是一个“生产环境”。</p><h2 id="关于Eclipse的热启动及热部署"><a href="#关于Eclipse的热启动及热部署" class="headerlink" title="关于Eclipse的热启动及热部署"></a>关于Eclipse的热启动及热部署</h2><p> Tomcat的热部署（以后就不用重启了）<br>1、 tomcat上的部署问题，有时候也是个麻烦的问题，要是不采用热部署，我们就只能每次对原来的文件做一次改动的时候就要重新部署，<br>而每次重新部署都要关闭tomcat，部署完重起tomcat，可见这是一个多么烦人的事情。现在，我们可以采用热部署了，以后，就不用做凡人的关闭重起工作。<br> 实现方式：<br>编辑Tomcat的server.xml<br>    <host name="localhost" debug="0" appbase="webapps" unpackwars="true" autodeploy="true" xmlvalidation="false" xmlnamespaceaware="false"></host></p><p>  在host节点内加入<br>    <!-- auto append ,then reload --><br>      <context path="/myapp" docbase="myapp" debug="99" reloadable="true"><br>“myapp” 为要部署的应用程序，通常在webapps目录下    <context>元素的属性:   path:指定访问该Web应用的URL入口。<br> docBase:指定Web应用的文件路径，可以给定绝对路径，也可以给定相对于 <host>的appBase属性的相对路径，<br>如果Web应用采用开放目录结构，则指定Web应用的根目录，如果Web应用是个war文件，则指定war文件的路径。<br> reloadable:如果这个属性设为true，tomcat服务器在运行状态下会监视在WEB-INF/classes和WEB-INF/lib目录下class文件的改动，<br>如果监测到有class文件被更新的，服务器会自动重新加载Web应用。    在开发阶段将reloadable属性设为true，<br>有助于调试servlet和其它的class文件，但这样用加重服务器运行负荷，建议在Web应用的发存阶段将reloadable设为false。</host></context></context></p><p>2、双击tomcat 服务器，切换到modules 界面，把项目的auto_reload 设置为Disabled 保存</p><p>这种方法只适用于改变类的方法实现，如果当一个类改变结构、或者配置文件修改了，tomcat是没办法热加载的，需要重启tomcat。<br>搞定！</p><p>使用spring boot可以非常方便、快速搭建项目，使我们不用关心框架之间的兼容性，适用版本等各种问题，我们想使用任何东西，仅仅添加一个配置就可以，所以使用sping boot非常适合构建微服务。</p><p>——————更新线——————</p><h1 id="关于SpringBootApplication的各项注解配置"><a href="#关于SpringBootApplication的各项注解配置" class="headerlink" title="关于SpringBootApplication的各项注解配置"></a>关于SpringBootApplication的各项注解配置</h1><p><img src="/2018/03/22/springboot/p5.png" alt="logo"></p><p>较为常用的注解有以下这些：</p><p>@SpringBootApplication:</p><p>包含@Configuration、@EnableAutoConfiguration、@ComponentScan<br>通常用在主类上。</p><p>@Repository:<br>用于标注数据访问组件，即DAO组件。</p><p>@Service:<br>用于标注业务层组件。 </p><p>@RestController:<br>4.0重要的一个新的改进是@RestController注解，它继承自@Controller注解。4.0之前的版本，Spring MVC的组件都使用@Controller来标识当前类是一个控制器servlet。使用这个特性，我们可以开发REST服务的时候不需要使用@Controller而专门的@RestController。<br>当你实现一个RESTful web services的时候，response将一直通过response body发送。为了简化开发，Spring 4.0提供了一个专门版本的controller。<br>用于标注控制层组件(如struts中的action)，包含@Controller和@ResponseBody。</p><p>@ResponseBody：<br>表示该方法的返回结果直接写入HTTP response body中<br>一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。</p><p>@Controller<br>如果我们需要使用页面开发只要使用 @Controller </p><p>@Component：<br>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p><p>@ComponentScan：<br>组件扫描。个人理解相当于<a href="context:component-scan" target="_blank" rel="noopener">context:component-scan</a>，如果扫描到有@Component @Controller @Service等这些注解的类，则把这些类注册为bean。</p><p>@Configuration：<br>指出该类是 Bean 配置的信息源，相当于XML中的<beans></beans>，一般加在主类上。</p><p>@Bean:<br>相当于XML中的<bean></bean>,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。</p><p>@EnableAutoConfiguration：<br>让 Spring Boot 根据应用所声明的依赖来对 Spring 框架进行自动配置，一般加在主类上。</p><p>@AutoWired:<br>byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。<br>当加上（required=false）时，就算找不到bean也不报错。</p><p>@Qualifier：<br>当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用</p><p>@Resource(name=”name”,type=”type”)：<br>没有括号内内容的话，默认byName。与@Autowired干类似的事。</p><p>@RequestMapping：<br>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。<br>该注解有六个属性：<br>params:指定request中必须包含某些参数值是，才让该方法处理。<br>headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。<br>value:指定请求的实际地址，指定的地址可以是URI Template 模式<br>method:指定请求的method类型， GET、POST、PUT、DELETE等<br>consumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html;<br>produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回</p><p>@RequestParam：<br>用在方法的参数前面。可以有效规避浏览器传参与服务端属性名字不一致的问题，最好每个参数前面都要加<br>@RequestParam String a =request.getParameter(“a”)。</p><p>@PathVariable:</p><p>路径变量。参数与大括号里的名字一样要相同。</p><pre><code>RequestMapping(&quot;user/get/mac/{macAddress}&quot;)public String getByMacAddress(@PathVariable String macAddress){　　//do something;}</code></pre><p>@Profiles<br>Spring Profiles提供了一种隔离应用程序配置的方式，并让这些配置只能在特定的环境下生效。<br>任何@Component或@Configuration都能被@Profile标记，从而限制加载它的时机。</p><pre><code>@Configuration@Profile(&quot;prod&quot;)public class ProductionConfiguration {    // ...}</code></pre><p>@ConfigurationProperties<br>Spring Boot将尝试校验外部的配置，默认使用JSR-303（如果在classpath路径中）。<br>你可以轻松的为你的@ConfigurationProperties类添加JSR-303 javax.validation约束注解：</p><pre><code>@Component@ConfigurationProperties(prefix=&quot;connection&quot;)public class ConnectionSettings {@NotNullprivate InetAddress remoteAddress;// ... getters and setters}</code></pre><p>全局异常处理</p><p>@ControllerAdvice：<br>包含@Component。可以被扫描到。<br>统一处理异常。</p><p>@ExceptionHandler（Exception.class）：<br>用在方法上面表示遇到这个异常就执行以下方法。</p><h2 id="自定义Filter"><a href="#自定义Filter" class="headerlink" title="自定义Filter"></a>自定义Filter</h2><p>我们常常在项目中会使用filters用于录调用日志、排除有XSS威胁的字符、执行权限验证等等。Spring Boot自动添加了OrderedCharacterEncodingFilter和HiddenHttpMethodFilter，并且我们可以自定义Filter。</p><p>两个步骤：</p><p>1.实现Filter接口，实现Filter方法<br>2.添加@Configuration 注解，将自定义Filter加入过滤链</p><pre><code>@Configurationpublic class WebConfiguration {    @Bean    public RemoteIpFilter remoteIpFilter() {        return new RemoteIpFilter();    }    @Bean    public FilterRegistrationBean testFilterRegistration() {        FilterRegistrationBean registration = new FilterRegistrationBean();        registration.setFilter(new MyFilter());        registration.addUrlPatterns(&quot;/*&quot;);        registration.addInitParameter(&quot;paramName&quot;, &quot;paramValue&quot;);        registration.setName(&quot;MyFilter&quot;);        registration.setOrder(1);        return registration;    }    public class MyFilter implements Filter {        @Override        public void destroy() {            // TODO Auto-generated method stub        }        @Override        public void doFilter(ServletRequest srequest, ServletResponse sresponse, FilterChain filterChain)                throws IOException, ServletException {            // TODO Auto-generated method stub            HttpServletRequest request = (HttpServletRequest) srequest;            System.out.println(&quot;this is MyFilter,url :&quot;+request.getRequestURI());            filterChain.doFilter(srequest, sresponse);        }        @Override        public void init(FilterConfig arg0) throws ServletException {            // TODO Auto-generated method stub        }    }}</code></pre><h2 id="自定义Property"><a href="#自定义Property" class="headerlink" title="自定义Property"></a>自定义Property</h2><p>在web开发的过程中，我经常需要自定义一些配置文件，如何使用呢</p><p>配置在application.properties中，例如：</p><pre><code>com.neo.title=路飞com.neo.description=海贼王@Component//配置好后，直接在类中用EL表达式引用即可，所有的参数配置都是写在这里，都是为了避免将程序写死public class NeoProperties {    @Value(&quot;${com.neo.title}&quot;)    private String title;    @Value(&quot;${com.neo.description}&quot;)    private String description;    //省略getter settet方法    }</code></pre><h2 id="log配置"><a href="#log配置" class="headerlink" title="log配置"></a>log配置</h2><p>配置输出的地址和输出级别，同样也是在application.properties里面设置参数即可</p><pre><code>logging.path=/user/local/loglogging.level.com.favorites=DEBUGlogging.level.org.springframework.web=INFOlogging.level.org.hibernate=ERROR</code></pre><p>path为本机的log地址，logging.level  后面可以根据包路径配置不同资源的log级别（关于等级说明在java常用类库–log日志 里面可以找到）</p><p>将日志输出到指定位置</p><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><p>重点讲述mysql、spring data jpa的使用，其中mysql 就不用说了大家很熟悉，jpa是利用Hibernate生成各种自动化的sql，如果只是简单的增删改查，基本上不用手写了，spring内部已经帮大家封装实现了。<br>实现了Mysql与Hibernate的结合，既可以自动生成sql语句简化开发，又可以利用mysql的快速方便不冗余的特点。</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>数据库及jpa配置文件（写在application.properties里）</p><pre><code>spring.datasource.url=jdbc:mysql://localhost:3306/testspring.datasource.username=rootspring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.jpa.properties.hibernate.hbm2ddl.auto=updatespring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialectspring.jpa.show-sql= true</code></pre><p>其实这个hibernate.hbm2ddl.auto参数的作用主要用于：自动创建|更新|验证数据库表结构,有四个值：</p><p>1.create： 每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。</p><p>2.create-drop ：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。</p><p>3.update：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据 model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等 应用第一次运行起来后才会。</p><p>4.validate ：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。</p><p>dialect 主要是指定生成表名的存储引擎为InneoDB<br>show-sql 是否打印出自动生产的SQL，方便调试的时候查看</p><p>添加实体类和Dao：</p><pre><code>@Entitypublic class User implements Serializable {    private static final long serialVersionUID = 1L;    @Id    @GeneratedValue    private Long id;    @Column(nullable = false, unique = true)    private String userName;    @Column(nullable = false)    private String passWord;    @Column(nullable = false, unique = true)    private String email;    @Column(nullable = true, unique = true)    private String nickName;    @Column(nullable = false)    private String regTime;    //省略getter settet方法、构造方法}</code></pre><p>关于@Column 注解详情</p><p>@Column标记表示所持久化属性所映射表中的字段，该注释的属性定义如下：</p><pre><code>@Target({METHOD, FIELD}) @Retention(RUNTIME)public @interface Column {    String name() default &quot;&quot;;    boolean unique() default false;    boolean nullable() default true;    boolean insertable() default true;    boolean updatable() default true;    String columnDefinition() default &quot;&quot;;    String table() default &quot;&quot;;    int length() default 255;    int precision() default 0;    int scale() default 0;}</code></pre><p>在使用此@Column标记时，需要注意以下几个问题：<br>此标记可以标注在getter方法或属性前，例如以下的两种标注方法都是正确的：</p><p>标注在属性前：</p><pre><code>@Entity@Table(name = &quot;contact&quot;)public class ContactEO{    @Column(name=&quot; contact_name &quot;)    private String name;}</code></pre><p>标注在getter方法前：</p><pre><code>@Entity@Table(name = &quot;contact&quot;)public class ContactEO{    @Column(name=&quot; contact_name &quot;)    public String getName() {        return name;    }}</code></pre><p>JPA规范中并没有明确指定那种标注方法，只要两种标注方式任选其一都可以。这根据个人的喜好来选择</p><p>属性都是什么意思：</p><p>unique属性表示该字段是否为唯一标识，默认为false。如果表中有一个字段需要唯一标识，则既可以使用该标记，也可以使用@Table标记中的@UniqueConstraint。</p><p>nullable属性表示该字段是否可以为null值，默认为true。</p><p>insertable属性表示在使用“INSERT”脚本插入数据时，是否需要插入该字段的值。</p><p>updatable属性表示在使用“UPDATE”脚本插入数据时，是否需要更新该字段的值。insertable和updatable属性一般多用于只读的属性，例如主键和外键等。这些字段的值通常是自动生成的。</p><p>columnDefinition属性表示创建表时，该字段创建的SQL语句，一般用于通过Entity生成表定义时使用。</p><p>table属性表示当映射多个表时，指定表的表中的字段。默认值为主表的表名。有关多个表的映射将在本章的5.6小节中详细讲述。</p><p>length属性表示字段的长度，当字段的类型为varchar时，该属性才有效，默认为255个字符。</p><p>precision属性和scale属性表示精度，当字段类型为double时，precision表示数值的总长度，scale表示小数点所占的位数。</p><p>dao只要继承JpaRepository类就可以，几乎可以不用写方法，还有一个特别有尿性的功能非常赞，就是可以根据方法名来自动的生产SQL，比如findByUserName 会自动生产一个以 userName 为参数的查询方法，比如 findAlll 自动会查询表里面的所有数据，比如自动分页等等</p><p>Entity中不映射成列的字段得加@Transient 注解，不加注解也会映射成列</p><pre><code>package com.example.springboot.domain;import org.springframework.data.jpa.repository.JpaRepository;public interface UserDao extends JpaRepository&lt;User, Long&gt;{    User findByUserName(String userName);    User findByUserNameOrEmail(String username, String email);}</code></pre><p>测试：</p><pre><code>@RunWith(SpringJUnit4ClassRunner.class)//@SpringApplicationConfiguration(Application.class)public class UserDaoTest {    @Autowired    private UserDao userDao;    @Test    public void test() throws Exception {        Date date = new Date();        DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG);                String formattedDate = dateFormat.format(date);        userDao.save(new User(&quot;1&quot;,&quot;aaa&quot;,&quot;123456&quot;,&quot;123@com&quot;,&quot;AAA&quot;,formattedDate));        userDao.save(new User(&quot;2&quot;,&quot;bbb&quot;,&quot;123456&quot;,&quot;123@com&quot;,&quot;BBB&quot;,formattedDate));        userDao.save(new User(&quot;3&quot;,&quot;ccc&quot;,&quot;123456&quot;,&quot;123@com&quot;,&quot;CCC&quot;,formattedDate));        Assert.assertEquals(9, userDao.findAll().size());        Assert.assertEquals(&quot;bb&quot;, userDao.findByUserNameOrEmail(&quot;bbb&quot;, &quot;123@com&quot;).getNickName());        userDao.delete(userDao.findByUserName(&quot;aaa&quot;));    }}</code></pre><h2 id="thymeleaf模板"><a href="#thymeleaf模板" class="headerlink" title="thymeleaf模板"></a>thymeleaf模板</h2><p>Spring boot 推荐使用来代替jsp</p><p>Thymeleaf是一款用于渲染XML/XHTML/HTML5内容的模板引擎。类似JSP，Velocity，FreeMaker等，它也可以轻易的与Spring MVC等Web框架进行集成作为Web应用的模板引擎。与其它模板引擎相比，Thymeleaf最大的特点是能够直接在浏览器中打开并正确显示模板页面，而不需要启动整个Web应用。</p><p>1.Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。</p><p>2.Thymeleaf 开箱即用的特性。它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。</p><p>3.Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。</p><p>我们已经习惯使用了什么 velocity,FreMaker，beetle之类的模版，那么到底好在哪里呢？ 比一比吧 Thymeleaf是与众不同的，因为它使用了自然的模板技术。这意味着Thymeleaf的模板语法并不会破坏文档的结构，模板依旧是有效的XML文档。模板还可以用作工作原型，Thymeleaf会在运行期替换掉静态值。Velocity与FreeMarker则是连续的文本处理器。 下面的代码示例分别使用Velocity、FreeMarker与Thymeleaf打印出一条消息：</p><pre><code>Velocity: &lt;p&gt;$message&lt;/p&gt;FreeMarker: &lt;p&gt;${message}&lt;/p&gt;Thymeleaf: &lt;p th:text=&quot;${message}&quot;&gt;Hello World!&lt;/p&gt;</code></pre><p>注意：由于Thymeleaf使用了XML DOM解析器，因此它并不适合于处理大规模的XML文件。</p><p>具体的在组件官方网站有详细介绍：<a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#introducing-thymeleaf" target="_blank" rel="noopener">https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#introducing-thymeleaf</a></p><p>涵盖了常见的前端操作，比如，判断，循环，引入模板，常用函数（日期格式化，字符串操作）下拉，js和css中使用，基本可以应对一般场景。</p><ul><li><p>引用命名空间 </p>  <html xmlns:th="http://www.thymeleaf.org"> </html></li></ul><p>在html中引入此命名空间，可避免编辑器出现html验证错误，虽然加不加命名空间对Thymeleaf的功能没有任何影响。</p><ul><li>URL</li></ul><p>URL在Web应用模板中占据着十分重要的地位，需要特别注意的是Thymeleaf对于URL的处理是通过语法@{…}来处理的。Thymeleaf支持绝对路径URL：</p><pre><code>&lt;a th:href=&quot;@{http://www.thymeleaf.org}&quot;&gt;Thymeleaf&lt;/a&gt;</code></pre><ul><li>条件求值</li></ul><p><a th:href="@{/login}" th:unless="${session.user" !="null}">Login</a></p><p>等等，在开发文档中都有介绍</p><ul><li>页面即原型</li></ul><p>在Web开发过程中一个绕不开的话题就是前端工程师与后端工程师的写作，在传统Java Web开发过程中，前端工程师和后端工程师一样，也需要安装一套完整的开发环境，然后各类Java IDE中修改模板、静态资源文件，启动/重启/重新加载应用服务器，刷新页面查看最终效果。</p><p>但实际上前端工程师的职责更多应该关注于页面本身而非后端，使用JSP，Velocity等传统的Java模板引擎很难做到这一点，因为它们必须在应用服务器中渲染完成后才能在浏览器中看到结果，而Thymeleaf从根本上颠覆了这一过程，通过属性进行模板渲染不会引入任何新的浏览器不能识别的标签。</p><p>Thymeleaf的用法也可参考：<a href="https://www.cnblogs.com/topwill/p/7434955.html" target="_blank" rel="noopener">https://www.cnblogs.com/topwill/p/7434955.html</a></p><h2 id="WebJars"><a href="#WebJars" class="headerlink" title="WebJars"></a>WebJars</h2><p>WebJars是一个很神奇的东西，可以让大家以jar包的形式来使用前端的各种框架、组件。</p><p>什么是WebJars？WebJars是将客户端（浏览器）资源（JavaScript，Css等）打成jar包文件，以对资源进行统一依赖管理。WebJars的jar包部署在Maven中央仓库上。</p><p>我们在开发Java web项目的时候会使用像Maven，Gradle等构建工具以实现对jar包版本依赖管理，以及项目的自动化管理，但是对于JavaScript，Css等前端资源包，我们只能采用拷贝到webapp下的方式，这样做就无法对这些资源进行依赖管理。那么WebJars就提供给我们这些前端资源的jar包形势，我们就可以进行依赖管理。</p><p>WebJars官网：<a href="http://www.webjars.org/" target="_blank" rel="noopener">http://www.webjars.org/</a><br>WebJars教程整理：<a href="https://www.cnblogs.com/liaojie970/p/7852576.html" target="_blank" rel="noopener">https://www.cnblogs.com/liaojie970/p/7852576.html</a></p><p>如何学习Spring Boot：<a href="https://www.zhihu.com/question/53729800/answer/255785661" target="_blank" rel="noopener">https://www.zhihu.com/question/53729800/answer/255785661</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。也被称为spring的脚手架。&lt;br&gt;该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。&lt;/p&gt;
&lt;p&gt;spring boot 致力于简洁，让开发者写更少的配置，程序能够更快的运行和启动。它是下一代javaweb框架，并且它是spring cloud（微服务）的基础。(spring cloud的基础就是基于spring boot来进行配置)，spring boot就是为了让开发人员从繁重的配置工作解放出来，快速参与开发。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建独立的Spring应用程序&lt;/li&gt;
&lt;li&gt;嵌入的Tomcat，无需部署WAR文件&lt;/li&gt;
&lt;li&gt;简化Maven配置&lt;/li&gt;
&lt;li&gt;自动配置Spring&lt;/li&gt;
&lt;li&gt;提供生产就绪型功能，如指标，健康检查和外部配置&lt;/li&gt;
&lt;li&gt;绝对没有代码生成和对XML没有要求配置（由java配置替代XML配置，也就是零XML配置）&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://yoursite.com/categories/springboot/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
      <category term="springboot" scheme="http://yoursite.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>好用的代码规范检查工具--checkstyle</title>
    <link href="http://yoursite.com/2018/03/22/checkstyle/"/>
    <id>http://yoursite.com/2018/03/22/checkstyle/</id>
    <published>2018-03-22T05:22:32.000Z</published>
    <updated>2018-03-22T06:22:00.889Z</updated>
    
    <content type="html"><![CDATA[<p>CheckStyle是SourceForge下的一个项目，提供了一个帮助Java开发人员遵守某些编码规范的工具。它能够自动化代码规范检查过程，从而使得开发人员从这项重要但枯燥的任务中解脱出来。它可以根据设置好的编码规则来检查代码。比如符合规范的变量命名，方法体的最大行数，重复代码检查等等。</p><p>如果你的项目经理开会时说：“我希望我们写出来的代码就象一个人写的!”，那么用Checkstyle绝对是正确选择！</p><a id="more"></a><h1 id="如何在Eclipse上安装插件"><a href="#如何在Eclipse上安装插件" class="headerlink" title="如何在Eclipse上安装插件"></a>如何在Eclipse上安装插件</h1><p>在eclipse上安装插件，这里直接以安装checkstyle为例子，以后的插件安装根据这个流程来就可以了。</p><p>列举了几个网上的方法（大概有5种方法可以将插件安装到eclipse上）</p><h2 id="第一种：直接复制法"><a href="#第一种：直接复制法" class="headerlink" title="第一种：直接复制法"></a>第一种：直接复制法</h2><p>假设Eclipse的安装目录在C:\eclipse，解压下载的eclipse 插件或者安装eclipse 插件到指定目录文件夹，打开安装文件夹，在安装文件夹里的根目录分别包含两个文件夹features和plugins ，然后把两个文件夹里的文件分别复制到C:\eclipse下所对应的文件夹下的features 和plugins 下，一般的把插件文件直接复制到eclipse目录里是最直接也是最愚蠢的一种方法！因为日后想要删除这些插件会非常的困难（你根本分不清哪个是哪个），不推荐使用。<br>　注意：直接将插件包解压到plugins文件夹下之后，重启eclipse，可能不会加载新的插件。<br>　解决方法是：<br>　　　1、打开命令行，到当前eclipse的目录下，输入eclipse -clean，重新启动eclipse，这样eclipse就会加上新的插件了。<br>　　　2、如果插件不能生效，则请将eclipse\configuration\org.eclipse.update目录（此目录会记录你插件等更新历史）删除后再启动eclipse；<br>　　你可以在eclipse的菜单”Help”–&gt;”About Eclipse SDK”–&gt;”Feature Details” 和”Plug-in Details”中看到新安装的插件。</p><h2 id="第二种：使用link文件法"><a href="#第二种：使用link文件法" class="headerlink" title="第二种：使用link文件法"></a>第二种：使用link文件法</h2><p>a.假设Eclipse的安装目录在C:\eclipse，在该文件夹下，新建这样的目录结构C:\eclipse\PluginsEclipse\jode\eclipse；<br>　　<br>b.解压下载的eclipse 插件或者安装eclipse 插件到指定目录BB（如：C:\BB）文件夹，打开BB文件夹，然后把 BB文件夹里的两个文件夹features和plugins复制到刚刚新建好 C:\eclipse\PluginsEclipse\jode\eclipse，这样eclipse中就有了两个插件目录features and plugins下。</p><p>c.在C:\eclipse目录中新建links（C:\eclipse\links）目录，在links目录中建立一个以link为扩展名的文本文件如jode.link，内容如下path=C:/eclipse/PluginsEclipse/jode 或者path=C:\eclipse\PluginsEclipse\jode（插件的目录），保存后重启eclipse插件就会安装完成。<br>　注意：link文件中path=插件目录的path路径分隔要用\或是/<br>    /eclipse/<br>    　　links/<br>    　　　　jode.link<br>    　　　　webtools.link<br>    　　　　updateManager.link<br>/eclipse/ links/ jode.link webtools.link updateManager.link … … 可以在eclipse的菜单”Help”–&gt;”AboutEclipse SDK”–&gt;”Feature Details” 和”Plug-in Details”中看到新安装的插件。</p><h2 id="第三种：使用eclipse自带图形界面安装"><a href="#第三种：使用eclipse自带图形界面安装" class="headerlink" title="第三种：使用eclipse自带图形界面安装"></a>第三种：使用eclipse自带图形界面安装</h2><p>选择Help &gt; Software Updates &gt; Manager Configuration，再选择Add &gt; Extension Location 找到你要安装插件的目录就可以了。使用eclipse的help-&gt;SoftwareUpdates -&gt;Find and install… search for new features… 输入软件安装地址进行安装强烈推荐这种方法，优点很多比如可以方便的添加删除，也不用自己写link文件！(注意：这种安装你即使没有下载安装包也可以从远程下载，只要知道链接即可，不过国内下载很多插件由于网络原因很慢，或者不能下载下来。)<br>　　备注：Eclipse插件的目录结构<br>/eclipse-plugins/<br>　　eclipse/<br>　　　　.eclipseextension<br>　　　　　　features/<br>　　　　　　plugins/<br>　　第2.3种方法所指向的目录都指的是”eclipse”目录，如果用第3种方法，在eclipse这个目录下必须有文件.eclipseextension，如果下载的插件没有这个文件，</p><p>那就随便eclipse安装目录下的那个文件拷过去就行，只有有这么个文件就可以了，内容没什么用，主要是一些版本信息。例如：</p><pre><code>id=org.eclipse.platform name=Eclipse Platformversion=3.1.1id=org.eclipse.platform name=Eclipse Platform version=3.1.1</code></pre><h2 id="第四种：使用dropins安装插件"><a href="#第四种：使用dropins安装插件" class="headerlink" title="第四种：使用dropins安装插件"></a>第四种：使用dropins安装插件</h2><p>从Eclipse3.5开始，安装目录下就多了一个dropins目录。只要将插件解压后拖到该目录即可安装插件。比如安装svn插件subclipse-1.8.16.zip，只需要如下的三步即可：<br>　　1、使用winrar等压缩软件将压缩包解压至某一文件夹，比如subclipse-1.8.16<br>　　2、将此目录移动/复制至Eclipse安装目录下的dropins目录<br>　　3、重启Eclipse。<br>　　由于此种安装方式可以将不同的插件安装在不同的目录里，并且不用麻烦地写配置文件，因此管理起来会非常方便，推荐使用。</p><h2 id="使用eclipse-marketplace自动下载"><a href="#使用eclipse-marketplace自动下载" class="headerlink" title="使用eclipse marketplace自动下载"></a>使用eclipse marketplace自动下载</h2><p>这个是我用的方法，不能离线，需要从网上下载，eclipse market在线安装</p><p>在早期的eclipse版本中，market功能不是很好用，经常搜索不到插件或下来。忘记在哪个版本开始，使用market就很方便了。<br>建议采用这种方式来安装，直接搜索，选择要安装的插件内容。无需记录引用插件位置。</p><p>打开Help -&gt; eclipse market，搜索checkstyle<br>选择想要的版本 -&gt; install</p><p>勾选所想要应用的功能</p><p>接受协议，安装完成后，重启eclipse生效。（方便快捷，适用于有网络的环境下）</p><h2 id="检查安装是否生效"><a href="#检查安装是否生效" class="headerlink" title="检查安装是否生效"></a>检查安装是否生效</h2><p>打开eclipse，Window–&gt;Preferences,如果列表中出现了checkstyle的菜单，则表示安装成功了。</p><p>注意：如果启动eclipse时，提示ClassNotFoundException等异常信息，则启动时加上一个“-clean”参数启动即可。</p><p>cd F:\Program Files\eclipse\eclipse.exe -clean</p><h2 id="资源整理"><a href="#资源整理" class="headerlink" title="资源整理"></a>资源整理</h2><p>CheckStyle插件地址：<a href="http://eclipse-cs.sourceforge.net/update" target="_blank" rel="noopener">http://eclipse-cs.sourceforge.net/update</a></p><p>github开源插件地址：<a href="https://github.com/checkstyle/eclipse-cs" target="_blank" rel="noopener">https://github.com/checkstyle/eclipse-cs</a></p><p>eclipse如何安装插件：<a href="http://blog.csdn.net/netdevgirl/article/details/54382301" target="_blank" rel="noopener">http://blog.csdn.net/netdevgirl/article/details/54382301</a></p><p>Eclipse中安装和使用CheckStyle： <a href="http://blog.csdn.net/qq_36871364/article/details/72472059" target="_blank" rel="noopener">http://blog.csdn.net/qq_36871364/article/details/72472059</a></p><p>Eclipse Marketplace地址：<a href="http://marketplace.eclipse.org/" target="_blank" rel="noopener">http://marketplace.eclipse.org/</a></p><h1 id="Checkstyle全局配置"><a href="#Checkstyle全局配置" class="headerlink" title="Checkstyle全局配置"></a>Checkstyle全局配置</h1><p>Window –&gt;Preferences,选择checkstyle菜单，增加项目组统一的规则文件，并设置为默认规则。如下图：</p><p><img src="/2018/03/22/checkstyle/p1.png" alt="logo"></p><p><img src="/2018/03/22/checkstyle/p2.png" alt="logo"></p><p>到此全局配置已经完成。</p><h1 id="Checkstyle项目配置"><a href="#Checkstyle项目配置" class="headerlink" title="Checkstyle项目配置"></a>Checkstyle项目配置</h1><p>项目 –&gt; 右键Properties</p><p><img src="/2018/03/22/checkstyle/p3.png" alt="logo"></p><p>到此项目配置已经完成。成功的话，checkstyle已经开始工作了。</p><p>此次发现项目上有很多红叉叉，说明是代码符合规范造成的。</p><p><img src="/2018/03/22/checkstyle/p4.png" alt="logo"></p><p>根据提示信息修改后，则没有有红色的提示。</p><p><img src="/2018/03/22/checkstyle/p5.png" alt="logo"></p><h1 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h1><p>在项目右键菜单中，checkstyle还有一些快捷操作，如下图所示：</p><p><img src="/2018/03/22/checkstyle/p6.png" alt="logo"></p><h1 id="checkStyle-使用"><a href="#checkStyle-使用" class="headerlink" title="checkStyle 使用"></a>checkStyle 使用</h1><p>选中工程，右键选择checkstyle-&gt;check code withcheckstyle,检查错误即可</p><p>Checkstyle的结果输出</p><p>序号     输出内容意义<br>1         Type is missing a javadoc commentClass 缺少类型说明<br>2        “{” should be on the previous line “{” 应该位于前一行<br>3        Methos is missing a javadoc comment方法前面缺少javadoc注释<br>4        Expected @throws tag for “Exception”在注释中希望有@throws的说明<br>5        “.” Is preceeded with whitespace “.” 前面不能有空格<br>6        “.” Is followed by whitespace“.” 后面不能有空格<br>7        “=” is not preceeded with whitespace“=” 前面缺少空格<br>8        “=” is not followed with whitespace“=” 后面缺少空格<br>9        “}” should be on the same line“}” 应该与下条语句位于同一行<br>10        Unused @param tag for “unused”没有参数“unused”，不需注释<br>11        Variable “CA” missing javadoc变量“CA”缺少javadoc注释<br>12        Line longer than 80characters行长度超过80<br>13        Line contains a tab character行含有”tab” 字符<br>14        Redundant “Public” modifier冗余的“public” modifier<br>15        Final modifier out of order with the JSL suggestionFinalmodifier的顺序错误<br>16        Avoid using the “.<em>” form of importImport格式避免使用“.</em>”<br>17        Redundant import from the same package从同一个包中Import内容<br>18        Unusedimport-java.util.listImport进来的java.util.list没有被使用<br>19        Duplicate import to line 13重复Import同一个内容<br>20        Import from illegal package从非法包中 Import内容<br>21        “while” construct must use “{}”“while” 语句缺少“{}”<br>22        Variable “sTest1” must be private and have accessormethod变量“sTest1”应该是private的，并且有调用它的方法<br>23        Variable “ABC” must match pattern“^[a-z][a-zA-Z0-9]<em>$”变量“ABC”不符合命名规则“^[a-z][a-zA-Z0-9]</em>$”<br>24        “(” is followed by whitespace“(” 后面不能有空格 25“)” is proceededby whitespace“)” 前面不能有空格</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CheckStyle是SourceForge下的一个项目，提供了一个帮助Java开发人员遵守某些编码规范的工具。它能够自动化代码规范检查过程，从而使得开发人员从这项重要但枯燥的任务中解脱出来。它可以根据设置好的编码规则来检查代码。比如符合规范的变量命名，方法体的最大行数，重复代码检查等等。&lt;/p&gt;
&lt;p&gt;如果你的项目经理开会时说：“我希望我们写出来的代码就象一个人写的!”，那么用Checkstyle绝对是正确选择！&lt;/p&gt;
    
    </summary>
    
      <category term="工具类" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
      <category term="软件架构" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
      <category term="插件" scheme="http://yoursite.com/tags/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="eclipse" scheme="http://yoursite.com/tags/eclipse/"/>
    
      <category term="代码规范" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>项目自动构建工具--maven和Gradle</title>
    <link href="http://yoursite.com/2018/03/22/maven01/"/>
    <id>http://yoursite.com/2018/03/22/maven01/</id>
    <published>2018-03-21T17:30:13.000Z</published>
    <updated>2018-03-23T08:30:46.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h1><p>Gradle和Maven都是项目自动构建工具，编译源代码只是整个过程的一个方面，更重要的是，你要把你的软件发布到生产环境中来产生商业价值，所以，你要运行测试，构建分布、分析代码质量、甚至为不同目标环境提供不同版本，然后部署。整个过程进行自动化操作是很有必要的。整个过程可以分成以下几个步骤：</p><ul><li>编译源代码</li><li>运行单元测试和集成测试</li><li>执行静态代码分析、生成分析报告</li><li>创建发布版本</li><li>部署到目标环境</li><li>部署传递过程</li><li>执行冒烟测试和自动功能测试</li></ul><a id="more"></a><p>如果你手工去执行每一个步骤无疑效率比较低而且容易出错，有了自动化构建你只需要自定义你的构建逻辑，剩下的事情交给工具去完成。虽然两者都是项目工具，但是maven现在已经是行业标准，Gradle是后起之秀，很多人对他的了解都是从android studio中得到的，Gradle抛弃了Maven的基于XML的繁琐配置，众所周知XML的阅读体验比较差，对于机器来说虽然容易识别，但毕竟是由人去维护的。取而代之的是Gradle采用了领域特定语言Groovy的配置，大大简化了构建代码的行数，比如在Maven中你要引入一个依赖：<br>    <properties><br>        &lt;kaptcha.version&gt;2.3&lt;/kaptcha.version&gt;<br>    </properties><br>    <dependencies><br>        <dependency><br>            <groupid>com.google.code.kaptcha</groupid><br>            <artifactid>kaptcha</artifactid><br>            <version>${kaptcha.version}</version><br>            <classifier>jdk15</classifier><br>        </dependency><br>        <dependency><br>            <groupid>org.springframework</groupid><br>            <artifactid>spring-core</artifactid><br>        </dependency><br>        <dependency><br>            <groupid>org.springframework</groupid><br>            <artifactid>spring-beans</artifactid><br>        </dependency><br>        <dependency><br>            <groupid>org.springframework</groupid><br>            <artifactid>spring-context</artifactid><br>        </dependency><br>        <dependency><br>            <groupid>junit</groupid><br>            <artifactid>junit</artifactid><br>        </dependency><br>    </dependencies></p><p>然后我将其转换成Gradle脚本，结果是惊人的：<br>    dependencies {<br>        compile(‘org.springframework:spring-core:2.5.6’)<br>        compile(‘org.springframework:spring-beans:2.5.6’)<br>        compile(‘org.springframework:spring-context:2.5.6’)<br>        compile(‘com.google.code.kaptcha:kaptcha:2.3:jdk15’)<br>        testCompile(‘junit:junit:4.7’)<br>    }<br>注意配置从原来的28行缩减至7行！这还不算我省略的一些父POM配置。依赖的groupId、artifactId、 version，scope甚至是classfier，一点都不少。较之于Maven或者Ant的XML配置脚本，Gradle使用的Grovvy脚本杀伤力太大了，爱美之心，人皆有之，相比于七旬老妇松松垮垮的皱纹，大家肯定都喜欢少女紧致的脸蛋，XML就是那老妇的皱纹。Gradle给我最大的有点是两点。其一是简洁，基于Groovy的紧凑脚本实在让人爱不释手，在表述意图方面也没有什么不清晰的地方。其二是灵活，各种在Maven中难以下手的事情，在Gradle就是小菜一碟，比如修改现有的构建生命周期，几行配置就完成了，同样的事情，在Maven中你必须编写一个插件，那对于一个刚入门的用户来说，没个一两天几乎是不可能完成的任务。</p><p>gradle基于groovy领域特定语言，而maven通过xml来配置，比较繁琐</p><p>Gradle和Maven作为自动构建工具，在项目的构建中有着广泛的应用。他们之间有各自的优缺点，这里我们讨论下他们在项目构建中的一些区别并进行比较。</p><p>首先简单介绍下Gradle和Maven。Maven主要服务于基于java平台的项目构建、依赖管理和项目信息管理。无论是小型的开源类库项目，还是大型的企业级应用；无论是传统的瀑布式开发还是流行的敏捷模式，Maven都能大显身手。Gradle是以groovy语言为基础，面向java应用为主，基于DSL语法的自动化构建工具。</p><p>虽然两种构建工具有着很多相似处，但是在依赖管理、构建生命周期、加载构建系统组件等许多方面两者有着许多区别。Maven使用XML来定义生成脚本，而 Gradle构建脚本是用Groovy。 用XML的优势在于它可以更方便地定义构建逻辑，但这是比较复杂的步骤。 用Groovy的好处是写起来比XML标签要简洁许多。 不过熟悉的XML的开发人员比groovy的多，并且复杂的逻辑必须由自己编写。类似于Maven的pom.xml文件，每个Gradle项目都需要有一个对应的build.gradle文件，该文件定义一些任务（task）来完成构建工作，当然，每个任务是可配置的，任务之间也可以依赖，用户亦能配置缺省任务。</p><h2 id="加载构建系统的组件"><a href="#加载构建系统的组件" class="headerlink" title="加载构建系统的组件"></a>加载构建系统的组件</h2><p>Maven中每个用于构建的组件（编译/jar等）都作为一个插件， 每个插件都有它自己的版本和依赖关系树。 Gradle的构建系统组件都是分散的。 Maven插件的优点是在于可以独立更新，无需整个系统更新。Gradle的模型的优点是编译需要核心组件以外的组件时才下载。与此同时Gradle给了用户足够的自由去定义自己的任务，Gradle每个任务都有一个描述,可以分配到一个组。Maven中插件和命令可以描述。比如Gradle你可以排除任何运行的任务。在Maven中没有通用的排除机制，必须用插件来实现它。而且Gradle具有高级任务排序的特性，任务之间的依赖关系被建立之后能够得到完全控制，因为Gradle具有强大的语言结构来描述任务之间的执行顺序，即使任务并不取决于对方的输出。Gradle支持动态任务创建，有时你想要一个任务的行为取决于或无限价值的大范围的参数。一个很好的表达方式提供这样的任务是任务规则。并且执行任务时，Gradle 在遇到第一次失败时不停止，执行每一个要执行的任务其中所有的任务依赖关系都要被完成且没有失败。任务可以被分配去完成其他任务类似于java中的终结原则。他们总是在另一个任务执行之后运行，不管这个任务是否失败了。可以发现在一个单一的执行中许多失败任务会被很好地记录成一个错误报告并最终被汇总。</p><h2 id="构建生命周期"><a href="#构建生命周期" class="headerlink" title="构建生命周期"></a>构建生命周期</h2><p>Maven提供有限的构建生命周期访问，插件可以连接到生命周期的特定阶段，而且只有在核心插件执行。而Gradle可以访问生成的一部分并允许用Groovy代码进行处理。Gradle Java Plugin也定义了构建生命周期，包括编译主代码、处理资源、编译测试代码、执行测试、上传归档等等任务.</p><p>相对于Maven完全线性的生命周期，Gradle的构建生命周期略微复杂，不过也更为灵活，例如jar这个任务是用来打包的，它不像Maven那样依赖于执行测试的test任务，类似的，从图中可以看到，一个最终的build任务也没有依赖于uploadArchives任务。这个生命周期并没有将用户限制得很死，由于Gradle完全是基于灵活的任务模型，因此很多事情包括覆盖现有任务，跳过任务都非常易于实现。而这些事情，在Maven的世界中，实现起来就比较的麻烦，或者说Maven就不希望用户这么做。</p><p>除了以上几个Maven核心内容与Gradle的区别，在面向对象输出模式，GUI操作界面、声明元素等方面Gradle也有良好表现。构建输出是构建用户体验的重要部分。在其他大多数构建工具中默认输出对于一个构建作者试图调试一个问题来说是有关联的。这通常会导致一个非常详细的输出会隐藏重要的警告和消息实际上是相关的开发人员运行构建。Gradle的默认输出是针对开发人员运行构建和只显示消息相关的情况下而不是滥用日志输出作为一种进度，例如在执行测试的时候。构建输出为构建用户体验是非常重要的。如果你与外部工具和库集成他们的控制台输出可能非常冗长。Gradle系统中你可以定义每个外部工具结合的日志级别的输出应该被路由。Gradle提供GUI操作界面，这是一个独立的用户界面，可以启动GUI选项，通过自定义日志模式你可以替换它的日志与自己的UI。Gradle有许多细粒度的声明性元素,如SourceSets或Android Product Flavors。它们的核心Gradle DSL然后让Gradle构建语言更加丰富。他们不断构建简洁、易于使用、维护和理解即使你有复杂的需求。Maven没有细粒声明元素，这是Maven极端顽固的主要原因。在Gradle,每个插件都可以提供自己的粗或细粒声明元素。这使你可以提供一个声明性方法甚至定制域。它还允许其他技术集成在Gradle中,让它被更多人使用。</p><p>整体来讲，Gradle给人一种简洁灵活的体验，然而必须掌握groovy也是他的问题，而且由于其灵活性，导致人们更容易破坏约定以至于让构建变得难以理解。但是Gradle确实是Maven理念的优秀实现。如果足够了解Groovy，也理解Maven的配置和构建，Gradle会是绝佳选择，尤其是它几乎能和现有的Maven系统无缝集成，而且你也能享受到简洁带来的极大乐趣，相信Gradle作为后起之秀在今后能够被完善的更好。</p><h1 id="关于groovy语言"><a href="#关于groovy语言" class="headerlink" title="关于groovy语言"></a>关于groovy语言</h1><p>Groovy 是 用于Java虚拟机的一种敏捷的动态语言，它是一种成熟的面向对象编程语言，既可以用于面向对象编程，又可以用作纯粹的脚本语言。使用该种语言不必编写过多的代码，同时又具有闭包和动态语言中的其他特性。</p><p>Groovy是JVM的一个替代语言（替代是指可以用 Groovy 在Java平台上进行 Java 编程），使用方式基本与使用 Java代码的方式相同，该语言特别适合与Spring的动态语言支持一起使用，设计时充分考虑了Java集成，这使 Groovy 与 Java 代码的互操作很容易。（注意：不是指Groovy替代java，而是指Groovy和java很好的结合编程。</p><p>Groovy 语法与Java 语言的语法很相似，虽然 Groovy 的语法源于Smalltalk和Ruby这类语言的理念，但是可以将它想像成 Java 语言的一种更加简单、表达能力更强的变体。（在这点上，Ruby与 Groovy 不同，因为它的语法与 Java 语法差异很大。）</p><p>许多 Java 开发人员喜欢 Groovy 代码和 Java 代码的相似性。从学习的角度看，如果知道如何编写 Java 代码，那就已经了解 Groovy 了。Groovy 和 Java 语言的主要区别是：完成同样的任务所需的 Groovy 代码比 Java 代码更少。</p><p>Groovy教程参考： <a href="https://www.w3cschool.cn/groovy/" target="_blank" rel="noopener">https://www.w3cschool.cn/groovy/</a></p><p>在现在市场上流行的微服务架构都建议采用Gradle来构建项目而非Maven</p><p>spring 项目建议使用Gradle进行构建项目，相比maven来讲 Gradle更简洁，而且gradle更时候大型复杂项目的构建。gradle吸收了maven和ant的特点而来，不过目前maven仍然是Java界的主流，大家可以先了解了解。</p><p>一个使用gradle配置的项目（在开发人员的角度去看这个会发现比maven构建项目的结构会更加的清晰明了）</p><pre><code>buildscript {    repositories {        maven { url &quot;http://repo.spring.io/libs-snapshot&quot; }        mavenLocal()    }    dependencies {        classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:1.3.6.RELEASE&quot;)    }}apply plugin: &apos;java&apos;  //添加 Java 插件, 表明这是一个 Java 项目apply plugin: &apos;spring-boot&apos; //添加 Spring-boot支持apply plugin: &apos;war&apos;  //添加 War 插件, 可以导出 War 包apply plugin: &apos;eclipse&apos; //添加 Eclipse 插件, 添加 Eclipse IDE 支持, Intellij Idea 为 &quot;idea&quot;war {    baseName = &apos;favorites&apos;    version =  &apos;0.1.0&apos;}sourceCompatibility = 1.7  //最低兼容版本 JDK1.7targetCompatibility = 1.7  //目标兼容版本 JDK1.7repositories {     //  Maven 仓库    mavenLocal()        //使用本地仓库    mavenCentral()      //使用中央仓库    maven { url &quot;http://repo.spring.io/libs-snapshot&quot; } //使用远程仓库}dependencies {   // 各种 依赖的jar包    compile(&quot;org.springframework.boot:spring-boot-starter-web:1.3.6.RELEASE&quot;)    compile(&quot;org.springframework.boot:spring-boot-starter-thymeleaf:1.3.6.RELEASE&quot;)    compile(&quot;org.springframework.boot:spring-boot-starter-data-jpa:1.3.6.RELEASE&quot;)    compile group: &apos;mysql&apos;, name: &apos;mysql-connector-java&apos;, version: &apos;5.1.6&apos;    compile group: &apos;org.apache.commons&apos;, name: &apos;commons-lang3&apos;, version: &apos;3.4&apos;    compile(&quot;org.springframework.boot:spring-boot-devtools:1.3.6.RELEASE&quot;)    compile(&quot;org.springframework.boot:spring-boot-starter-test:1.3.6.RELEASE&quot;)    compile &apos;org.webjars.bower:bootstrap:3.3.6&apos;    compile &apos;org.webjars.bower:jquery:2.2.4&apos;    compile(&quot;org.webjars:vue:1.0.24&quot;)    compile &apos;org.webjars.bower:vue-resource:0.7.0&apos;}bootRun {    addResources = true}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;主要区别&quot;&gt;&lt;a href=&quot;#主要区别&quot; class=&quot;headerlink&quot; title=&quot;主要区别&quot;&gt;&lt;/a&gt;主要区别&lt;/h1&gt;&lt;p&gt;Gradle和Maven都是项目自动构建工具，编译源代码只是整个过程的一个方面，更重要的是，你要把你的软件发布到生产环境中来产生商业价值，所以，你要运行测试，构建分布、分析代码质量、甚至为不同目标环境提供不同版本，然后部署。整个过程进行自动化操作是很有必要的。整个过程可以分成以下几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译源代码&lt;/li&gt;
&lt;li&gt;运行单元测试和集成测试&lt;/li&gt;
&lt;li&gt;执行静态代码分析、生成分析报告&lt;/li&gt;
&lt;li&gt;创建发布版本&lt;/li&gt;
&lt;li&gt;部署到目标环境&lt;/li&gt;
&lt;li&gt;部署传递过程&lt;/li&gt;
&lt;li&gt;执行冒烟测试和自动功能测试&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="工具类" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
      <category term="软件架构" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
      <category term="构建工具" scheme="http://yoursite.com/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
      <category term="maven" scheme="http://yoursite.com/tags/maven/"/>
    
      <category term="Gradle" scheme="http://yoursite.com/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>微服务架构--Dubbo还是Spring Cloud？</title>
    <link href="http://yoursite.com/2018/03/20/%E5%88%86%E5%B8%83%E5%BC%8F02/"/>
    <id>http://yoursite.com/2018/03/20/分布式02/</id>
    <published>2018-03-20T13:04:00.000Z</published>
    <updated>2018-03-22T11:41:48.133Z</updated>
    
    <content type="html"><![CDATA[<p>微服务以及SOA我们在上一篇《微服务架构简析》中已经谈及了，接下来我们来谈谈市面上流行的微服务架构产品有哪些?</p><p>微服务架构是互联网很热门的话题，是互联网技术发展的必然结果。它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。</p><p>虽然微服务架构没有公认的技术标准和规范或者草案，但业界已经有一些很有影响力的开源微服务架构框架提供了微服务的关键思路，例如 Dubbo 和 Spring Cloud。</p><a id="more"></a><h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1><p>Dubbo 是阿里巴巴公司一个开源的高性能服务框架，致力于提供高性能和透明化的 RPC 远程服务调用方案，以及 SOA 服务治理方案，使得应用可通过高性能 RPC 实现服务的输出、输入功能和 Spring 框架无缝集成。(淘宝为了应付双11的高流量并发请求所带来的服务器压力而开发的产品)。</p><p>Dubbo 包含远程通讯、集群容错和自动发现三个核心部分。它提供透明化的远程方法调用，实现像调用本地方法一样调用远程方法，只需简单配置，没有任何 API 侵入。</p><p>同时它具备软负载均衡及容错机制，可在内网替代 F5 等硬件负载均衡器，降低成本，减少单点。</p><p>它可以实现服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的 IP 地址，并且能够平滑添加或删除服务提供者。</p><p>2011 年末，阿里巴巴在 GitHub 上开源了基于 Java 的分布式服务治理框架 Dubbo，之后它成为了国内该类开源项目的佼佼者，许多开发者对其表示青睐。</p><p>同时，先后有不少公司在实践中基于 Dubbo 进行分布式系统架构。目前在 GitHub 上，它的 fork、star 数均已破万。</p><p>Dubbo 核心部件（如下图）:</p><ul><li>Provider：暴露服务的提供方，可以通过 jar 或者容器的方式启动服务。</li><li>Consumer：调用远程服务的服务消费方。</li><li>Registry：服务注册中心和发现中心。</li><li>Monitor：统计服务和调用次数，调用时间监控中心。（Dubbo 的控制台页面中可以显示，目前只有一个简单版本。）</li><li>Container：服务运行的容器。</li></ul><p><img src="/2018/03/20/分布式02/p1.jpg" alt="logo"><br>Dubbo总体架构</p><p>Dubbo 核心功能：</p><p>1.远程通讯，提供对多种基于长连接的 NIO 框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。<br>2.集群容错，提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。<br>3.自动发现，基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</p><p>关于Dubbo的历史可以到这篇知乎文章中去看，人家已经整理了Dubbo的发展历史。<br><a href="https://zhuanlan.zhihu.com/p/31206177" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31206177</a></p><h1 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h1><p>spring cloud 为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等。它运行环境简单，可以在开发人员的电脑上跑。另外说明spring cloud是基于springboot的，所以需要开发中对springboot有一定的了解。</p><p>Spring Cloud的子项目，大致可分成两类，一类是对现有成熟框架”Spring Boot化”的封装和抽象，也是数量最多的项目；第二类是开发了一部分分布式系统的基础设施的实现，如Spring Cloud Stream扮演的就是kafka, ActiveMQ这样的角色。对于我们想快速实践微服务的开发者来说，第一类子项目就已经足够使用，如：</p><ul><li><p>Spring Cloud Netflix<br>　　是对Netflix开发的一套分布式服务框架的封装，包括服务的发现和注册，负载均衡、断路器、REST客户端、请求路由等。</p></li><li><p>Spring Cloud Config<br>　　将配置信息中央化保存, 配置Spring Cloud Bus可以实现动态修改配置文件</p></li><li><p>Spring Cloud Bus<br>　　分布式消息队列，是对Kafka, MQ的封装</p></li><li><p>Spring Cloud Security<br>　　对Spring Security的封装，并能配合Netflix使用</p></li><li><p>Spring Cloud Zookeeper<br>　　对Zookeeper的封装，使之能配置其它Spring Cloud的子项目使用</p></li><li><p>Spring Cloud Eureka<br> Spring Cloud Eureka 是 Spring Cloud Netflix 微服务套件中的一部分，它基于Netflix Eureka 做了二次封装，主要负责完成微服务架构中的服务治理功能。</p></li></ul><p>Spring Cloud对于中小型互联网公司来说是一种福音，因为这类公司往往没有实力或者没有足够的资金投入去开发自己的分布式系统基础设施，使用Spring Cloud一站式解决方案能在从容应对业务发展的同时大大减少开发成本。同时，随着近几年微服务架构和Docker容器概念的火爆，也会让Spring Cloud在未来越来越“云”化的软件开发风格中立有一席之地，尤其是在目前五花八门的分布式解决方案中提供了标准化的、全站式的技术方案，意义可能会堪比当前Servlet规范的诞生，有效推进服务端软件系统技术水平的进步。</p><p>Spring Cloud官方网站：<a href="https://projects.spring.io/spring-cloud/" target="_blank" rel="noopener">https://projects.spring.io/spring-cloud/</a> （包括英文DOC）<br>Spring Cloud中文文档地址：<a href="https://springcloud.cc/" target="_blank" rel="noopener">https://springcloud.cc/</a></p><p><img src="/2018/03/20/分布式02/p1.jpg" alt="logo"></p><p>学习资源整理：</p><p>Spring Cloud基础教程：<a href="http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</a><br>  对应Github项目：<a href="https://github.com/dyc87112/SpringCloud-Learning" target="_blank" rel="noopener">https://github.com/dyc87112/SpringCloud-Learning</a><br>方志朋的专栏 Spring Cloud：<a href="http://blog.csdn.net/forezp/article/details/70148833" target="_blank" rel="noopener">http://blog.csdn.net/forezp/article/details/70148833</a></p><p>Spring Boot基础教程：<a href="http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</a><br>  对应Github项目：<a href="https://github.com/dyc87112/SpringBoot-Learning" target="_blank" rel="noopener">https://github.com/dyc87112/SpringBoot-Learning</a><br>  对应码云：<a href="https://gitee.com/didispace/SpringBoot-Learning" target="_blank" rel="noopener">https://gitee.com/didispace/SpringBoot-Learning</a><br>方志朋的专栏 Spring Boot：<a href="http://blog.csdn.net/forezp/article/details/61472783" target="_blank" rel="noopener">http://blog.csdn.net/forezp/article/details/61472783</a>           </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微服务以及SOA我们在上一篇《微服务架构简析》中已经谈及了，接下来我们来谈谈市面上流行的微服务架构产品有哪些?&lt;/p&gt;
&lt;p&gt;微服务架构是互联网很热门的话题，是互联网技术发展的必然结果。它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。&lt;/p&gt;
&lt;p&gt;虽然微服务架构没有公认的技术标准和规范或者草案，但业界已经有一些很有影响力的开源微服务架构框架提供了微服务的关键思路，例如 Dubbo 和 Spring Cloud。&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="Dubbo" scheme="http://yoursite.com/tags/Dubbo/"/>
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>主流的Web服务实现方案--REST与SOAP和XML-RPC相比有哪些优势？</title>
    <link href="http://yoursite.com/2018/03/20/web%E9%A3%8E%E6%A0%BC/"/>
    <id>http://yoursite.com/2018/03/20/web风格/</id>
    <published>2018-03-20T08:51:36.000Z</published>
    <updated>2018-03-20T13:03:38.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于RESTful"><a href="#关于RESTful" class="headerlink" title="关于RESTful"></a>关于RESTful</h1><p>具象状态传输（REST，英文：Representational State Transfer）是Roy Thomas Fielding博士于2000年在他的博士论文中提出来的一种万维网软件架构风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息。</p><p>目前在三种主流的Web服务实现方案中，因为REST模式与复杂的SOAP和XML-RPC相比更加简洁，越来越多的web服务开始采用REST风格设计和实现。例如，Amazon.com提供接近REST风格的Web服务运行图书查询；雅虎提供的Web服务也是REST风格的。</p><a id="more"></a><p>具象状态传输是设计风格而不是标准。REST通常基于使用HTTP，URI，和XML以及HTML这些现有的广泛流行的协议和标准。<br>一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p><p>1.资源是由URI来指定。<br>2.对资源的操作包括获取、创建、修改和删除资源，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。<br>3.通过操作资源的表现形式来操作资源。<br>4.资源的表现形式则是XML或者HTML，取决于读者是机器还是人，是消费web服务的客户软件还是web浏览器。当然也可以是任何其他的格式。</p><h2 id="RESTful特征"><a href="#RESTful特征" class="headerlink" title="RESTful特征"></a>RESTful特征</h2><ul><li>统一接口(Uniform Interface)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于RESTful&quot;&gt;&lt;a href=&quot;#关于RESTful&quot; class=&quot;headerlink&quot; title=&quot;关于RESTful&quot;&gt;&lt;/a&gt;关于RESTful&lt;/h1&gt;&lt;p&gt;具象状态传输（REST，英文：Representational State Transfer）是Roy Thomas Fielding博士于2000年在他的博士论文中提出来的一种万维网软件架构风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息。&lt;/p&gt;
&lt;p&gt;目前在三种主流的Web服务实现方案中，因为REST模式与复杂的SOAP和XML-RPC相比更加简洁，越来越多的web服务开始采用REST风格设计和实现。例如，Amazon.com提供接近REST风格的Web服务运行图书查询；雅虎提供的Web服务也是REST风格的。&lt;/p&gt;
    
    </summary>
    
      <category term="WEB" scheme="http://yoursite.com/categories/WEB/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="软件架构" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
      <category term="REST" scheme="http://yoursite.com/tags/REST/"/>
    
  </entry>
  
  <entry>
    <title>微服务架构简析</title>
    <link href="http://yoursite.com/2018/03/20/%E5%88%86%E5%B8%83%E5%BC%8F01/"/>
    <id>http://yoursite.com/2018/03/20/分布式01/</id>
    <published>2018-03-19T16:34:06.000Z</published>
    <updated>2018-03-20T13:09:18.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微服务是什么？"><a href="#微服务是什么？" class="headerlink" title="微服务是什么？"></a>微服务是什么？</h1><p>谈及微服务架构，2016年应该是软件业微服务爆发的元年，微服务到底是什么？<br>观察现有的软件业，使用单独一款开发语言区开发一款较为全面的产品很少，大多数都是各种语言编写的功能模块进行组装成完整的业务模型，<br>各语言效率优势互补。<br>微服务架构所强调的特点就是业务系统需要彻底的组件化与模块分割，原有的单个业务系统分割成多个小应用，每个小应用可以进行独立开发，管理，运行和测试，甚至连每个产品的前端（UI加结构），服务端（控制层，逻辑层和持久化层），数据库都是完全独立的产品，通过微服务架构将每个小应用进行整合，交互与集成，每个小应用不仅能够自己完全独立的功能，还可以运行其他小应用的服务，同时也将自己作为可供利用的服务对象。</p><a id="more"></a><p>采用一组服务的方式来构建一个应用，服务独立部署在不同的进程中，不同服务通过一些轻量级交互机制来通信，例如 RPC、HTTP 等，服务可独立扩展伸缩，每个服务定义了明确的边界，不同的服务甚至可以采用不同的编程语言来实现，由独立的团队来维护。简单的来说，一个系统的不同模块转变成不同的服务！而且服务可以使用不同的技术加以实现。</p><p>有了微服务，彻底的将耦合性再次的降低，彼此之间可以高效解耦。</p><p>关于微服务到底是个啥，我这里引用了一个知乎的回答，很有意思：<br>作者：dz902<br>链接：<a href="https://www.zhihu.com/question/37808426/answer/195479692" target="_blank" rel="noopener">https://www.zhihu.com/question/37808426/answer/195479692</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>很久以前的一天，Martin 在跟好友的交流中悟到了一种很棒的架构设计。他总结了一下，然后告诉了好友，好友说，这不是新鲜东西，早有人总结了，叫做 SOA。Martin 很高兴，开始在公司内外推广 SOA。结果，不停有人质疑和挑战他。</p><p>你这不是 SOA 吧？SOA 这里应该是如此这般的。对，这里我对 SOA 的理解是这样的。你看，这本 SOA 的书说的和你说的有出入。粒度？SOA 没有谈到这个呀，你这不是 SOA。分层跟 SOA 没有关系，你为什么要说这个呢？</p><p>…Martin 没办法，心一横，老子就叫它 Martin’s SOA。老子发明的词，老子就是最高权威，有最终解释权。还有谁不服？同事们一看，这思想本身很不错，值得推广，但叫 Martin’s SOA 太没品了吧？还是要取个好一点的名字，最好还能跟 SOA 有某种暗示传承。干脆就叫 Microservices 好了，又新，又有服务含在其中。</p><p>Martin 忿忿地接受了这个建议，心里想着：妈的，明明就是 SOA，一群傻逼非要逼我取个新名字。后来 Martin 发现每次提一个东西就会收到旧恶傻势力对解释权的挑战，所以每次要提一个什么概念，都去发明一个新词，免得一群人在那一边质疑挑战，一边大谈“我的理解”。</p><p>这就是微服务、敏捷、精益企业、持续集成、持续交付背后的故事。一个名词产生之后，命名者的解释权就会随着时间而弱化（比如 Cooper 发明的 Persona 就被无数设计师乱用）。<br>敏捷已经有点烂了，等微服务也烂了，我们还会发明新词。实在没辙，都是被逼的啊。</p><p>微服务有以下几个特征：</p><ol><li>通过服务实现组件化；</li><li>按业务能力来划分服务与组织团队；</li><li>服务即产品；</li><li>智能终端与哑管道；</li><li>去中心统一化；</li><li>基础设施自动化；</li><li>Design for failure；</li><li>进化设计</li></ol><p>上面讲到微服务与SOA的宫斗戏码，又来讲讲什么是SOA？</p><h2 id="SOA架构"><a href="#SOA架构" class="headerlink" title="SOA架构"></a>SOA架构</h2><p>SOA是什么？SOA全英文是Service-Oriented Architecture，中文意思是中文面向服务编程，是一种思想，一种方法论，一种分布式的服务架构</p><p>可以肯定的是SOA和微服务的确是一脉相承的，大神Martin Fowler提出来这一概念可以说把SOA的理念继续升华，精进了一步。其核心思想是在应用开发领域，使用一系列微小服务来实现单个应用的方式途径，或者说微服务的目的是有效的拆分应用，实现敏捷开发和部署 ，可以是使用不同的编程语言编写。而SOA可能包含的意义更泛一些，更不准确一些。</p><p> 用途：SOA解决多服务凌乱问题，SOA架构解决数据服务的复杂程度，同时SOA又有一个名字，叫做服务治理。</p><p>架构由中心式转为分布式的演变过程</p><p>这里给一个电商服务由传统架构改向分布式架构的流程图</p><p><img src="/2018/03/20/分布式01/p1.png" alt="logo"></p><p>当我们的项目比较小时，我们只有一个系统，并且把他们写到一起，放在一个服务器上，但是随着平台越来越大，数据量越来越大，我们不得不通过分库，把多个模块的数据库分别放在对应得服务器上，每个模块调用自己的子系统即可。</p><p><img src="/2018/03/20/分布式01/p2.png" alt="logo"></p><p>随着我们系统的进一步复杂度的提示，我们不得不进一步对系统的性能进行提升，我们将多个模块分成多个子系统，多个子系统直接互相调用（因为SOA一般用于大型项目，比较复杂，所以一般总系统不会再集成，会拆分多个，分别做成服务，相互调用）。当我们的电商UI进行一个下订单的任务时，多个服务直接互相调用，系统通过数据总线，分别调用对应的子系统即可。</p><p>企业数据总线(ESB)：企业数据总线不是对多个子模块的集成，他在这里充当数据通道的作用，数据总线不关心业务，数据总线根据给的地址和协议去调服务，上端不关心服务在哪里是什么，只找数据总线。</p><p>上面几个图应该算是比较清楚了，随着业务的深入，我们不得不对系统进行调整，分别是对数据和业务的拆分，最后每个子系统对面提供服务。</p><p>还要提的一点就是下面那个图，下面的IP库以及几个子系统是公共服务，分别向上提供功能，也是SOA方法论的一部分。</p><p><img src="/2018/03/20/分布式01/p3.png" alt="logo"></p><p>通过上面的图我们可以看出，多个子系统直接相互交互，相互调用非常凌乱，这样我们就很不爽，所以我们就用到了我们的SOA架构，SOA又叫服务治理，SOA就是帮助我们把服务之间调用的乱七八糟的关系给治理起来，然后提供一个统一的标准，把我们的服务治理成下图所示，以前我们的服务是互相交互，现在是只对数据总线进行交互，这样系统就变得统一起来。</p><p><img src="/2018/03/20/分布式01/p4.png" alt="logo"></p><p>统一标准：各系统的协议、地址、交互方式。</p><p>新的交互方式：各个系统分别根据统一标准向数据总线进行注册，各子系统调用其他子系统时，我们并不关心如果找到其他子系统，我们只找数据总线，数据总线再根据统一标准找其他子系统，所以数据总线在这里充当一个只路人的作用。</p><p>首先Martin Fowler提出SOA歧义Service Oriented Ambiguity，认为”什么是SOA”是不可能回答，因为不同的人意味着不同的事情，SOA意味服务接口，意味流程整合，意味资源再利用，意味着管制，在下面SOA组件图中，服务和服务消费者(客户端)之间存在多个约束，当一个服务显式暴露后，客户端能够通过绑定定位到该服务，相当于两者签订了合同，规定了合同内容和如何实施，具体合同的描述是通过消息方式进行</p><p><img src="/2018/03/20/分布式01/soa.png" alt="logo"></p><p>由于Java等传统语言主要是以类表达对象，将功能行为封装在类内部，而业务客户一般都是注重软件的功能，包括同行业公司系统之间数据交流也是以功能服务为接口，因此，面向服务的架构SOA更加贴近业务客户，也更适合业务伙伴之间流程整合，各个行业已经诞生自己行业特点的SOA，例如电信联盟的NGOSS，已经成为电信行业业务支撑系统BOSS的标准。SOA不但是技术用语，也是业务销售用语，通过服务这个中间概念，可以实现业务和技术之间的无缝转换，如今SOA已经和REST DDD以及云计算等新技术方法结合。其内部主要概念有SCA ESB JBI等等，涉及工作流 规则引擎 消息总线等多个技术细节方面。</p><p>通常，一个架构师进行系统架构顶层设计时，必须考虑使用者的利益，不能单单实现软件的功能，还要考虑到软件的性能Scalable 可用性available/usable 安全性等软件质量，还要借鉴社区的最佳实践和经验形成的模式和反模式，避免重蹈覆辙和陷阱，再大胆采取最新的软件技术(比如用REST替代SOAP等)。</p><p>服务的提出其实隐含了两个概念，服务提供者和服务消费者，这两者之间有一个合同约定，这非常类似我们现实生活中签订的服务合同，A单位和B单位分别是服务的提供者和消费者，两者签订了一个服务合同，规定A为B提供某项服务。服务就是提供一些公共需求的设施，通过一个工作过程能提供帮助，使用，让使用者受益。</p><p>服务具体有如下：Windows Service:如PC定位者RPC Locator, 事件日志EventLog, DHCP Client,；. 软件服务Software Service，如分布式服务Distribution Service, 警告服务Alert Service 安全服务 Security Service, 日志服务；业务服务Business Service，如 帐号和客户服务，销售服务，订单服务，采购服务。</p><p>服务两个重要特点：自治和管制，自治代表服务不能被外部势力牵制，比如如果一个服务内部处理中需要调用外部资源或等待外部流程结束，这种等待不能影响服务本身的调用，如果一个服务分为显式对外和隐式内部两个部分，那么自治是针对隐式内部，意味着我们不能在具体一个服务中直接使用同步代码实现复杂功能。如：</p><pre><code>public AServiceImpl implements AService{　　public void productSale(...){　　　　Product product = productService.getProduct();　　　　int inventory = InventoryService.getInventory(product);　　　　int price = priceService.getPrice(product);　　}}</code></pre><p>在AServiceImpl的productSale方法中，我们获得商品的库存和定价，都是通过同步的RPC实现调用的，这样造成productSale方法依赖于InventoryService和priceService，无法实现自身自治。</p><p>实现服务真正自治，实际就是解决类之间依赖耦合的问题，消息是一种方式，但是基于消息又有两种通讯方式，基于请求响应和基于事件的EDA。</p><p>从服务自治可以看出，为什么要提出服务必须自治，因为服务是受管制的，在实际业务活动中，不同服务是被不同部分管理，比如定价服务归属财务部门系统，库存归属仓库系统，涉及系统之间调用协调不能自己使用同步RPC，而是需要消息。</p><p>在实际应用中，很多单位使用SOA主要看中其能够无缝整合新旧系统,称为EAI企业应用整合，下图是苏宁的一种SOA图，使用ESB企业服务总线这样的消息系统整合了新旧各种系统。</p><p><img src="/2018/03/20/分布式01/suning.jpg" alt="logo"></p><h3 id="ESB"><a href="#ESB" class="headerlink" title="ESB"></a>ESB</h3><p>ESB全称为Enterprise Service Bus，即企业服务总线。它是传统中间件技术与XML、Web服务等技术结合的产物。ESB提供了网络中最基本的连接中枢，是构筑企业神经系统的必要元素。ESB的出现改变了传统的软件架构，可以提供比传统中间件产品更为廉价的解决方案，同时它还可以消除不同应用之间的技术差异，让不同的应用服务器协调运作，实现了不同服务之间的通信与整合。从功能上看，ESB提供了事件驱动和文档导向的处理模式，以及分布式的运行管理机制，它支持基于内容的路由和过滤，具备了复杂数据的传输能力，并可以提供一系列的标准接口。</p><p><img src="/2018/03/20/分布式01/p5.png" alt="logo"></p><p>数据总线是起到调度服务的作用，数据总线不是集成服务，数据总线更新一个调度框架，每个服务需要根据约定向数据总线注册服务，那么如何注册那？其实数据总线就像一个字典结构，</p><p>数据总线里面一个key对于一个value，key指的是服务名，value则是服务的调度方式，还有一点需要说明的是，数据总线只是指路人，服务是不经过数据总线的，如上图的黄色线的路径。</p><p>企业服务总线（EnterpriseServiceBus，ESB）从面向服务体系架构（Service-OrientedArchitecture，SOA）发展而来，是传统中间件技术与XML、Web服务等技术结合的产物。<br>ESB提供了网络中最基本的连接中枢，是构筑企业神经系统的必要元素。ESB采用了“总线”这样一种模式来管理和简化应用之间的集成拓扑结构，以广为接受的开放标准为基础来支持应用之间在消息、事件和服务级别上动态的互连互通，是一种在松散耦合的服务和应用之间标准的集成方式。它可以作用于：<br>①面向服务的架构—分布式的应用由可重用的服务组成；<br>②面向消息的架构—应用之间通过ESB发送和接受消息；<br>③事件驱动的架构—应用之间异步地产生和接收消息。<br>ESB的出现改变了传统的软件架构，可以提供比传统中间件产品更为低廉的解决方案，同时它还可以消除不同应用之间的技术差异，让不同的应用服务器协调运作，实现了不同服务之间的通信与整合。从功能上看，ESB提供了事件驱动和文档导向的处理模式，以及分布式的运行管理机制，它支持基于内容的路由和过滤，具备了复杂数据的传输能力，并可以提供一系列的标准接口。</p><p>ESB 是传统中间件技术与XML、Web服务等技术相互结合的产物，ESB的出现改变了传统的软件架构，可以提供比传统中间件产品更为廉价的解决方案，同时它还可以消除不同应用之间的技术差异，让不同的应用服务器协调运作，实现了不同服务之间的通信与整合。从功能上看，ESB提供了事件驱动和文档导向的处理模式，以及分布式的运行管理机制，它支持基于内容的路由和过滤，具备了复杂数据的传输能力，并可以提供一系列的标准接口。</p><p>大规模分布式的企业应用需要相对简单而实用的中间件技术来简化和统一越来越复杂、繁琐的企业级信息系统平台。面向服务体系架构（SOA）是能够将应用程序的不同功能单元通过服务之间定义良好的接口和契约联系起来。SOA使用户可以不受限制地重复使用软件、把各种资源互连起来，只要IT人员选用标准接口包装旧的应用程序、把新的应用程序构建成服务，那么其他应用系统就可以很方便的使用这些功能服务。<br>支撑SOA的关键是其消息传递架构-企业服务总线（ESB）。ESB是传统中间件技术与XML、Web服务等技术相互结合的产物，用于实现企业应用不同消息和信息的准确、高效和安全传递。让不同的应用服务协调运作，实现不同服务之间的通信与整合。ESB在不同领域具有非常广泛的用途:</p><p>电信领域：ESB能够在全方位支持电信行业OSS的应用整合概念。是理想的电信级应用软件承载平台。<br>电力领域：ESB能够在全方位支持电力行业EMS的数据整合概念，是理想的SCADA系统数据交换平台。<br>金融领域：ESB能够在全方位支持银企间业务处理平台的流程整合概念，是理想的B2B交易支撑平台。<br>电子政务：ESB能够在全方位支持电子政务应用软件业务基础平台、信息共享交换平台、决策分析支撑平台和政务门户的平台化实现。</p><p>使用SOA和ESB能够灵活实现业务流程管理，工作流的管理BPM，如下图，一个订单的产生可能需要几个部门批准才能完成，而且这几个部门经常是变化的，如何灵活实现这种批准流程的定制也成为SOA实现的一部分，如下：</p><p><img src="/2018/03/20/分布式01/bpm.png" alt="logo"></p><p>注意图中1 2 3 4 5 6 7 8 9标注的订单处理流程步骤，这种不同服务之间调用处理顺序可通过BPM进行灵活定制。</p><p>目前提供SOA全套解决方案和产品的厂商很多，包括IBM SAP和Oracle，国内金蝶用友浪潮软件等等，比如苏宁的SOA是以SAP为主的八国联军组装，既然SOA中间件服务商已经为我们提供了成熟的架构方案和产品，那么作为SOA使用者是否就无需顶层架构设计了呢？当然不是，SOA使用者要根据自己业务进行模块划分，进行领域建模设计，根据DDD领域驱动设计将业务分解为一个上下文模块，然后再用服务作为对外接口，内部封装的是DDD聚合根，而传统SOA作法是内部封装的是数据表的DTO，从而导致SOA服务内部腐烂堵塞，违背SOA自治和可用性等原则约束。具体可见DDD领域驱动设计。</p><p>SOA的好处<br>1.松耦合：由于服务自治，有一定封装边界，服务调用交互是通过发布接口。这意味着应用程序不感兴趣的服务如何被实现。<br>2.位置透明：服务的消费者不必关系服务位于什么地方。<br>3.可在异构平台间复用。可以将遗留系统包装成服务。<br>4.便于测试，能并行开发，较高可靠性和良好可伸缩性。<br>5.降低用户成本，用户不需要关心各服务之间是什么语言的、不需要知道如果调用他们，只要通过统一标准找数据总线就可以了。<br>6.程序之间关系服务简单<br>7.识别哪些程序有问题（挂掉）</p><p>缺点：提示了系统的复杂程度，性能有相应影响。</p><p>从实现方式上，两者都是中立性，语言无关，协议跨平台，相比SOA，微服务框架将能够带来更大的敏捷性，并为你构建应用提供更轻量级、更高效率的开发。而SOA更适合大型企业中的业务过程编排、应用集成。</p><p>另外还有微服务甚至是去ESB、去中心化、分布式的，而SOA还是以ESB为核心，大量的WS标准实现。再次，从服务粒度上，既然是微，必然微服务更倡导服务的细粒度，重用组合，甚至是每个操作（或方法）都是独立开发的服务，足够小到不能再进行拆分。而SOA没有这么极致的要求，只需要接口契约的规范化，内部实现可以更粗粒度，微服务更多为了可扩充性、负载均衡以及提高吞吐量而去分解应用，但同时也引发了打破数据模型以及维护一致性的问题。</p><p>微服务相比于SOA粒度更细。</p><p>最后，从部署方式上，这个是最大的不同，对比Monolithic（有人翻译为单体）的Java EE部署架构，通过展现层打包WARs，业务层划分到JARs最后部署为EAR一个大包，而微服务则打开了这个黑盒子，把应用拆分成为一个一个的单个服务，应用Docker技术，不依赖任何服务器和数据模型，是一个 全栈应用，可以通过自动化方式独立部署，每个服务运行在自己的进程中，通过轻量的通讯机制联系，经常是基于HTTP资源API，这些服务基于业务能力构建，能实现集中化管理（因为服务太多啦，不集中管理就无法DevOps啦）。</p><p><strong>引用知乎比喻：</strong></p><p>以一个公司为例：有基层员工 有管理层 有老板，最初大家都听老板指挥，谁干什么谁干什么，根据需要，你可能今天干A事情，明天干B事情，后来人越来越多了，事情也越来越多了，做事情的效率越来越多，管理也很混乱，就开始做部门划分（服务化），专门部门做专门事情的，IT部门只做研发，人事部门只做招聘； 这个时候就无法避免的发生跨部门协作（服务器调用）， 但是你怎么知道有这样一个部门可以做这个事情呢，就要依赖行政部门（注册中心），新成立的部门要在行政哪里做一个备案（服务注册），然后公布一下，让其他部门知道了（服务发布），大家就可以在新的工作秩序里面嗨皮的上班了，这个时候依然是在公司的组织架构中运转；</p><p>上述就是我理解的SOA的概念微服务没有具体的实施过，通过自己的一些理解尝试解释一下，勿喷！微服务有一定SOA的概念在里面，只是在粒度中，微服务更加细一点，比如说用户业务服务：登录 注册 个人中心 包含3个业务，都有userService 提供的，但是在微服务中，登录会被独立出来一个服务，注册也会被独立出来，相对SOA的粒度更细，业务场景耦合更低；另外微服务强调一个去中心化，上述的公司的组织架构会被打散，没有老板，没有管理层，每一个人都是一个服务，做着自己的事情，虽然没有完全想明白，把自己的理解放出来，大家可以探讨一下。</p><p>微服务是SOA的一种实现，也可以说微服务是去ESB的SOA</p><p>背后实际上是两种思想的分歧：分布还是集中</p><p>当然这里说的不是服务的分布和集中。服务肯定是分布的，这是大前提，是SOA的本质理念之一。分歧在于对服务的治理，是分布还是集中。</p><p>微服务所提倡的是完完全全的分布式服务。</p><h2 id="微服务架构特征（Characteristics）"><a href="#微服务架构特征（Characteristics）" class="headerlink" title="微服务架构特征（Characteristics）"></a>微服务架构特征（Characteristics）</h2><p>微服务架构是 Martin Fowler 和 James Lewis 定义的一种架构风格。他们将这种风格描述为”一种使用小型服务构建系统的架构方法，每个服务都在自己的进程中，它们通过轻量型协议进行通信”。</p><p>每个服务都是相互独立开发和部署的。每个微服务都专注执行一个它所擅长的相对较小的任务。</p><p>微服务架构是产品或服务所有者跟上或超越 IT 行业的快速发展节奏的推动因素之一。</p><h3 id="小型且专注于业务领域"><a href="#小型且专注于业务领域" class="headerlink" title="小型且专注于业务领域"></a>小型且专注于业务领域</h3><p>小并不能充分描述微服务，使用这个词只是为了尝试表明微服务相对于整体式应用程序的大小。在此上下文中，小的定义可能在各个系统中各不相同，而且没有规则来定义服务必须有多小。<br>我的理解是将传统整体式应用服务拆分为可独立运行互不干扰的最小组件，这个组件涵盖软件设计的全部细节，前段后端数据端，开发者必须熟悉小组件设计的全部设计环节，这岂不是以后每个人都必须是全栈式开发人员？</p><p>微服务的另一个重要特征是，每个服务专注负责一项精细的业务。Vaughn Vernon 在他撰写的图书《实现领域驱动设计》中定义了术语业务领域。他将业务领域定义为，”某个组织执行的操作和它执行操作的环境。”他还指定，”每个组织都有自己独特的知识范围和操作方式。这个理解范围和它执行操作的方法就是它的领域。”被分解为微服务的单元实际上就是领域内的业务实体，<strong>这意味着每个微服务处理完成一个完整的业务任务</strong>。例如：Mortgage Services 是一个业务领域。Loan Origination 是该领域中一个可能的微服务。Loan Refinancing 可能是同一个领域中的另一个微服务。跨服务边界的调用和更改通常很耗资源，必须避免。拥有这些服务的团队成为相应业务领域或子领域的专家，而不是任意技术领域的专家。</p><p>微服务通常负责一个精细的工作单元，所以它在规模上相对较小。一条著名的指导原则是”两块披萨的团队规模”方案，意思是说，如果两块披萨不能将整个团队喂饱，那么这个开发微服务的团队可能太大了。微服务必须足够小，使得团队中的每个人都能理解该服务的整体设计和实现。另外，它的大小必须足以让团队在必要时轻松地维护或重写服务。</p><h3 id="与技术中立"><a href="#与技术中立" class="headerlink" title="与技术中立"></a>与技术中立</h3><p>开发微服务的团队必须使用他们熟悉的技术。不要规定开发团队应该使用何种编程语言。让开发人员自由选择对任务最有意义的技术和执行任务的人。这种工作方式能够充分利用团队成员拥有的最佳技术和技能。微服务架构仍需要技术决策；举例而言，使用具象状态传输 (REST) 应用编程接口 (API) 访问更好一些（即RESTful API），还是使用某种类型的排队来访问更好一些？但是，一般而言，您可以为微服务架构选择广泛范围内的任何技术。</p><ul><li>具象状态传输 (REST)<br>具象状态传输（REST，英文：Representational State Transfer）是Roy Thomas Fielding博士于2000年在他的博士论文中提出来的一种万维网软件架构风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息。<br>目前在三种主流的Web服务实现方案中，因为REST模式与复杂的SOAP和XML-RPC相比更加简洁，越来越多的web服务开始采用REST风格设计和实现。例如，Amazon.com提供接近REST风格的Web服务运行图书查询；雅虎提供的Web服务也是REST风格的。<br>这个后期会将互联网WEB架构单独开篇讲解。</li></ul><h3 id="松散耦合"><a href="#松散耦合" class="headerlink" title="松散耦合"></a>松散耦合</h3><p>松散耦合对基于微服务的系统至关重要。每个微服务都必须采用使其与其他服务的关联很小的方式来设计接口。这样，在更改一个服务并部署它时，就无需更改和重新部署系统的其他部分。（完全可独立运行的最小服务组件）</p><p>为了避免服务之间的耦合，必须了解导致紧密耦合的原因。紧密耦合的一个原因是通过 API 公开服务的内部实现。这种公开方式将服务的使用者与它的内部实现绑定在一起，从而导致更高的耦合度。在这种情况下，如果更改微服务的内部架构，可能还需要更改服务的使用者，否则就会破坏使用者。这可能会增加更改的成本，给实现更改带来潜在隐患，进而增加服务中的技术债务。必须避免任何导致公开服务的内部实现的方法，以确保微服务之间松散耦合。</p><p>另一个错误是让服务的 API 太过精细。如果 API 太过精细，服务之间的调用可能变得太过频繁，也就是说，会通过网络执行更多的调用。除了前缀的性能问题，过度频繁的通信还可能造成紧密耦合。因此，设计服务接口的方式必须能够最大限度地减少网络中执行的来回调用。</p><p>必须避免一个服务内的实现过于分散，方法是将表示业务实体的相关属性、行为放在尽可能相近的地方。将相关属性放在一个微服务中；如果更改某个属性或行为，可以在一个位置更改它并快速部署该更改。否则，必须在不同部分中执行更改，然后同时一起部署这些散乱的部分；这会导致这些部门之间紧密耦合。</p><p>每个微服务必须有自己的源代码管理存储，以及用于构建和部署的交付管道。这样即可在必要时部署每个服务，而不需要与其他服务的所有者进行协调。如果您有两个服务，而且始终在一次部署中一起发布这两个服务，这可能表明两个服务最好合并为一个服务，而且必须对当前服务执行更多分解工作。松散耦合还支持更频繁、更快速的部署，最终提高应用程序对其用户需求的响应能力。</p><h3 id="实现容易观察"><a href="#实现容易观察" class="headerlink" title="实现容易观察"></a>实现容易观察</h3><p>微服务架构要求您能够可视化系统中所有服务的健康状态，以及它们之间的连接。这使您能快速找到并响应可能发生的问题。实现可视化的工具包含一种全面的日志机制，能够记录日志，存储日志，并使日志容易搜索，以便执行更有效的分析。</p><p>向系统中配置和添加的新服务越多，让这些服务变得可观察就会越难。因为在添加更多动态部分时，微服务架构会增加复杂性，所以观察设计必须明确，使可视化的日志和监视数据能为分析提供有帮助的信息。</p><h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><p>自动化是有效设计和实现软件应用程序的一个重要要求。对于微服务，自动化是一个至关重要但又充满挑战的任务。除了需要在生产中运行系统之外，微服务架构还向系统的实现引入了更多复杂性。在处理的机器和组件数量较少时，可能可以接受手动配置机器，安装中间件，部署组件，或者手动登录到服务器并收集日志，以及执行其他手动任务。但是，当组件数量增加时，在某个时刻后，您可能无法使用手动方法。</p><p>自动化可帮助组建一个服务器并安装必要的运行时环境。然后，只需使用几行代码，就能快速将微服务放在这些运行时环境上。这种自动化使您能编写微结构代码，访问用于部署生产服务的准确的工具链，从而及早发现问题。自动化是连续集成和连续交付方法的核心推动力量。如果您想将微服务架构的复杂性保持在控制范围内，推崇自动化文化是关键。为此，您需要一种综合的、端到端的方法，以便在整个软件开发生命周期中推广自动化。这个生命周期涉及通过一些操作执行测试驱动开发，比如 IBM Bluemix® Garage Method。有关更多信息，请访问网站。<br><a href="https://www.ibm.com/cloud/garage/" target="_blank" rel="noopener">https://www.ibm.com/cloud/garage/</a></p><h3 id="有界上下文"><a href="#有界上下文" class="headerlink" title="有界上下文"></a>有界上下文</h3><p>开发模型时，请记住识别它的有界上下文，即模型的有效范围。有界上下文是具有明确边界的模型，模型在该边界内是没有歧义的。如果您不在模型周围设置一条边界，最终使用的上下文可能不在您的应用程序内。适合应用程序的某个部分的上下文不得适合另一个部分，即使它们具有相同的名称，而且指向相同的实体。例如，如果您构建一个预约系统，则必须知道客户的基本信息。但是，如果您在账单上下文中有一个账单系统，您可能希望在其中包含客户的联系信息和支付信息，而在预约系统上下文中，不需要该信息。如果您尝试在多个地方重用完全相同的客户模型，可能会在系统中导致不一致的行为。这是一个放入预约系统的上下文中的简单模型，包含一些除客户名称外的行为。</p><p>例如，您可能决定在客户模型上包含某种形式的验证，以确保拥有足够的信息来向他们收账。如果您不够小心，验证可能意外地阻止您使用客户模型安排预约；这不是那您想要的行为。账单系统可能要求客户拥有有效的信用卡，然后才能保存更改。但是，如果缺少信用卡信息，则会阻止您将客户预约信息保存到预约系统中，这是不合理的。</p><p>在这个示例中，您有两个上下文，但它们之间的边界是模糊和重叠的。Eric Evans 在他撰写的图书《领域驱动设计》中说道”模型仅在特定的上下文内有效。因此，最好显式定义应用该模型的上下文。您可以避免损坏该上下文内的模型，将它严格保持在这些边界内，并避免被外部问题分心或混淆。”</p><p>当显示定义了有界上下文后，通常能看到您是否拥有一个尝试扩展到多个上下文中的模型元素。在这个示例中，您希望在预约系统中保持简单的客户视图，而在账单上下文中提供包含联系信息和账单信息的更完整的客户视图版本。在两个不同的类中定义客户的这两个视图，然后将它们放在不同的应用程序中。Eric Evans 建议，通过为每个上下文提供它们自己的团队、代码库、数据库模式和交付管道，让有界上下文保持分离。</p><p>有界上下文的原则在微服务架构中至关重要。可使用这些原则作为指导，正确地确定系统并将其分解为微服务。明确定义有界上下文（意味着业务领域是通过显式边界分离的），有助于推断系统中最终包含的微服务。拥有有界上下文，还有助于正式化不同服务之间的交互，有效且高效地构建它们之间的接口。</p><p>1.通过服务实现组件化<br>传统实现组件的方式是通过库（library），传统组件是和应用一起运行在进程中，组件的局部变化意味着整个应用的重新部署。 通过服务来实现组件，意味着将应用拆散为一系列的服务运行在不同的进程中，那么单一服务的局部变化只需重新部署对应的服务进程。 另外将服务作为组件可以更明确的定义出组件的边界，因为服务之间的调用是跨进程的，清晰的边界和职责定义是设计时必须考虑的。</p><p>即单一服务可以作为一个单独进程存在。</p><p>2.按业务能力来划分服务与组织团队<br><strong>康威定律（Conway’s law）</strong>指出：</p><p>organizations which design systems … are constrained to produce designs which are copies of the communication structures of these organizations.<br>任何设计系统的组织，最终产生的设计等同于组织之内、之间的沟通结构。</p><p>传统开发方式中，我们将工程师按技能专长分层为前端层、中间层、数据层，前端对应的角色为UI、页面构建师等，中间层对应的角色为服务端业务开发工程师，数据层对应着DBA等角色。<strong>事实上传统应用设计架构的分层结构正反应了不同角色的沟通结构</strong>。 而微服务架构的开发模式不同于传统方式，它将应用按业务能力来划分为不同的服务，每个服务都要求在对应业务领域的全栈（从前端到后端）软件实现，从界面到数据存储到外部沟通协作等等。因此团队的组织是跨功能的，包含实现业务所需的全面的技能。 </p><p>近年兴起的全栈工程师正是因为架构和开发模式的转变而出现，当然具备全栈的工程师其实很少，但将不同领域的工程师组织为一个全栈的团队就容易的多。</p><p>3.服务即产品<br>传统的应用开发都是基于项目模式的，开发团队根据一堆功能列表开发出一个软件应用并交付给客户后，该软件应用就进入维护模式，由另一个维护团队负责，开发团队的职责结束。 而微服务架构的倡导者提议避免采用这种项目模式，更倾向于让<strong>开发团队负责整个产品的全部生命周期</strong>。Amazon 对此提出了一个观点：</p><p>You buidl it, you run it.<br>开发团队对软件在生产环境的运行负全部责任，让服务的开发者与服务的使用者（客户）形成每天的交流反馈，来自直接客户端的反馈有助于开发者提升服务的质量。</p><p>4.智能终端与哑管道<br><strong>微服务架构抛弃了 ESB 过度复杂的业务规则编排、消息路由等（即去ESB化）。</strong> 服务作为智能终端，所有的业务智能逻辑在服务内部处理，而服务间的通信尽可能的轻量化，不添加任何额外的业务规则。</p><p>5.去中心统一化<br>传统应用中倾向采用统一的技术平台或产品来解决所有问题。 不是每个问题都是钉子，也不是每个解决方案都是一个锤子。 <strong>问题有其具体性，解决方案也应有其针对性。</strong> 用最适合的技术方案去解决具体的问题，在大一统的传统应用中其实很难做到，而微服务的架构意味着，你可以针对不同的业务服务特征选择不同的技术平台或产品，有针对性的解决具体的业务问题。</p><p>6.基础设施自动化<br><strong>单一进程的传统应用被拆分为一系列的多进程服务后，意味着开发、调试、测试、集成、监控和发布的复杂度都会相应增大。</strong> 必须要有合适的自动化基础设施来支持微服务架构模式，否则开发、运维成本将大大增加（硬件水平跟上软件速度）。</p><p>7.Design for failure<br>正因为将服务独立在不同的进程中后，引入了额外的失败因素。 任何时刻对服务的调用都可能因为服务方不可用导致失败，这就要求服务的消费方需要优雅的处理此类错误。 这其实是相对传统应用开发方式的一个缺点，不过随着一些开源服务化框架的出现，对业务开发人员而言适当的屏蔽了类似的错误处理，不过开发人员依然需要知道对服务的调用是完全不同于进程内的方法或函数调用的。</p><p>8.进化设计<br>一旦采用了微服务架构模式，那么在服务需要变更时我们要特别小心，服务提供者的变更可能引发服务消费者的兼容性破坏，时刻谨记保持服务契约（接口）的兼容性。 对于解耦服务消费方和服务提供方，伯斯塔尔法则（Postel’s law）特别适用：</p><p>Be conservative in what you send, be liberal in what you accept.<br>发送时要保守，接收时要开放。<br>按照<strong>伯斯塔尔法则</strong>的思想来设计实现服务调用时，发送的数据要更保守，意味着最小化的传送必要的信息，接收时更开放意味着要最大限度的容忍信息的兼容性。 多余的信息不认识可以忽略，而不应该拒绝或抛出错误。</p><h3 id="微服务架构应用"><a href="#微服务架构应用" class="headerlink" title="微服务架构应用"></a>微服务架构应用</h3><p>采用微服务架构面临的第一个问题就是如何将一个单一应用拆分为多个服务。 有一个一般的原则是，单一服务提供的功能是可以独立被替换和升级的。 也就是说如果有 A 和 B 两个功能，如果 A 功能发生变化时同时 B 功能也需要变化，那么 A 和 B 这两个功能应该被划在一个服务中。</p><p>微服务架构应用的成功经验近年已越来越多，例如国外的 Amazon，Netflix，国内如阿里都采用微服务架构取得了很多正面的成功案例。 但通过上文所述微服务架构特征看出，其实微服务架构模式有利有弊，需要根据实际的业务、团队、环境进行仔细权衡利弊。 其中的服务拆分带来的额外开发、测试、运维、监控的复杂度，在现有的环境、团队下是否能够很好的支持。</p><p>另外，有人可能会说，我一开始不采用微服务架构方式，而是在单一进程内基于清晰定义的模块化方式，模块之间通过接口调用，到了适当阶段，必要的时候再将模块拆分为服务。 其实这个想法显得过于理想，因为进程内良好定义的接口通常不是很好的服务化接口。 一开始没有考虑服务化的设计方法，那么后期拆分时依然是一个痛苦的过程（改整体架构对一个已成型的产品来说比开发一个新产品还要吃力）。</p><p><strong>难在架构，也赢在架构！</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>正如，Martin Fowler 在其文中所说，微服务架构是否就是企业应用开发的未来，还有待时间的检验。 就目前的情况看，对此我们可以保持谨慎的乐观，这条路依然值得去探索。 实际任何的架构决策都是基于我们不完美的现状做出的，这正是架构取舍的微妙之处，超越任何的方法论。</p><p>在整体式应用程序中，大部分逻辑都部署在一个集中化、单一的运行时环境或服务器中，并在其中运行。整体式应用程序通常很大，由一个大型团队或多个团队构建。采用此方法，各个团队需要花更多精力和统筹安排才能执行更改或部署。</p><p>随着时间的推移，整体式模型中已引入了更好的架构模式，有助于显著提高架构的灵活性。例如，一种著名的模式是模型-视图-控制器 (MVC)，它将应用程序分解为层和合理的组件。这些模式有多种优点，比如更快的初始开发、更简单的应用程序治理，等等。但是，整体式模型也有缺点，尤其是在当今环境中的技术瞬息万变的背景下。（MVC【模型-视图-控制结构的整体式模型】已经不满足当前网络开发的情况了）</p><p>整体式方法可能带来许多挑战，有以下四点：</p><ul><li>庞大的应用程序代码库</li><li><p>庞大的代码库可能给希望熟悉代码的开发人员带来困扰，尤其是团队的新成员。庞大的应用程序代码库可能还会让应用程序开发过程中使用的开发环境工具和运行时容器不堪重负。最终，这会导致开发人员效率降低，可能会阻止对执行更改的尝试。<br>开发人员在进入这个项目业务时，因为是整体式的架构项目，开发人员可能负责的是整个控制层，业务层或者持久层的逻辑，虽然各层的处理逻辑和分类管理做的好的项目容易看得懂，但是各层的代码库随着产品的深入会加上各种功能，导致代码库庞大且凌乱，这就是导致了开发人员的工作重点不是在有效的开发上而是在找代码甚至是理清他们的关系上，开发效率低下也导致无用功过多，也会使开发人员的情绪受到影响。</p></li><li><p>不频繁的更新</p></li><li><p>在典型的整体式应用程序中，大部分（几乎是全部）逻辑组件都部署在单一运行时容器中，并在其中运行。这意味着要更新对某个组件的一处细微更改，必须重新部署整个应用程序。另外，如果需要推广细微但关键的应用程序更改，则需要投入大量精力来对未更改的部分运行回归测试。这些挑战意味着整体式应用程序很难连续交付，这导致部署次数减少，对需要的更改的响应变慢。<br>利用微服务架构后若出现问题则可以单个组件更新部署，不需要整个项目进行维护升级。</p></li><li><p>依赖单一类型的技术</p></li><li><p>对于整体式模型，由于应用更改方面的挑战，以增量方式采用新技术或技术栈开发框架的新版本会变得很困难。最终，整体式架构应用程序通常必须一直使用这一种技术，这最终会阻碍应用程序跟上新的发展趋势。<br>微服务架构利用各项技术优势互补，哪个效率高用哪个。新技术增加的功能可以直接部署在系统上，各组件的技术也可以用不同的语言来实现。<br>甚至是为整个项目整体更换新框架时也会变得容易。</p></li><li><p>可扩展性</p></li></ul><p>可扩展性是整体式架构面临的最大挑战之一。Martin Abbot 和 Michael Fisher 在他们合著图书《可扩展的艺术》中介绍了一种查看系统的可扩展性的有用方式；他们使用了一种三维可扩展性模型或扩展立方体。在此模型中，通过在负载平衡器后运行克隆版本来扩展应用程序称为 X 轴扩展或水平复制。另外两种扩展是 Y 轴扩展（或功能分解）和 Z 轴扩展（或数据分割），Y 轴扩展通过拆分不同实体来实现扩展，Z 轴扩展通过拆分类似实体来实现扩展。由于整体上的凝聚性，典型的整体式应用程序通常只能在扩展立方体的一个维度上扩展。随着生产环境收到更多请求，该应用程序通常采用的垂直扩展方式是添加更多资源供其使用，或者克隆到多个副本来进行响应。这种扩展方式低效且很耗资源。<br>当应用程序达到一定规模时，开发团队必须拆分为更小的团队，每个小团队专注于一个特定的功能区域，各团队彼此独立工作，而且通常位于不同地理位置。但是，由于应用程序的各部分间的自然凝聚性，需要各个团队协力执行更改和重新部署。</p><p><img src="/2018/03/20/分布式01/image001.png" alt="logo"></p><p>使用微服务架构的最重要目的是，解决整体式模型面临的难题。<br>将从应用程序的不同涉众角度，介绍微服务方法如何帮助解决整体式系统的问题。</p><ul><li>对于业务所有者</li></ul><p>作为业务所有者，您希望您的服务适用于新客户和业务需求。但是，在整体式模型中，由于庞大的代码库，为满足业务需求而执行并推广更改的过程会很缓慢。这个过程缓慢的另一个原因是，各个组件和层之间有严格的内部限制和依赖关系。</p><p>依靠传统框架来将各个层和组件整合起来，这样的话各层的关系不仅会受到整体框架的限制，还会让开发周期变得很长。</p><p>微服务架构原则是围绕高灵活性和恢复能力而建立的。这两个特征有助于快速推广更改。这有助于业务所有者更快地收到反馈，调整业务和投资战略，从而让客户满意和提高市场竞争力。</p><p>从资源分配的角度讲，由于团队更小且更专注，所以可以更轻松地测量和可视化效率。然后，业务所有者可以更轻松地制定投资决策，可将资源从低业务影响区域转移到高业务影响区域。</p><ul><li>对于服务管理人员</li></ul><p>作为服务管理团队成员，您希望协调各个团队的管理操作负担更少，以便您可以提高服务的生产力。整体式模型需要做大量的工作。活动之间需要的协调更多，因为整体式应用程序通常拥有庞大的业务范围，以及许多基础架构和操作接触点。因此，对应用程序的每次更改都可能需要不同涉众多次评审和批准。微服务架构推崇利用自助服务，在服务交付管道的每个阶段利用<strong>自动化</strong>。</p><p>这有助于减少服务管理团队的日常管理协调。</p><p>微服务架构中的一个重要原则是高可观察性。高可观察性功能为服务管理团队提供了必要的工具，以便更好地监督系统中或产品中的每个微服务的状态。这有助于提高服务管理效率。</p><ul><li>对于开发人员</li></ul><p>作为加入团队的新开发人员，您希望快速熟悉源代码，以便快速上手并带来成果。<strong>典型整体式应用程序中的代码库很大，可能阻碍您并潜在地延长学习曲线</strong>。对于所有开发人员，庞大的代码库会增加载入开发环境中并运行的负担，从而导致生产力降低。</p><p>庞大的代码库可能让代码评审和其他合作开发活动面临更大压力。此外，在处理更改时，破坏其他功能的风险可能导致开发人员对创新和增强应用程序犹豫不决。然而，微服务更小且更轻量，这可以缩短新开发人员的学习曲线。微服务还可以帮助消除加载和运行的繁重负担，鼓励引入突破性的更改，从而帮助提高生产力和创新水平。</p><p>———————————————更新线—————————————————</p><h3 id="云时代"><a href="#云时代" class="headerlink" title="云时代"></a>云时代</h3><p>为什么现在是采用微服务架构的好时机。</p><ul><li>云环境和产品的激增</li></ul><p>微服务架构体现了使用连续集成和连续部署的许多优势。该架构也引入了新的复杂性，需要一种在构建应用程序的每个步骤中实施自动化的现代方法。例如，从基础架构和治理的角度讲，首先需要一个能动态地快速为服务组建运行时环境的业务连续性基础架构。该环境可能是一个虚拟机、容器等。另外，还需要一种统筹安排和监视服务的高效方式。当今环境中的云平台（比如 IBM Bluemix）可通过其自然的动态性和恢复能力满足此需求。<br>借助可用于各种服务模型的不同云产品，无论是基础架构即服务 (IaaS) 还是平台即服务 (PaaS)，开发人员都可以通过更多选择转变为微服务战略。借助 IaaS 选项，您可以在几分钟内快速组建一台机器，而且可以将基础架构配置打包到一组脚本中，以便根据需要自动化该流程。如果您不想接触基础架构级别的复杂性，也可采用平台级选项，采用不同的语言和服务的形式来快速打包，然后根据意愿包含和启动微服务。<br>IBM Bluemix 是这些平台的一个示例。IBM Bluemix 有许多适合使用云技术构建微服务的服务，比如 IBM 容器、消息中心、日志记录、监视和其他技术。Bluemix 使开发人员能够快速创建、部署和管理他们的云应用程序，为简化操作、确定安全策略和管理系统中微服务的健康提供关键基础。</p><ul><li>工具的可用性和成熟性</li></ul><p>除了云基础架构可为微服务战略的采用所提供的动态性和恢复能力，拥有全面的工具也是采用微服务战略的关键需求。微服务工具在不断演变和进步。在当今环境中，开发人员有许多选择，他们可以使用一组合适的工具来实施其微服务战略，比如日志工具组合、监视工具组合、服务注册表或容器化技术。这些先进工具可帮助解决微服务架构所引入的挑战，以便更有效地交付、管理和统筹安排服务。<br>图展示了基于微服务架构而构建的 IBM Watson™ 云服务的完整组合示例。这种革命性架构有云技术、一组全面的工具及敏捷流程提供支持。</p><p><img src="/2018/03/20/分布式01/image002.png" alt="logo"></p><p>该架构包含多个主要的技术组合：<br>DevOps<br>每个 Watson 云服务在开发后，都会在一个不可变的虚拟机中容器化，然后通过明显的 DevOps 流程自动部署到 IBM SoftLayer 云基础架构上。微服务架构的典型模式（比如服务发现、API 网关等）是通过 IBM 独有的和开源的技术来使用的。然后，可以在 IBM Bluemix 平台上公开这些服务。<br>Elasticsearch、Logstash、Kibana (ELK) 组合或 Elastic 组合<br>Elk 组合是该系统的日志工具组合，包含一组工具来捕获日志，并将其存储在一个强大的、集中化的、可搜索的日志数据库中。有关更多信息，请查阅 elastic 网站。<br>监视工具组合<br>展示了一组工具，它们可从一个中央仪表板监视整个系统，包含一种通知机制，以便基于特定事件来发送提醒。</p><h2 id="从整体式应用程序向微服务的转变"><a href="#从整体式应用程序向微服务的转变" class="headerlink" title="从整体式应用程序向微服务的转变"></a>从整体式应用程序向微服务的转变</h2><ul><li>虚构公司 A 的业务问题</li><li>虚构公司 A 是一家电子商务公司，它使用了一个名为 Customer Order Service 的基于 Java EE 的传统 Web 应用程序来提供在线购买服务和运营业务。尽管该应用程序能很好地处理业务，但公司 A 已开始努力响应新的业务需求。这些需求包括：</li></ul><p>接触使用移动设备的客户<br>基于对客户在互联网上的个人行为的洞察，改善客户体验<br>扩展基础架构，以便处理来自新客户和现有客户的更多请求保持较低的 IT 成本<br>以及其他需求<br>目前的客户订购服务应用程序的设计不支持在业务领域中执行更改，而且无法应用新技术来加速创新。图中介绍了当前的整体式应用程序的逻辑架构概述。</p><p><img src="/2018/03/20/分布式01/image003.png" alt="logo"></p><p>公司 A 希望改变客户订单服务应用程序，以便从业务和技术角度促进和更好地处理更改，它拥有一些主要的业务需求：</p><p>新系统必须是经过进化的，意味着它必须能灵活地处理更改。<br>在将流量从当前系统转移到新构建的系统的过程中，不允许宕机。<br>新应用程序必须能基于发送给系统的有效负载来按需或自动扩展，以便应对动态的购物行为模式。<br>新系统必须支持利用新兴技术来促进创新。</p><p>采用微服务来实现一种革命性架构：</p><p>采用微服务架构的主要动机是，解决很难更改的传统整体式架构的问题。微服务方法支持对架构的每个组成部分执行更改。对于业务需求，公司 A 非常适合在构建新系统时采用微服务架构。</p><p>公司 A 应用最佳实践和模式将现有的整体式应用程序转变为更加革命性的架构，以期最终将应用程序迁移到微服务架构上。<br>执行以下主要步骤和活动：</p><ul><li>演化战略<br>要拥有一种转型案例分析中的整体式应用程序的合适战略，必须发现和考虑不同的模式和建议实践。</li></ul><p>识别要转变为微服务的候选功能<br>在这一步中，选择应用程序的相对较小的组件或功能片段。从这些功能片段，可配置新微服务来让这些片段更有利于经常或渐进式的更改。</p><ul><li><p>数据访问模式<br>因为数据是 IT 系统中最重要的资产，所以一个关键步骤是在转变为微服务架构的过程中采取正确的数据访问方法。</p></li><li><p>安全和治理<br>“安全和治理”将介绍如何在更加分布式的新模型中管理应用程序的组件，以及如何处理安全挑战。</p></li><li><p>性能和可扩展性<br>解决整体式应用程序的可扩展性问题时，微服务架构（拥有更多分布式特征）带来了性能挑战。</p></li><li><p>DevOps 和自动化<br>自动化是让微服务方法成为可能的推动因素。</p></li></ul><p>重点介绍了微服务的重要概念、特征以及它为何对现代软件应用程序的开发如此有吸引力的原因。最后，通过一个示例简单的描述了从整体应用程序向微服务的转变。目前为止，相信您已经对微服务有一个初步的了解。下一部分将更深入的介绍如何在 Java 中创建微服务。</p><p>内容转自 Evolve the Monolith to Microservices with Java and Node （IBM产品devoloper开发红皮书）</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;微服务是什么？&quot;&gt;&lt;a href=&quot;#微服务是什么？&quot; class=&quot;headerlink&quot; title=&quot;微服务是什么？&quot;&gt;&lt;/a&gt;微服务是什么？&lt;/h1&gt;&lt;p&gt;谈及微服务架构，2016年应该是软件业微服务爆发的元年，微服务到底是什么？&lt;br&gt;观察现有的软件业，使用单独一款开发语言区开发一款较为全面的产品很少，大多数都是各种语言编写的功能模块进行组装成完整的业务模型，&lt;br&gt;各语言效率优势互补。&lt;br&gt;微服务架构所强调的特点就是业务系统需要彻底的组件化与模块分割，原有的单个业务系统分割成多个小应用，每个小应用可以进行独立开发，管理，运行和测试，甚至连每个产品的前端（UI加结构），服务端（控制层，逻辑层和持久化层），数据库都是完全独立的产品，通过微服务架构将每个小应用进行整合，交互与集成，每个小应用不仅能够自己完全独立的功能，还可以运行其他小应用的服务，同时也将自己作为可供利用的服务对象。&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="Dubbo" scheme="http://yoursite.com/tags/Dubbo/"/>
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>创业之路--关于风险投资</title>
    <link href="http://yoursite.com/2018/03/19/fengtou/"/>
    <id>http://yoursite.com/2018/03/19/fengtou/</id>
    <published>2018-03-19T04:39:15.000Z</published>
    <updated>2018-03-19T04:54:02.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于风投泄密及其保密协议"><a href="#关于风投泄密及其保密协议" class="headerlink" title="关于风投泄密及其保密协议"></a>关于风投泄密及其保密协议</h1><p>保密协议就属于防君子不防小人,特别是在商业模式、概念以及技术在早期还很不具象的时候(这恰恰都是初创公司所面临的情况),保密协议起到的作用就更小,因为连保护的标的都不清楚,总不能说保护一个头脑中的idea吧?即使起到作用,通过法律手段花上无数的时间和精力去索赔并成功,损失的时间和精力放在自己的梦想和创业上,是不是会更加划算?天使投资人最大的价值就是,给钱不捣乱,同时需要的时候提供不太计较的支持.</p><a id="more"></a><p>所以题主关心的方向不对,应该更关注如何找到靠谱的天使投资人,而不是在这种ROI极低的地方选择如何去保护自己的利益。如同找老公过日子,越是天使投资越容易走得远成为长期的婚姻关系,关注点更多在于如何选对人,而不是如何利用拉链守住门户.</p><p>而且还有一个基本原则,如果在天使阶段,一个潜在投资人对于你的技术绌节和实现方式如此关注,而对于创始人的人品以及公司的远景却不那么在乎。是不是有点熟悉的感觉,上来就问你的银行存折、小区档次等等?</p><p>保密协议的注意事项1、保密信息的范围从披露方来看，只要是自己提供给对方的非公知信息，都可以纳入保密信息的范围，包括关于自身的保密信息，也包括自己获准披露的第三方保密信息。另一方面，也不能范围过宽延伸到接受信息方已有或者自行开发的信息以及无关第三方披露等原因造成公开的信息，尤其是保密期限比较长的时候，接受信息方也可能因为各种现实原因无法承受过重的保密限制。</p><p>2、商业秘密上文提过，并非所有的保密信息都能构成商业秘密，商业秘密的保护须权利人采取保密措施，例如：技术措施以及要求接触到商业秘密的员工签署保密协议的法律措施等。商业秘密和普通的保密信息需要区分开来。针对保密信息双方可以商定一个有限的持续时间（很多信息因为技术发展几年后就根本没有保密的意义了），期间届满后则不再负有保密义务；但商业秘密则不能轻易地披露给对方，披露给对方也要注意保密措施，并且不受保密期限的限制。</p><p>3、知识产权专利等知识产权与商业秘密的保护方式各有利弊，此处不再展开。有些创意、方法和流程可能无法获得知识产权的保护，所以只能作为商业秘密并通过保密协议等方式防止保密信息进入公知领域。即便是能够申请专利的技术或方案，也需要在申请专利前注意保密，并与接触者签署保密协议，防止被公众所知破坏其新颖性，导致无法申请专利。</p><p>4、保密信息的使用限制保密协议不仅仅限制信息接受方不得对外披露保密信息，而且需要限制信息接受方对保密信息的使用范围和目的。一方面，信息接受方应当仅限于向项目合作过程中确需了解保密信息的人群披露，还要限制信息接受方使用于讨论、评估或依据各方协议约定实施项目合作之外的目的，<br>例如：不得因项目之外的目的擅自使用保密信息。此外，如果披露具有知识产权的内容则需要明确，依据保密协议进行的披露与知识产权的许可使用不同，为签约各方项目合作之目的披露给对方，并不意味着给予了对方知识产权的使用许可。结语保密协议仅仅是保护公司保密信息的一种常见手段，创业公司还需要提高保密意识，并结合技术手段以及知识产权等各种方式，更全面地保护自己来之不易的创造性成果。<br>如果运用得当，即便是创业公司也能有效对抗巨头“友商”窃取自己的劳动果实。</p><p>在《要求投资人签署保密协议 能否保护你的商业秘密》这篇文章中，我曾经表示，通过要求投资人签署保密协议的方式，不能从根本上保护自己的商业秘密。<br>那创业者在融资时，还需要与投资人签署保密协议吗？<br>答案是肯定的。也就是说，保密协议还是要签的。<br>既然它不能从根本上解决问题，那在这里为什么还要建议创业者与投资人签署保密协议呢？<br>因为尽管它不能从根本上解决问题，但毕竟能起一定的作用。而对有些投资人，这点作用就已经足够。<br>不同的投资人，愿意承担的违约风险不同。如果对方可以承受的违约风险幅度很大，那单靠一纸保密协议，不能引起他们足够重视，自然也约束不住他们。这时候，就要附加其他手段。但如果对方可以承受的违约风险幅度很小，那这一纸保密协议就能很好的约束对方。<br>同一份协议，在不同的投资人眼里分量不同，自然对其影响和制约能力也不同。<br>在《周永信说融资泄密17：Term Sheet前投资人不愿签署保密协议的原因及例外》这篇文章中，我也曾提到，投资人是不愿意签署保密协议的，但那指的是在Term Sheet之前。<br>真正到了谈判Term Sheet阶段，甚至尽职调查阶段，投资人是不会拒绝签署保密协议的。因为这是一种合理且常规的要求。到了这一阶段，如果创业者还不要求签署保密协议，投资人甚至会认为创业者不够成熟。因为保密意识是企业成功的必要要素之一，没有投资人愿意投资一个保密意识淡薄的创业者。<br>所以不管是为了保护自己，还是为了取信于投资人，创业者都要要求投资人签署保密协议。只是，要掌握好时间点。</p><p>那么，投资人看重的是什么？<br>第一，商业案思路清晰，市场回报设计方案路径清楚，言之成理，<br>第二，最最重要的：执行团队。换句话说，绝大多数投资人看重的，不是案子，而是能把案子做成买卖的创业团队！所以，千万别想着拿几张天马行空的A4纸去打动别人把几千万给你，他们看都不会看，即便里面写了九阴真经。但如果这纸上的方案，你已经建立起了自己稳定的核心团队，而且靠这个团队已经在小规模范围内取得了一定的商业成功，现在是需要资金扩大规模，那么，加上你的好点子，投资人对你是有兴趣的。</p><p>是否需要签订保密协议,主要还是要具体评估下题主展示或向对方提供的内容是什么。<br>如果是机变的数据资料或者一些数据模型等,付出大量的人力、物力的智力成果,可以达到商业秘密了<br>众所知悉、能芾来经济利益,具有实用性并采取保密措施的技术信息和经营信息)<br>还是非常有必要签署保密协议的。虽然有人说保密协议是防君子不防小人,但有保密协议在,毕竟会对一部分投资人产生威慑,而且后续如果有纠纷,诉诸司法,保密协议毕竟要求对方承担的一个法律文件和基础<br>如果只是一些创意或电子,毕竟法律不保护创意,签与不签,并无实质性区别。</p><h1 id="家装风投"><a href="#家装风投" class="headerlink" title="家装风投"></a>家装风投</h1><p>经纬中国，合力投资，红杉资本，IDG资本，沸点资本，创湃资本，稳国基金，创吧投资，58集团，梧桐树资本，红星美凯龙，北辰星，<br>天使湾，印尼力保集团，华耀资本，氪空间，中骏基金等等</p><p>基本涵盖种子轮，天使轮，Pre-A轮，A轮，B轮，C轮，C+轮以后，。。。，F轮，上市前。</p><p>天使投资人需要做进一步的网络爬虫</p><p>不局限于拿国内资本投资，可考虑境外投资或者联合投资形式</p><p>A+轮后可考虑资本市场，多家融资</p><p> VC风险投资(venture capital)</p><h1 id="轮次融资"><a href="#轮次融资" class="headerlink" title="轮次融资"></a>轮次融资</h1><p>同时也是解读资本与企业发展之间关系的学问。</p><h1 id="种子轮"><a href="#种子轮" class="headerlink" title="种子轮"></a>种子轮</h1><p>种子投资极具风险，大多数种子投资者明白70%的初创企业投资最终都会失败。但是，他们也明白，只需一个成功的初创企业，便可带来大量的财富。因此，种子投资者明白，在寻找成功企业的过程中，他们需要与企业“风险共担”，更重要的是，要避免“FOMO”的陷阱，即“错过”下一个取得巨大成功的初创企业[2]  。<br>由于更多的种子投资者承担更多的风险，因此早期的种子融资变得更加普遍、丰富，也更容易获得。尤其在许多初创企业明白快速进入市场的重要性之后，种子融资的易得性和不断增长的资金池对初创企业来说无疑是好消息。具有讽刺意味的是，这种发展也给初创企业带来了严重的问题。<br>种子融资后，会对初创企业创始人进行早期的估值、收入和客户标准检查，并规定达成业绩的严格时限。如果初创企业过早进入种子融资，在接下来的轮次融资阶段，如A轮融资时，则会遇到严重的挑战。轮次融资通常更加重要和复杂，因此如不能满足标准，会给接下来的投资人带来强烈的负面信息。</p><p>在融资中，这一般被称之为“种子轮”投资，它是指公司发展的一个阶段。在这个阶段，公司只有创意却没有具体的产品或服务，创业者只拥有一项技术上的新发明、新设想以及对未来企业的一个蓝图，缺乏初始资金投入。创业者在这一阶段寻找投资的时候，最需要的讲清楚的是“我要做什么”，重要的是要给投资人画好你想象中的“大饼”。<br>一般来讲，因为前期资金需求相对较小，也或许是创业者大都抱有“先做出一点成绩或者先做出个样子”的想法，种子期的所需要的资金都是创业者自筹或者通过亲朋好友来筹集。当然，也有种子期投资人和投资机构。<br>注意，种子期的投资资金一般在10万-100万RMB左右。当然，也有破例。比如，最近VR比较火，森声科技在3月就宣布获得了数百万元的天使投资。森声科技想做的是，基于双耳录音(Binaural recording)技术，为广大 VR 影视团队提供一套简便的全景声录制和播放解决方案。</p><p>种子期的项目，往往只有一个idea和初始团队（有些只有一两个创始人），idea能不能转换为一个make sense的business，具有高度的不确定性，需要通过一段时间的尝试，对idea背后的各种假设进行验证，从而探索到真正可行的方向。在此过程中项目的方向和内容随时有可能面临调整，而且项目一没有历史，二缺乏连续性，唯一稳定的、可供投资者参考的因素就是团队（而且主要是创始人），因此种子期的投资主要看人。人是极其复杂的，要想对一个人作出判断就必须深入了解他、和他打交道。由于这个过程依赖大量的经验和直觉，很难进行理性的分析，因此履行这个任务、做这个决策的，一般都是个人投资者。这也是“天使”这个称号的来历。此外，由于尝试和探索所需的资金量一般不是太多，个人投资者出得起，且项目越早期风险越大，所以天使投资的金额一般也较小，一般都在500万（人民币）以下。</p><p>—————————–<strong>破土期</strong>———————————————————</p><h1 id="天使轮"><a href="#天使轮" class="headerlink" title="天使轮"></a>天使轮</h1><p>天使轮是指公司有了产品初步的模样，商业模式也已初步形成，同时积累了一部分的核心用户。投资来源一般是天使投资人、天使投资机构。相比之后的融资，这个时期想要拿到融资还是相对容易的，投资人主要看的是创业团队和创业方向。<br>对于成熟理性的天使投资机构来说，种子期和天使期项目在阶段上的差别不大，区别最大的就是在融资金额上。因此，也有人会把这种初创公司的融资阶段称为“种子天使”。</p><p>天使轮，即天使投资（Angel Investment），是指个人出资协助具有专门技术或独特概念而缺少自有资金的创业家进行创业，并承担创业中的高风险和享受创业成功后的高收益，或者说是自由投资者或非正式风险投资机构对原创项目构思或小型初创企业进行的一次性的前期投资。天使投资是风险投资的一种特殊形式。</p><p>天使轮的投资资金额度一般在100万RMB到1000万RMB左右。上限为2000万左右。<br>2015年12月，刚刚成立半年多的美国P2P保险公司Lemonade获得红杉资本1300万美元的种子轮投资。Quartz称，这是红杉历史上最大的种子轮投资之一。</p><p>种子、天使轮，顾名思义就是很早期的公司，可能只是一个idea、没有实际的走出去，这个时候VC机构，一般会看创业者的背景、愿景，但最重要的还是个人背景，如果你是一个已经很牛的人，那你的天使轮估值肯定会很高，比如瓜子二手车天使轮就能拿到6000万美元的融资，就是因为杨浩涌以前有过成功创业的经验，即使他做出渣来也会有人投资的。</p><p>天使投资也属于风险投资的范围，只是更为早期，风险更大，同时回报也可能更高。天使投资的来源更广泛，早年最常见的三类天使投资人，3F，family，friend，fool。</p><p>随着越来越多的互联网公司上市，大量掌握大笔资金，熟悉上市流程，和投资机构关系密切，了解行业动向，具有大量人脉的前互联网公司高管们开始成为专业的天使投资人，他们是最合适的天使投资人选，也会有相当多的好项目被他们挖掘获得成长。</p><p>同时，天使机构化的趋势也开始明显，一些新的天使投资开始就以正规军的方式作战，一些以往A轮起投的风险投资机构也开始向天使扩展，所以天使投资和风险投资的界限也开始模糊，天使和VC主要用在界定投资金额的多少，比如通常天使是100-200万人民币，A轮是100-200万美金，B轮是500-1000万美金，等等，但是也并不确定，有人天使就上千万美金了。</p><p>除了资金多少的区别，我通常会按照项目的状态来界定项目的阶段以及投资款的用途。天使阶段，商业模式还没有建立，钱是不够烧的，天使投资的钱更主要用来搭建团队，大量试错，为A轮较大资金进入，具有可复制的商业模式的基础做准备，要能证明后续资金可以高效的使用才值得引进新的投资，也才容易拿到后续的风险投资。（当然，这个市场上充满了反例和个案）</p><p>成长期则似乎没有公认的定义，我个人的理解是当一个项目经历过种子期的摸索，探索到一条有较大可行性的道路时，便进入到成长期。可以说种子期是纸上谈兵，成长期则经过了实践，从市场的反应中看到了希望。企业进入成长期以后，战略基本成型，准备着手投入资源（其中资金是关键资源）去实现这个战略。这个时候投进去的，就可以算作是VC了。所以VC是企业战略初步成型以后用以支撑企业去实施战略的投资。此时企业刚刚在市场上取得一些成绩，或者看到了一些成功的苗头，但企业自身的资源不足以支撑它，需要引进外部的资源。对投资者而言，企业战略所隐含的关键性的假设通过市场已经有所验证，此时可以对项目进行理性的分析，并能够对面临的风险进行相对准确的评估。这就有了机构化投资的基础，也即实际的出资人可以委托专业的投资人士进行操作并对投资人士实施监督，从而在投资领域产生了委托－代理关系；另一方面，这个阶段企业需要的资金量相对比较大，如果由个人投资者投资将很难分散风险，因此投资的机构化也成为必然。因此，VC一般都是以基金的方式实行机构化运作的，投资额一般在千万量级。</p><p>天使的话，我喜欢你，看得起你， 相信你，就可以了。看中的可能只是被投资人的某个闪光点而已。</p><p>天使投资无疑是“单个项目的回报”最高的。早期项目估值低，一旦项目成为了独角兽，百倍千倍的回报完全可以实现。一版情况下项目如果没有5倍、10倍的回报，都不好意思拿出来和同行说。但是对应风险也是非常高的。比如，天使投资人一年投10个项目，其中有9个血本无归，只靠成功的那个项目赚了百倍收益来弥补9个的亏损，这种情况也是时有发生。VC和PE投资随着公司估值不断上升，单个项目的回报倍数越低，相对投资成功的概率会比天使投资高不少。</p><p>所以天使轮也被称为独角兽投资。</p><h1 id="Pre-A轮"><a href="#Pre-A轮" class="headerlink" title="Pre-A轮"></a>Pre-A轮</h1><p>按照正常的融资进程，下一轮的融资应该是是A轮融资。但是，有的公司会增加一轮融资：Pre-A轮。</p><p>Pre的意思是前期，Pre-A就是A轮之前的融资。增加这轮融资的原因是多方面的，创业公司在估值不理想;资金困难，但又没有达到A轮阶段的规模，以上这些情况都有可能。Pre-A可以看作一个缓冲阶段，可以让创业者资金压力缓解，也可以让新的投资人进来。</p><p>———————————<strong>天堑期</strong>—————————————————————–</p><h1 id="A轮"><a href="#A轮" class="headerlink" title="A轮"></a>A轮</h1><p>A轮，其实A轮也是初创公司，很多有资历、有人脉的，通过自己或创始团队搞定了天使轮，真正向VC拿钱的时候是A轮，A轮公司特征是已经有了产品原型，可以拿到市场上面对用户了，但基本还没有收入或者收入很小，类似的公司有小米、平安好医生等，都是有产品了拿到了A轮，但公司还是不盈利；这个时候投资人还是更看重创业者资历背景，但这时候也会看些市场前景，以及公司的愿景了。</p><p>在A轮融资阶段，创业公司的产品已经基本成熟，产品上线或者服务已经正常运作一段时间，并有完整详细的商业及盈利模式。另外，创业公司在行业内拥有一定地位和口碑，但是还处于亏损的状态，有诱人的前景。A轮的投资资金额度一般在1000万RMB到1亿RMB左右。</p><p>2015年12月，58到家宣布与阿里巴巴，平安，KKR完成了A轮融资协议的签署，58到家将以超过10亿美金的估值融资3亿美金。据说，这是互联网史上最巨额的A轮融资。<br>当然，从天使到A轮是很多创业公司很难踏出的一步。在这个时期，是考验创业公司的产品、商业模式、盈利模式和创业团队等各个方面的阶段。如果一个环节出现问题就可能导致一个项目的失败或者说创业失败。</p><h1 id="B轮"><a href="#B轮" class="headerlink" title="B轮"></a>B轮</h1><p>创业公司经过一轮烧钱后，获得了较大发展。甚至一些公司开始盈利，盈利模式趋于完善，可能需要推出新业务、拓展新领域。资金来源一般是大多是上一轮的风险投资机构跟投、新的风投机构加入、私募股权投资机构加入。投资资金额度一般在2亿RMB以上。</p><p>———————————<strong>换血期</strong>————————————————————————</p><h1 id="C轮"><a href="#C轮" class="headerlink" title="C轮"></a>C轮</h1><p>到达C轮融资的时候，创业公司又会遇到一个瓶颈。<br>这时公司已经非常成熟了，离上市不远了。这轮除了拓展新业务，讲讲“生态”，就要开始准备上市了。资金来源主要是私募股权投资，有些之前的VC也会选择跟投，投资资金一般在10亿RMB左右。<br>大部分公司一般C轮后就会上市，但也有公司选择融D轮，甚至更多轮的融资。<br>这些需要更多轮融资的公司大部分是其本身的业务所决定的，有的项目需要大量的烧钱，过早上市就不符合这类公司的发展战略，最为形象的例子就是滴滴了，滴滴由于烧钱补贴，现在已经G轮了，还在融资。</p><h1 id="C-轮–至死亡轮"><a href="#C-轮–至死亡轮" class="headerlink" title="C+轮–至死亡轮"></a>C+轮–至死亡轮</h1><p>简单来说就是无数的资本融入。</p><h1 id="IPO期"><a href="#IPO期" class="headerlink" title="IPO期"></a>IPO期</h1><p>完成以上这些融资阶段后，公司就可以上市了。<br>上市之前第一件事就是IPO。<br>IPO(Initial Public Offerings)即为首次公开募股，是指一家企业或公司 (股份有限公司)第一次将它的股份向公众出售(首次公开发行，指股份公司首次向社会公众公开招股的发行方式)。只有首次公开上市完成后，公司才可以申请到证券交易所或报价系统挂牌交易。IPO需要经过多个环节的严格审核。<br>以上，就是一家公司从创立初到上市的全过程。</p><h1 id="天使投资、VC-以及-PE-的区别是什么？"><a href="#天使投资、VC-以及-PE-的区别是什么？" class="headerlink" title="天使投资、VC 以及 PE 的区别是什么？"></a>天使投资、VC 以及 PE 的区别是什么？</h1><p>VC即风险投资，PE即私募股权</p><p>回答这个问题,需要看一下私募股权基金的发展历史,以及在PE这个大概念里产生的V和 Angel</p><p>私募股权基金,是伴随着上世纪七八十年代的并购潮起来的概念,可以看做一个替代资本市场,为<br>需要资本或者想岀手资产的企业提供类似股票市场和银行信贷功能的一种金融产品</p><p>私募股权基金,最早从事的就是兼并收购,随看市场的变化,老牌的PE基金,比如黑石,KKR<br>在随时调整并改变其投资策略,但是,这些老的PE基金在折腾纳贝斯克,折腾UCAR,折腾轮轴制<br>造公司的时候,他们亻脑子里想的是现金流状况,是持续盈利能力和稳定的偿债能力</p><p>于是,这些老PE和他们所实际控制的传统企业的光芒,被来自硅谷的人和他们背后的资本力量所遮<br>挡了,而VC和天使们的故事,要从1995年4月 Netscape的IPO开始谈起。</p><p>对于黑石和KKR来说,像网景这样 Pre ipo收入只有1600万美元,净亏损430万美元的公司能上市<br>简直就是荒唐的事情,但来自硅谷的另类PE——VC们告诉黑石,新世纪,投资者会对那些用新技<br>术实现高成长的公司充满信心。于是,传统金融领域闻所未闻的IPO大批出现,包括:雅虎<br>Amazon甚至包括 Google。</p><p>买股票,不用看盈利水平,不用看财务报表,来自西海岸的投资者们一次又一次抽打华尔街那些穿<br>看笔挺西装的人们的脸。一个又一个天价的IPO,让华尔街的PE们开始反思传统并购和私募股权融<br>资创造的资本价值是否还有没有意义。</p><p>时,美国的PE团伙集中在曼哈顿,而∨C和天使们则聚集在苹果的老家帕拉奥图。PE们每天打看<br>爱马仕领带,而VC们则穿看和乔布斯一样的衣服到处瞎比溜达,找他们心中无需看财务报表,只看<br>技术和团队的下一个网景或者亚马逊。</p><p>如果说PE们考的是财务模型和数学分析,那V们靠的就是对技术领先性和市场占有率的赌局。事实<br>证明,西海岸的∨C们比曼哈顿的那帮老头更讨人喜欢。黑石,KKR们动辄几百亿的并购,也敌不过<br>西海岸一个又一个高科技上市公司的造富神话。</p><p>那么,说完了历史问题,针对题主的可题,讲点更直接的东西</p><p>1.PE更关注的是财务数据,现金流状况,以及各种极限环境下的损失测算,因此PE失败的概率较<br>小,但暴富的概率也不大<br>2.VC需要关注的则是产品本身,市场潜力和社会价值,要准确的洞察历史的演进和应用的趋势,并<br>成为下一个风囗里的猪<br>3.天使更需要准确的洞察趋势,以及赌对一个产品或团队<br>上世纪末,因为互联网和高科技行业的譟动,伴随看大批高科技企业的IPO,一大批VC和天使基<br>金就此崛起。</p><p>但,VC和天使们所面对的行业趋势不可预知性和极大地投资风险,是他们相对PE最大的区别所在<br>要了解vc和天使的区别,就必须要了解他们的起源和PE的发展历史,以及几个重要的历史变革<br>vc和天使的投资理念,孬资风格都是从我讲的这些历史里演化而来的。</p><p>VC和PE的发展时间较长，资金来源比较丰富，高净值个人、专业风险基金、杠杆并购基金、战略投资者、养老基金、保险公司。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于风投泄密及其保密协议&quot;&gt;&lt;a href=&quot;#关于风投泄密及其保密协议&quot; class=&quot;headerlink&quot; title=&quot;关于风投泄密及其保密协议&quot;&gt;&lt;/a&gt;关于风投泄密及其保密协议&lt;/h1&gt;&lt;p&gt;保密协议就属于防君子不防小人,特别是在商业模式、概念以及技术在早期还很不具象的时候(这恰恰都是初创公司所面临的情况),保密协议起到的作用就更小,因为连保护的标的都不清楚,总不能说保护一个头脑中的idea吧?即使起到作用,通过法律手段花上无数的时间和精力去索赔并成功,损失的时间和精力放在自己的梦想和创业上,是不是会更加划算?天使投资人最大的价值就是,给钱不捣乱,同时需要的时候提供不太计较的支持.&lt;/p&gt;
    
    </summary>
    
      <category term="创业之路" scheme="http://yoursite.com/categories/%E5%88%9B%E4%B8%9A%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="风险投资" scheme="http://yoursite.com/tags/%E9%A3%8E%E9%99%A9%E6%8A%95%E8%B5%84/"/>
    
      <category term="VC" scheme="http://yoursite.com/tags/VC/"/>
    
      <category term="融资" scheme="http://yoursite.com/tags/%E8%9E%8D%E8%B5%84/"/>
    
  </entry>
  
  <entry>
    <title>google-Google Protocol Buffer</title>
    <link href="http://yoursite.com/2018/03/15/google-tech00/"/>
    <id>http://yoursite.com/2018/03/15/google-tech00/</id>
    <published>2018-03-15T12:46:01.000Z</published>
    <updated>2018-03-16T13:56:51.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Google-Protocol-Buffer"><a href="#Google-Protocol-Buffer" class="headerlink" title="Google Protocol Buffer"></a>Google Protocol Buffer</h1><p>什么是 Google Protocol Buffer？ 假如您在网上搜索，应该会得到类似这样的文字介绍：<br>Google Protocol Buffer( 简称 Protobuf) 是 Google 公司内部的混合语言数据标准，目前已经正在使用的有超过 48,162 种报文格式定义和超过 12,183 个 .proto 文件。他们用于 RPC 系统和持续数据存储系统。<br>Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API。<br>或许您和我一样，在第一次看完这些介绍后还是不明白 Protobuf 究竟是什么，那么我想一个简单的例子应该比较有助于理解它。</p><p><img src="/2018/03/15/google-tech00/p1.png" alt="logo"></p><a id="more"></a><p>移动应用客户端与服务器之间的通信协议,目前比较主流的有Facebook的Thrift,腾讯的JCE,以及Google的ProtocolBuffer(以下简称protobuf),本文主要介绍protobuf基本概念,协议解析,以及在Android中的应用实践。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>一种 结构化数据 的数据存储格式（类似于 <code>XML、Json</code> ）,用于网络世界的数据交换</p><p>Google 出品 （开源）<br>Protocol Buffer 目前有两个版本：proto2 和 proto3<br>因为proto3 还是beta 版，所以本次讲解是 proto2</p><p>Protobuf是一种灵活高效的,用于序列化结构化数据的机制,类似于XML,但比XML更小,更快,更简单。Protobuf序列化为二进制数据,不依赖于平台和语言,同时具备很好的兼容性。</p><p>通过将 结构化的数据 进行 串行化（序列化），从而实现 数据存储 / RPC(Remote Procedure Call Protocol远程过程调用协议) 数据交换的功能：</p><p>序列化： 将 数据结构或对象 转换成 二进制串 的过程<br>反序列化：将在序列化过程中所生成的二进制串 转换成 数据结构或者对象 的过程</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>传输数据量大 &amp; 网络环境不稳定 的数据存储、RPC 数据交换 的需求场景</p><p>如 即时IM （QQ、微信）的需求场景</p><p>在 传输数据量较大的需求场景下，Protocol Buffer比XML、Json 更小、更快、使用 &amp; 维护更简单！</p><h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><h3 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h3><h3 id="OSI-RM协议模型"><a href="#OSI-RM协议模型" class="headerlink" title="OSI/RM协议模型"></a>OSI/RM协议模型</h3><p>说到GPB（Google protocol Buffer）通过序列化与反序列化来进行数据传输，那么我们来聊聊序列化的问题。</p><p>序列化 &amp; 反序列化 属于通讯协议的一部分<br>通讯协议采用分层模型：TCP/IP模型（四层） &amp; OSI 模型 （七层）</p><p>ISO/OSI的参考模型共有7层，由低层至高层分别为：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><p>各层功能分别为：</p><p>（1）物理层</p><p>提供建立、维护和拆除物理链路所需的机械、电气、功能和规程的特性；提供有关在传输介质上传输非结构的位流</p><p>及物理链路故障检测指示。在这一层，数据还没有被组织，仅作为原始的位流或电气电压处理，单位是比特。</p><p>（2）数据链路层</p><p>负责在两个相邻结点间的线路上，无差错地传送以帧为单位的数据，并进行流量控制。每一帧包括一定数量的数据</p><p>和一些必要的控制信息。与物理层相似，数据链路层要负责建立、维持和释放数据链路的连接。在传送数据时，如</p><p>果接收点检测到所传数据中有差错，就要通知发方重发这一帧。</p><p>（3）网络层</p><p>为传输层实体提供端到端的交换网络数据传送功能，使得传输层摆脱路由选择、交换方式、拥挤控制等网络传输</p><p>细节；可以为传输层实体建立、维持和拆除一条或多条通信路径；对网络传输中发生的不可恢复的差错予以报告。</p><p>网络层将数据链路层提供的帧组成数据包，包中封装有网络层包头，其中含有逻辑地址信息——源站点和目的站点</p><p>地址的网络地址。</p><p>（4）传输层</p><p>为会话层实体提供透明、可靠的数据传输服务，保证端到端的数据完整性；选择网络层的最适宜的服务；提供建</p><p>立、维护和拆除传输连接功能。传输层根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间提</p><p>供建立、维护和取消传输连接的功能，并以可靠和经济的方式传输数据。在这一层，信息的传送单位是报文。</p><p>（5）会话层</p><p>为彼此合作的表示层实体提供建立、维护和结束会话连接的功能；完成通信进程的逻辑名字与物理名字间的对应；</p><p>提供会话管理服务。</p><p>（6）表示层</p><p>为应用层进程提供能解释所交换信息含义的一组服务，即将欲交换的数据从适合于某一用户的抽象语法，转换为</p><p>适合于OSI系统内部使用的传送语法，提供格式化的表示和转换数据服务。数据的压缩，解压缩，加密和解密等</p><p>工作都由表示层负责。</p><p>（7）应用层</p><p>提供OSI用户服务，即确定进程之间通信的性质，以满足用户需要以及提供网络与用户应用软件之间的接口服务。</p><p>简言之，各层的作用：</p><p>物理层：在物理媒体上传输原始的数据比特流。</p><p>数据链路层：将数据分成一个个数据帧，以数据帧为单位传输。有应有答，遇错重发。</p><p>网络层：将数据分成一定长度的分组，将分组穿过通信子网，从信源选择路径后传到信宿。</p><p>传输层：提供不具体网络的高效、经济、透明的端到端数据传输服务。</p><p>会话层：进程间的对话也称为会话，会话层管理不同主机上各进程间的对话。</p><p>表示层： 为应用层进程提供格式化的表示和转换数据服务。</p><p>应用层：提供应用程序访问OSI环境的手段。</p><p>OSI网络体系结构各层协议：</p><p>（1）应用层：TELNET、FTP、TFTP、SMTP、SNMP、HTTP、BOOTP、DHCP、DNS<br>（2）表示层：<br> 　　文本：ASCII，EBCDIC<br> 　　图形：TIFF，JPEG，GIF，PICT<br> 　　声音：MIDI，MPEG，QUICKTIME<br>（3）会话层：NFS、SQL、RPC 、X-WINDOWS、ASP（APPTALK会话协议）、SCP<br>（4）传输层：TCP、UDP、SPX<br>（5）网络层：IP、IPX、ICMP、RIP、OSPF(Open Shortest Path First开放式最短路径优先)<br>（6）数据链路层：SDLC、HDLC、PPP、STP（Spanning Tree Protocol）、帧中继<br>（7）物理层：EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45</p><p>常用端口（每个协议都有一个缺省端口）</p><p><img src="/2018/03/15/google-tech00/p5.png" alt="logo"></p><h3 id="TCP-IP协议模型"><a href="#TCP-IP协议模型" class="headerlink" title="TCP/IP协议模型"></a>TCP/IP协议模型</h3><p>TCP/IP概念层次中与OSI模型相互对应</p><p><img src="/2018/03/15/google-tech00/p2.png" alt="logo"></p><p><img src="/2018/03/15/google-tech00/p4.jpg" alt="logo"></p><h3 id="两者关系"><a href="#两者关系" class="headerlink" title="两者关系"></a>两者关系</h3><p>OSI引入了服务、接口、协议、分层的概念，TCP/IP借鉴了OSI的这些概念建立TCP/IP模型。</p><p>OSI先有模型，后有协议，先有标准，后进行实践；而TCP/IP则相反，先有协议和应用再提出了模型，且是参照的OSI模型。</p><p>OSI是一种理论下的模型，而TCP/IP已被广泛使用，成为网络互联事实上的标准。</p><ul><li>TCP：transmission control protocol 传输控制协议</li><li>UDP：user data protocol 用户数据报协议</li></ul><p><img src="/2018/03/15/google-tech00/p3.png" alt="logo"></p><p>OSI七层协议模型算是一个理想的规范模型而不应用在实践中，而TCP/IP模型则是现在国际所通用的网络传输协议模型</p><p>序列化 / 反序列化 属于 TCP/IP模型 应用层 和 OSI`模型 展示层的主要功能：</p><ul><li>（序列化）把 应用层的对象 转换成 二进制串</li><li>（反序列化）把 二进制串 转换成 应用层的对象<br>所以， Protocol Buffer属于 TCP/IP模型的应用层 &amp; OSI模型的展示层</li></ul><h2 id="对于数据结构和对象"><a href="#对于数据结构和对象" class="headerlink" title="对于数据结构和对象"></a>对于数据结构和对象</h2><h3 id="数据结构、对象与二进制串"><a href="#数据结构、对象与二进制串" class="headerlink" title="数据结构、对象与二进制串"></a>数据结构、对象与二进制串</h3><p>不同的计算机语言中，数据结构，对象以及二进制串的表示方式并不相同。</p><p>对于面向对象的语言（如Java）：对象 = Object = 类的实例化；在Java中最接近数据结构 即 POJO（Plain Old Java Object），或Javabean（只有 setter/getter 方法的类）</p><p>对于半面向对象的语言（如C++），对象 = class，数据结构 = struct</p><p>对于C++，因为具有内存操作符，所以 二进制串 容易理解：C++的字符串可以直接被传输层使用，因为其本质上就是以 ‘\0’ 结尾的存储在内存中的二进制串</p><p>对于 Java，二进制串 = 字节数组 =byte[]<br>byte 属于 Java 的八种基本数据类型<br>二进制串 容易和 String混淆：String 一种特殊对象（Object）。对于跨语言间的通讯，序列化后的数据当然不能是某种语言的特殊数据类型。</p><h3 id="T-L-V-的数据存储方式"><a href="#T-L-V-的数据存储方式" class="headerlink" title="T - L - V 的数据存储方式"></a>T - L - V 的数据存储方式</h3><ul><li>定义 </li></ul><p>即 Tag - Length - Value，标识 - 长度 - 字段值 存储方式</p><p>作用<br>以 标识 - 长度 - 字段值 表示单个数据，最终将所有数据拼接成一个 字节流，从而 实现 数据存储 的功能</p><p>其中 Length可选存储，如 储存Varint编码数据就不需要存储Length</p><ul><li>示意图</li></ul><p><img src="/2018/03/15/google-tech00/p6.png" alt="logo"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Google-Protocol-Buffer&quot;&gt;&lt;a href=&quot;#Google-Protocol-Buffer&quot; class=&quot;headerlink&quot; title=&quot;Google Protocol Buffer&quot;&gt;&lt;/a&gt;Google Protocol Buffer&lt;/h1&gt;&lt;p&gt;什么是 Google Protocol Buffer？ 假如您在网上搜索，应该会得到类似这样的文字介绍：&lt;br&gt;Google Protocol Buffer( 简称 Protobuf) 是 Google 公司内部的混合语言数据标准，目前已经正在使用的有超过 48,162 种报文格式定义和超过 12,183 个 .proto 文件。他们用于 RPC 系统和持续数据存储系统。&lt;br&gt;Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API。&lt;br&gt;或许您和我一样，在第一次看完这些介绍后还是不明白 Protobuf 究竟是什么，那么我想一个简单的例子应该比较有助于理解它。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/03/15/google-tech00/p1.png&quot; alt=&quot;logo&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Google" scheme="http://yoursite.com/categories/Google/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="java类库" scheme="http://yoursite.com/tags/java%E7%B1%BB%E5%BA%93/"/>
    
      <category term="google" scheme="http://yoursite.com/tags/google/"/>
    
      <category term="protocol Buffer" scheme="http://yoursite.com/tags/protocol-Buffer/"/>
    
      <category term="数据交换" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2/"/>
    
  </entry>
  
</feed>
