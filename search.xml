<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JAVA开发常用类库--JSON解析库]]></title>
    <url>%2F2018%2F03%2F07%2FJAVA-api%2F</url>
    <content type="text"><![CDATA[#JSON是什么？ 尽管有许多宣传关于 XML 如何拥有跨平台，跨语言的优势，然而，除非应用于 Web Services，否则，在普通的 Web 应用中，开发者经常为 XML 的解析伤透了脑筋，无论是服务器端生成或处理 XML，还是客户端用 JavaScript 解析 XML，都常常导致复杂的代码，极低的开发效率。实际上，对于大多数 Web 应用来说，他们根本不需要复杂的 XML 来传输数据，XML 的扩展性很少具有优势，许多 AJAX 应用甚至直接返回 HTML 片段来构建动态 Web 页面。和返回 XML 并解析它相比，返回 HTML 片段大大降低了系统的复杂性，但同时缺少了一定的灵活性。 现在， JSON 为 Web 应用开发者提供了另一种数据交换格式。让我们来看看 JSON 到底是什么，同 XML 或 HTML 片段相比，JSON 提供了更好的简单性和灵活性。 #JSON的数据格式是怎么样的？和 XML 一样，JSON 也是基于纯文本的数据格式。由于 JSON 天生是为 JavaScript 准备的，因此，JSON 的数据格式非常简单，您可以用 JSON 传输一个简单的 String，Number，Boolean，也可以传输一个数组，或者一个复杂的 Object 对象。 String，Number 和 Boolean 用 JSON 表示非常简单。例如，用 JSON 表示一个简单的 String “ abc ”，其格式为： “abc”除了字符 “，\，/ 和一些控制符（\b，\f，\n，\r，\t）需要编码外，其他 Unicode 字符可以直接输出。 下图是一个 String 的完整表示结构： 一个 Number 可以根据整型或浮点数表示如下： 这与绝大多数编程语言的表示方法一致，例如： 12345（整数） -3.9e10（浮点数） Boolean 类型表示为 true 或 false 。此外，JavaScript 中的 null 被表示为 null，注意，true、false 和 null 都没有双引号，否则将被视为一个 String 。JSON 还可以表示一个数组对象，使用 [] 包含所有元素，每个元素用逗号分隔，元素可以是任意的 Value，例如，以下数组包含了一个 String，Number，Boolean 和一个 null： [&quot;abc&quot;,12345,false,null] Object 对象在 JSON 中是用 {} 包含一系列无序的 Key-Value 键值对表示的，实际上此处的 Object 相当于 Java 中的 Map&lt;String, Object&gt;，而不是 Java 的 Class 。注意 Key 只能用 String 表示。例如，一个 Address 对象包含如下 Key-Value： city:Beijing street:Chaoyang Road postcode:100025（整数） 用 JSON 表示如下： {“city”:”Beijing”,”street”:” Chaoyang Road “,”postcode”:100025} 其中 Value 也可以是另一个 Object 或者数组，因此，复杂的 Object 可以嵌套表示，例如，一个 Person 对象包含 name 和 address 对象，可以表示如下： {&quot;name&quot;:&quot;Michael&quot;,&quot;address&quot;: {&quot;city&quot;:&quot;Beijing&quot;,&quot;street&quot;:&quot; Chaoyang Road &quot;,&quot;postcode&quot;:100025} } #JavaScript 处理 JSON 数据上面介绍了如何用 JSON 表示数据，接下来，我们还要解决如何在服务器端生成 JSON 格式的数据以便发送到客户端，以及客户端如何使用 JavaScript 处理 JSON 格式的数据。我们先讨论如何在 Web 页面中用 JavaScript 处理 JSON 数据。我们通过一个简单的 JavaScript 方法就能看到客户端如何将 JSON 数据表示给用户： &apos;function handleJson() { var j={&quot;name&quot;:&quot;Michael&quot;,&quot;address&quot;: {&quot;city&quot;:&quot;Beijing&quot;,&quot;street&quot;:&quot; Chaoyang Road &quot;,&quot;postcode&quot;:100025} }; document.write(j.name); document.write(j.address.city); }&apos; 假定服务器返回的 JSON 数据是上文的： ‘{“name”:”Michael”,”address”: {“city”:”Beijing”,”street”:” Chaoyang Road “,”postcode”:100025} }’ 只需将其赋值给一个 JavaScript 变量，就可以立刻使用该变量并更新页面中的信息了，相比 XML 需要从 DOM 中读取各种节点而言，JSON 的使用非常容易。我们需要做的仅仅是发送一个 Ajax 请求，然后将服务器返回的 JSON 数据赋值给一个变量即可。有许多 Ajax 框架早已包含了处理 JSON 数据的能力，例如 Prototype（一个流行的 JavaScript 库：http://prototypejs.org）提供了 evalJSON() 方法，能直接将服务器返回的 JSON 文本变成一个 JavaScript 变量： new Ajax.Request(&quot;http://url&quot;, { method: &quot;get&quot;, onSuccess: function(transport) { var json = transport.responseText.evalJSON(); // TODO: document.write(json.xxx); } }); #服务器端输出 JSON 格式数据 讲完客户端的JSON处理，接下来到服务端的处理 下面我们讨论如何在服务器端输出 JSON 格式的数据。以 Java 为例，我们将演示将一个 Java 对象编码为 JSON 格式的文本。将 String 对象编码为 JSON 格式时，只需处理好特殊字符即可。另外，必须用 (“) 而非 (‘) 表示字符串： static String string2Json(String s) { StringBuilder sb = new StringBuilder(s.length()+20); sb.append(&apos;\&quot;&apos;); for (int i=0; i&lt;s.length(); i++) { char c = s.charAt(i); switch (c) { case &apos;\&quot;&apos;: sb.append(&quot;\\\&quot;&quot;); break; case &apos;\\&apos;: sb.append(&quot;\\\\&quot;); break; case &apos;/&apos;: sb.append(&quot;\\/&quot;); break; case &apos;\b&apos;: sb.append(&quot;\\b&quot;); break; case &apos;\f&apos;: sb.append(&quot;\\f&quot;); break; case &apos;\n&apos;: sb.append(&quot;\\n&quot;); break; case &apos;\r&apos;: sb.append(&quot;\\r&quot;); break; case &apos;\t&apos;: sb.append(&quot;\\t&quot;); break; default: sb.append(c); } } sb.append(&apos;\&quot;&apos;); return sb.toString(); } 将 Number 表示为 JSON 就容易得多，利用 Java 的多态，我们可以处理 Integer，Long，Float 等多种 Number 格式： static String number2Json(Number number) { return number.toString(); } Boolean 类型也可以直接通过 toString() 方法得到 JSON 的表示： static String boolean2Json(Boolean bool) { return bool.toString(); } 要将数组编码为 JSON 格式，可以通过循环将每一个元素编码出来： static String array2Json(Object[] array) { if (array.length==0) return &quot;[]&quot;; StringBuilder sb = new StringBuilder(array.length &lt;&lt; 4); sb.append(&apos;[&apos;); for (Object o : array) { sb.append(toJson(o)); sb.append(&apos;,&apos;); } // 将最后添加的 &apos;,&apos; 变为 &apos;]&apos;: sb.setCharAt(sb.length()-1, &apos;]&apos;); return sb.toString(); } 最后，我们需要将 Map&lt;String, Object&gt; 编码为 JSON 格式，因为 JavaScript 的 Object 实际上对应的是 Java 的 Map&lt;String, Object&gt; 。该方法如下： static String map2Json(Map&lt;String, Object&gt; map) { if (map.isEmpty()) return &quot;{}&quot;; StringBuilder sb = new StringBuilder(map.size() &lt;&lt; 4); sb.append(&apos;{&apos;); Set&lt;String&gt; keys = map.keySet(); for (String key : keys) { Object value = map.get(key); sb.append(&apos;\&quot;&apos;); sb.append(key); sb.append(&apos;\&quot;&apos;); sb.append(&apos;:&apos;); sb.append(toJson(value)); sb.append(&apos;,&apos;); } // 将最后的 &apos;,&apos; 变为 &apos;}&apos;: sb.setCharAt(sb.length()-1, &apos;}&apos;); return sb.toString(); } 为了统一处理任意的 Java 对象，我们编写一个入口方法 toJson(Object)，能够将任意的 Java 对象编码为 JSON 格式： public static String toJson(Object o) { if (o==null) return &quot;null&quot;; if (o instanceof String) return string2Json((String)o); if (o instanceof Boolean) return boolean2Json((Boolean)o); if (o instanceof Number) return number2Json((Number)o); if (o instanceof Map) return map2Json((Map&lt;String, Object&gt;)o); if (o instanceof Object[]) return array2Json((Object[])o); throw new RuntimeException(&quot;Unsupported type: &quot; + o.getClass().getName()); } 我们并未对 Java 对象作严格的检查。不被支持的对象（例如 List）将直接抛出 RuntimeException 。此外，为了保证输出的 JSON 是有效的，Map&lt;String, Object&gt; 对象的 Key 也不能包含特殊字符。细心的读者可能还会发现循环引用的对象会引发无限递归，例如，精心构造一个循环引用的 Map，就可以检测到 StackOverflowException： @Test(expected=StackOverflowError.class) public void testRecurrsiveMap2Json() { Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;key&quot;, map); JsonUtil.map2Json(map); } 好在服务器处理的 JSON 数据最终都应该转化为简单的 JavaScript 对象，因此，递归引用的可能性很小。最后，通过 Servlet 或 MVC 框架输出 JSON 时，需要设置正确的 MIME 类型（application/json）和字符编码。假定服务器使用 UTF-8 编码，则可以使用以下代码输出编码后的 JSON 文本： response.setContentType(&quot;application/json;charset=UTF-8&quot;); response.setCharacterEncoding(&quot;UTF-8&quot;); PrintWriter pw = response.getWriter(); pw.write(JsonUtil.toJson(obj)); pw.flush(); JSON 已经是 JavaScript 标准的一部分。目前，主流的浏览器对 JSON 支持都非常完善。应用 JSON，我们可以从 XML 的解析中摆脱出来，对那些应用 Ajax 的 Web 2.0 网站来说，JSON 确实是目前最灵活的轻量级方案。 #关于作者 关于python的学习，可以借鉴这个作家的网络教程来看廖雪峰，十年软件开发经验，业余产品经理，精通Java/Python/Ruby/Scheme/Objective C等，对开源框架有深入研究，著有《Spring 2.0核心技术与最佳实践》一书，多个业余开源项目托管在GitHub https://github.com/michaelliao]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>大数据</tag>
        <tag>java类库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO技巧分享--markdown语法归纳]]></title>
    <url>%2F2018%2F03%2F07%2Fhexo-tech3%2F</url>
    <content type="text"><![CDATA[什么是 Markdown 感谢大佬写得非常好的新手指南 引用自简书的https://www.jianshu.com/p/q81RER Markdown 是一种「电子邮件」风格的「标记语言」什么是 Markdown？简单地说，它就是一种语法，一门适合用于写作的简单语言。用过 Markdown 的人都知道，它的高效在于能有效避免不规范的行高、行距、首行缩紧等格式要求，以及繁乱复杂的字体，这样用户就能专注于写作本身，抛开杂项带来的烦恼。如果你从来没用过 Markdown，那我可以非常明确地告诉你——学习入门级的 Markdown 用法只需要 10 分钟，就足够了！在此，我们总结 Markdown 的优点如下： 纯文本，所以兼容性极强，可以用所有文本编辑器打开。 让你专注于文字而不是排版。 格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。 Markdown 的标记语法有极好的可读性。 要开始 Markdown 的写作，首先要找到一款适合自己的 Markdown 编辑器工具。下面三篇文章详细介绍了各个平台（Win，Mac，iOS，Android）上优秀的 Markdown 编辑器，可以根据自己的喜好和经济能力选择一个或几个： 在这篇“解决作者们的焦虑：7 款优秀 Markdown 编辑工具推荐”中总结一些使用率高的md编辑工具 传送门 https://sspai.com/post/27792 那么 Markdown 是通过什么方法去避免发生这些问题的呢？答案其实也并没有那么复杂，通俗地说就俩字：转码。 是的，不要单纯地以为只有多媒体文件才能用「转码」形容，在计算机的世界里，任何东西都不是我们肉眼凡胎，直接看到的那个样子。比如说文字，从像素到一个完整的字体库，期间经历的是数不尽的设计、再设计，再加上软件工程及硬件工程的完美协作，最终才能获得一个在计算机中最常见的元素：文字。 而在文字创作领域，Markdown 的作用就是把一篇纯文本文章转换为 富文本，让读者得到清晰明了的阅读体验。当然，由于各平台对于「格式」的兼容性不同，有时也会发生一些不那么「友善」的事情。比如用 OS X 上的 Chrome 浏览器阅读「两端对齐」格式的文章时，为了符合要求，在遇到中英文交替出现的段落，很有可能导致「大空格」现象的发生，继而在一定程度上影响了读者的阅读体验，但 OS X 的 Safari 和 Windows 的 IE 就可以轻松避免。所以针对这种问题，你既可以理解为这是 Markdown 转码富文本的不够完善，也能看作是浏览器的兼容性问题。总之，在这个越来越多人选择自己写文章的年代，Markdown 语法一定是该群体独一无二的选择。 有了想法，接下来要做的就是付诸实践，而这其中，最让人头疼的问题就是 Markdown 编辑器的选择，因为有的人喜欢在移动平台上创作文字，比如 iPhone、iPad 等，但更多的人会选择在（便携式）电脑上完成这项工作。说实话，我个人属于电脑撰稿用户，理由很简单： 第一，就目前而言，虚拟键盘在文字输入的体验上远不及实体键盘来得有效率。第二，支持的格式范围广，保存、导出、备份、发布的方法简单又便捷。第三，大多数人在使用电脑时，周围的场景会是家里、办公室、咖啡厅、图书馆，至少不会是非常吵闹的地方，这样有助于保持专注的思维；而习惯用手机码字的人，很多都是因为受到环境的限制，不得已出此下策，而非「情怀」作祟。或许现在的你有千万种理由可以反驳我，但本文的目的不在于此，只是要分享 7 款我使用过，及正在使用的 Markdown 编辑器，它们有不同的分类、定位、售价，也涵盖了 Mac、iOS、Windows 平台，它们都是让笔者留下深刻印象的选择。所以，为了尽可能避免「独立观点」的干扰，希望大家以技术探讨为优先，相互推荐更多、更有价值的选择。 Ulysses一款由国外开发商 The Soulmen 制作的 Markdown 编辑器。与其它同类应用相比，Ulysses 最大的不同在于，它能根据内置的文件管理器，以及与 iCloud 云服务器的实时同步方案，达到最快捷的文章整理效率。这么说可能不够细致，那我们不妨简单试想一下：当你正在写一篇文章，突然由于外在原因（比如出门），干扰了原本的写作计划，那么很有可能也就同时打断了思路，继而最终影响到文章的完成。对于作者而言，这丝毫不亚于「冬天洗澡没热水」的混蛋事，但你又能怎么办呢？ 所以，云同步的好处在此时就能体现出来了！记得 乔布斯 在刚回归苹果的一次开发者大会演讲上，着重强调了「云」在未来计算机发展领域的重要性。在综合现代环境的因素，我得出了以下结论： 如果有一天，我们电脑里的数据可以随时保存在云端服务器，并做到随用随取，那么就可以解决当下科技领域几大严重的先天缺陷，第一，设备丢失导致的数据损失；第二，使用内置硬盘带来无法避免的厚度和重量，导致便携式电脑的「便携性」降低；第三，不同的数据转换方式，导致文件结构的分裂，继而影响到操作系统的稳定性和数据相关行为的有效性。 话虽如此，但要具体的实现，还需要等到全球网络环境的大进步，软硬件水准提升到相当高的阶段才行。不过，在当下数不尽的解决方案面前，我认为 Apple 作了一个不算最好，但合理可行的选择：iCloud。iCloud 是个涉及领域颇广的话题，这里不适合分类讨论，读者请自行联想，但针对 Markdown 编辑器，我认为及时的云同步确实可以部分实现上文提到的目标，即数据找回、随用随取、多平台覆盖等。这就是我推荐 Ulysses 的理由。 Byword一款轻量级的 Markdown 编辑器，人称 Markdown 写作新手的必选，不过我个人不是非常同意这一观点。回想较早面世的几款 Markdown 工具，大多都会加入「实时预览」特性，（笔者推测）这是因为当时的 Markdown 语法还没有形成一个合理规范的体系，这些应用的开发者为了保证用户体验，不得已而加入了这一特性，可在此之后，大多数 Markdown 编辑器则又都反其道而行之（例如本文的介绍对象 Ulysses，Byword 和 Typed），这不禁要引起用户的怀疑：难道「实时预览」不是 Markdown 编辑器应有的功能？当然不是，因为这类应用的目的就是要帮助作者生产出高质量的文章，也就是说，只要你会写，并且能通过 Markdown 来完成自己的工作，这就足够了，与选择 Markdown 编辑器无关，与用户能力的强弱无关！所以我的观点非常简单：能达到目的的应用就是好应用。 开发商除了制作 Mac 平台的版本，同样也带来了 iOS 客户端。很多人建议已经在使用 Byword for Mac 的人应该首选 Byword for iOS 而不是其它（可能更好的）编辑器，是因为它能经由 OS X 10.10 Handoff 特性实现文档编辑环境的无缝切换，这种畅快淋漓的感觉是无法在不同的应用间体验到的。 Mou一款由国人独立开发者 罗晨 开发的实时预览型 Markdown 编辑器，也因此成为（目前）同类应用中，对汉字兼容性最好的代表作。不信？你一用便知。反过来讲，要论它有多人性化，我有点说不上来，毕竟每个人都有自己的偏好、习惯和审视角度，任何文章作者都不能以偏概全，但有一点是为大众认可的——Mou 是目前最好用的免费 Markdown 编辑器，没有之一！顺便也恭喜下不久前 Mou 1.0 版本开发资金的成功众筹，也衷心希望国内能有更多靠个人实力登上国际舞台的独立开发者。罗晨，好样的！ Typed一款由国外软件开发商 Realmac 制作的 Markdown 编辑器，于 2014 年 12 月份刚刚发布。对于这款应用，笔者的评价是：噱头大于亮点。这么说可能有些刻薄，但我却丝毫没有自己有一张「毒舌」的感觉，因为事实即是如此。在看了其特性列表后，大多数人都认为 Typed 的最大亮点就在于 Zen Mode（姑且解释为「禅模式」），号称能让用户更加专注于写作，而实际体验下来我发现，这一功能倒不如形容为「背景音乐播放」来得直接，因为它只是用来播放一些从自然界采集到的声音（例如鸟鸣、水流、风刮、雨打），但我却丝毫没有从中体会到写作应有的环境氛围。个人认为，码字就是要安安静静，才能更全面地发挥逻辑思维和想象空间，以进一步充实文章的内涵，保证内容的连贯有序，提高可读性。安静，是一个要求相当高的环境，不是所谓的「自然之声」就能做到，或者说弥补得了的。如果您同意笔者的愚见，那么从现在起，我建议读者不要（再）相信任何带有类似「禅模式」功能的写作工具，都是忽悠人的！否则，烦请三思而后行呀。 Sublime Text 3一款基于 Vim 开发的跨平台代码编辑器，支持 OS X、Windows、Ubuntu 等 UNIX 及 Linux 操作系统，并由于其功能的多样性而广受好评，在代码工作者圈内相当出名！关于 Vim，《MacTalk 人生元编程》一书的作者 @池建强 是这么评价的： 操作系统、编程语言和编辑器是程序员永恒的吐槽话题，技术发展了几十年，争论起来依然是「此恨绵绵无绝期」。在本文编辑器领域，Vim 和 Emacs 是永恒的焦点。Vim 号称编辑器之神，Emacs 则是神的编辑器；Vim 编程唯快不破，插件遍天下，Emacs 则宣称自己是伪装成文本编辑器的操作系统。 既然是「神的编辑器」，那么基于它开发的 Sublime Text 又会有怎样的表现呢？仅目前来看，它原生支持的编程语言就能多达十几种，其中包括大家熟知的 C、C++、C#、Objective-C、AppleScript、HTML、Java、Python 等。通过第三方插件，Sublime Text 还能实现更多语法的支持，这之中的代表就是 Markdown。其实，Sublime Text 在老版本中就已经支持 Markdown 了，但苦于没有像样的「预览」功能，其用户大多只是通过一种叫 Markdown Preview 的插件实现对 Markdown 的预览，而且还必须要有浏览器的支持。所以，笔者不推荐大家首选 Sublime Text 作为 Markdown 编辑器，但如果读者已经是一名代码工作者，并且正在使用它，那么考虑到这部分群体的使用习惯和口味，将就着用也是可以的。 Editorial一款 iOS 平台上支持 Workflow 的纯文本编辑器。论性质，倒确实与 Sublime Text 有那么几分相似，因为它也支持脚本代码的编译，比如说 Python。但这并不属于本文的介绍对象。更让我印象深刻的是它对 Markdown 语法的支持，主题体现在这三方面：界面、键盘和预览模式。 Editorial 的界面非常简洁，完全是按照 iOS 7 的扁平化风格设计的，可不少人在 App Store 中第一眼看到它的时候，都立刻失去了兴趣，理由竟然是：太单调了！好吧，这让我感到无言以对… 作为一款本文编辑器，尤其是 Markdown 编辑器，应该且必须以文字为核心，其它元素皆为陪衬或补偿，而不是代替前者的价值和意义，所以笔者觉得 Editorial 在用户界面的设计上还是很符合主流需求的。键盘方面，基本的语法符号很全，再配合文字输入辅助应用 TextExpander touch 可以让码字变得更有效率，此外，Editorial 还内置了 Snippets 功能。这是一个相当实用的功能，它可以直接代替 TextExpander touch，实现基于基本语法的输入，举两个简单的例子：[Clipboard] 能提取剪贴板内容，[yyy]-[MM]-[dd] 能提取实时日期等。这方面的例子有很多，这里不做扩展，感兴趣的读者可以自行研究一下。关于「预览」模式，一句话就可以概括：请往左划！ 简书不同于上文介绍的对象，简书 是一家由国内初创团队建立的在线文字创作及发布平台，而非客户端，所以相对来说，我更加建议 Windows 用户可以着重考虑一下。仔细想想，其实笔者个人接触它的时间不多，但很快就发现自己已经上瘾了，虽然这其中的因素有很多，可主要还是因为它有两个方面做得非常到位：后台、专题。回顾发展史，简书从一开始就已经支持 Markdown 和富文本编辑，对于像我这样的 Markdown 控而言是绝对的好事！另外，每位作者都可以通过连续撰稿和收集建立自己的专题、文集，甚至是一本看得见也摸得着的纸质作品。所以综合评定下来，它注定就是一个为作者打造的平台。 摸着良心说，推荐「简书」完全是因为它作为初创团队的成果，能做到如此精良的水准实属不易！就像我喜欢 Mou 一样，只要东西好，无论它来自国人之手，还是「进口」海外，每个人都有选择它的理由。因此我还是那句话，体验过后你就知道了。 关于MarkDown语法点击这里可以看到 https://www.jianshu.com/p/b03a8d7b1719https://www.jianshu.com/p/q81RER]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链技术解读--区块链结构解释]]></title>
    <url>%2F2018%2F03%2F06%2F%E5%8C%BA%E5%9D%97%E9%93%BE03%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>区块链技术</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>数字货币</tag>
        <tag>互联网金融</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链技术解读--数字签名]]></title>
    <url>%2F2018%2F03%2F06%2F%E5%8C%BA%E5%9D%97%E9%93%BE02%2F</url>
    <content type="text"><![CDATA[#数字签名# 数字签名即哈希算法+非对称加密相结合的技术 百度概念：数字签名（又称公钥数字签名、电子签章）是一种类似写在纸上的普通的物理签名，但是使用了公钥加密领域的技术实现，用于鉴别数字信息的方法。一套数字签名通常定义两种互补的运算，一个用于签名，另一个用于验证。数字签名，就是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。数字签名是非对称密钥加密技术与数字摘要技术的应用。 原理数字签名的文件的完整性是很容易验证的（不需要骑缝章，骑缝签名，也不需要笔迹专家），而且数字签名具有不可抵赖性（不需要笔迹专家来验证）。简单地说,所谓数字签名就是附加在数据单元上的一些数据,或是对数据单元所作的密码变换。这种数据或变换允许数据单元的接收者用以确认数据单元的来源和数据单元的完整性并保护数据,防止被人(例如接收者)进行伪造。它是对电子形式的消息进行签名的一种方法,一个签名消息能在一个通信网络中传输。基于公钥密码体制和私钥密码体制都可以获得数字签名,主要是基于公钥密码体制的数字签名。包括普通数字签名和特殊数字签名。普通数字签名算法有RSA、ElGamal、Fiat-Shamir、Guillou- Quisquarter、Schnorr、Ong-Schnorr-Shamir数字签名算法、Des/DSA,椭圆曲线数字签名算法和有限自动机数字签名算法等。特殊数字签名有盲签名、代理签名、群签名、不可否认签名、公平盲签名、门限签名、具有消息恢复功能的签名等,它与具体应用环境密切相关。显然,数字签名的应用涉及到法律问题,美国联邦政府基于有限域上的离散对数问题制定了自己的数字签名标准(DSS)。 主要功能保证信息传输的完整性、发送者的身份认证、防止交易中的抵赖发生。数字签名技术是将摘要信息用发送者的私钥加密，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。数字签名是个加密的过程，数字签名验证是个解密的过程。 数字签名即哈希算法+非对称加密相结合的技术提到非对称算法就会想到对称算法 对称算法对称密码算法有时又叫传统密码算法，就是加密密钥能够从解密密钥中推算出来，反过来也成立。在大多数对称算法中，加密解密密钥是相同的。这些算法也叫秘密密钥算法或单密钥算法，它要求发送者和接收者在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都能对消息进行加密解密。只要通信需要保密，密钥就必须保密。 即消息的发送方和接收方都拥有共同的密钥，可以将传递的明文进行解密 不对称算法不对称加密算法使用两把完全不同但又是完全匹配的一对钥匙—公钥和私钥。在使用不对称加密算法加密文件时，只有使用匹配的一对公钥和私钥，才能完成对明文的加密和解密过程。 加密明文时采用公钥加密，解密密文时使用私钥才能完成，而且发信方（加密者）知道收信方的公钥，只有收信方（解密者）才是唯一知道自己私钥的人。不对称加密算法的基本原理是，如果发信方想发送只有收信方才能解读的加密信息，发信方必须首先知道收信方的公钥，然后利用收信方的公钥来加密原文；收信方收到加密密文后，使用自己的私钥才能解密密文。显然，采用不对称加密算法，收发信双方在通信之前，收信方必须将自己早已随机生成的公钥送给发信方，而自己保留私钥。由于不对称算法拥有两个密钥，因而特别适用于分布式系统中的数据加密。广泛应用的不对称加密算法有RSA算法和美国国家标准局提出的DSA。 与对称加密算法的不同与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私 有 密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加 密，只有用对应的私有密钥才能解密；因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。 非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。甲方只能用其专用密钥解密由其公用密钥加密后的任何信息。 非对称加密算法的保密性比较好，它消除了最终用户交换密钥的需要，但加密和解密花费时间长、速度慢，它不适合于对文件加密而只适用于对少量数据进行加密。 经典的非对称加密算法如RSA算法等安全性都相当高。对称加密对称加密算法是应用较早的加密算法，技术成熟。在对称加密算法中，数据发信方将明文（原始数据）和加密密钥一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。收信方收到密文后，若想解读原文，则需要使用加密用过的密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密密钥。对称加密算法的特点是算法公开、计算量小、加密速度快、加密效率高。不足之处是，交易双方都使用同样钥匙，安全性得不到保证。此外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的惟一钥匙，这会使得发收信双方所拥有的钥匙数量成几何级数增长。对称加密算法在分布式网络系统上使用较为困难，主要是因为密钥管理困难，使用成本较高。在计算机专网系统中广泛使用的对称加密算法有DES、IDEA和AES。 DES传统的DES由于只有56位的密钥，因此已经不适应当今分布式开放网络对数据加密安全性的要求。1997年RSA数据安全公司发起了一项“DES挑战赛”的活动，志愿者四次分别用四个月、41天、56个小时和22个小时破解了其用56位密钥DES算法加密的密文。在计算机速度提升后的今天，DES加密算法被认为是不安全的。 AESAES是美国联邦政府采用的商业及政府数据加密标准，预计将在未来几十年里代替DES在各个领域中得到广泛应用。AES提供128位密钥，因此，128位AES的加密强度是56位DES加密强度的1021倍还多。假设可以制造一部可以在1秒内破解DES密码的机器，那么使用这台机器破解一个128位AES密码需要大约149亿万年的时间。（更深一步比较而言，宇宙一般被认为存在了还不到200亿年）因此可以预计，美国国家标准局倡导的AES即将作为新标准取代DES。]]></content>
      <categories>
        <category>区块链技术</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>数字货币</tag>
        <tag>互联网金融</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链技术解读--哈希算法]]></title>
    <url>%2F2018%2F03%2F06%2F%E5%8C%BA%E5%9D%97%E9%93%BE01%2F</url>
    <content type="text"><![CDATA[哈希算法 Hash算法是密码学基础，较常用的是MD5系和SHA系的散列算法结构最重要的两条特性为不可逆和无冲突但是这两条特性在数学上是不成立的不可逆即不可能反向推出哈希码所对应的明文内容，但是既然明文对应密文，非动态，那么就一直可以推出明文，在算法上利用穷举法或者彩虹表可以反解出明文内容因为一个函数必然可逆，且由于HASH函数的值域有限，理论上会有无穷多个不同的原始值，它们的hash值都相同，就是一个密文对应无限明文。无冲突不算是真的无冲突，密文对应明文，但是密文根据算法的不同，有限制规定的长度，而明文是无限的，所以是有可能发生哈希碰撞的 MD5和SHA做到的，是求逆和求冲突在计算上不可能，也就是正向计算很容易，而反向计算即使穷尽人类所有的计算资源都做不到。 哈希加密算法 MD5,SHA-1,SHA-2,SHA-256,SHA-512,SHA-3,RIPEMD-160等引用自 http://www.atool.org/hash.php MD5算法MD5即Message-Digest Algorithm 5（信息-摘要算法 5），用于确保信息传输完整一致。是计算机广泛使用的散列算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。 将数据（如汉字）运算为另一固定长度值，是散列算法的基础原理，MD5的前身有MD2、MD3和MD4。MD5一度被广泛应用于安全领域。但是由于MD5的弱点被不断发现以及计算机能力不断的提升，现在已经可以构造两个具有相同MD5的信息[2]，使本算法不再适合当前的安全环境。目前，MD5计算广泛应用于错误检查。例如在一些BitTorrent下载中，软件通过计算MD5和检验下载到的碎片的完整性。MD5是输入不定长度信息，输出固定长度128-bits的算法。经过程序流程，生成四个32位数据，最后联合起来成为一个128-bits散列。基本方式为，求余、取余、调整长度、与链接变量进行循环运算。得出结果。 SHA-1哈希加密算法SHA-1在许多安全协议中广为使用，包括TLS和SSL、PGP、SSH、S/MIME和IPsec，曾被视为是MD5（更早之前被广为使用的散列函数）的后继者。但SHA-1的安全性如今被密码学家严重质疑。 SHA-2哈希加密算法SHA-224、SHA-256、SHA-384，和SHA-512并称为SHA-2。新的散列函数并没有接受像SHA-1一样的公众密码社区做详细的检验，所以它们的密码安全性还不被大家广泛的信任。虽然至今尚未出现对SHA-2有效的攻击，它的算法跟SHA-1基本上仍然相似；因此有些人开始发展其他替代的散列算法。 SHA-3哈希加密算法SHA-3，之前名为Keccak算法，是一个加密杂凑算法。SHA-3并不是要取代SHA-2，因为SHA-2目前并没有出现明显的弱点。由于对MD5出现成功的破解，以及对SHA-0和SHA-1出现理论上破解的方法，NIST感觉需要一个与之前算法不同的，可替换的加密杂凑算法，也就是现在的SHA-3。 RIPEMD-160哈希加密算法RIPEMD-160 是一个 160 位加密哈希函数。它旨在用于替代 128 位哈希函数 MD4、MD5 和 RIPEMD。RIPEMD 是在 EU 项目 RIPE（RACE Integrity Primitives Evaluation，1988-1992）的框架中开发的。 引用自新浪微博 http://blog.sina.com.cn/s/blog_1799256a10102x3fh.html Hash算法将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。哈希值是一段数据唯一且极其紧凑的数值表示形式。如果散列一段明文而且哪怕只更改该段落的一个字母，随后的哈希都将产生不同的值。要找到散列为同一个值的两个不同的输入，在计算上是不可能的，所以数据的哈希值可以检验数据的完整性。一般用于快速查找和加密算法。 再引入一个hash表概念，计算机数据结构中，给定一个表M，关键字key，存在函数H(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为hash表。 简单理解hash算法就是这一种单向的加密，一个明文加密称为密文，不可逆推，只有加密过程，没有解密过程。说明了hash函数和hash表的概念，那么目前常用的hash算法有MD5（已被破解），SHA系列算法（比特币中使用sha-256算法）。SHA这里稍微提下（secure hash algorithm）这不是一个算法，这是一个hash函数集，现在有sha-224、sha-256、sha-384、sha-512等算法。在09年中本聪设计比特币的时候，当时sha-256被认为最安全的算法之一，故选择了sha-256，到目前为止还没有被破解。 解释到这里，可能会联想到，hash算法中key在计算后如果出现了同一位置，冲突的产生，这里简单说下几种冲突处理，如有兴趣可以查看hash算法论文。 1.拉链法：这种方法可以完全避免冲突，将所有关键字为同义词的结点链接在同一个单链表中。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数组t[0..m-1]。凡是散列地址为i的结点，均插入到以t为头指针的单链表中。t中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于1，但一般均取α≤1。 2.多哈希法：设计两种以上的hash函数，避免冲突，这个感觉比较不靠谱，但是从概率上来说多种hash函数还是降低了冲突的出现。 3.开放地址法：开放地址法有一个公式：Hi=(H(key)+di) MOD m i=1,2,…,k(k&lt;=m-1），其中，m为哈希表的表长。di 是产生冲突的时候的增量序列。如果di值可能为1,2,3,…m-1，称线性探测再散列。如果di取1，则每次冲突之后，向后移动1个位置.如果di取值可能为1,-1,4,-4,9,-9,16,-16,…kk,-kk(k&lt;=m/2），称二次探测再散列。如果di取值可能为伪随机数列。称伪随机探测再散列。 Hash算法函数根据分类：加法hash、位运算hash、乘法hash、除法hash、查表hash等。 区块链中的哈希解读因为区块链技术作为比特币的底层技术之一，目的是用于保证数字货币在交易环节中的安全性。 在徐明星的图说区块链中以一种图解更直观的形式这样说道 结合区块链，在区块链中很多地方都用到了hash函数： 1.区块链中节点的地址、公钥、私钥的计算。以地址为例：公钥经过一次SHA256计算，再进行一次RIPEMD160计算，得到一个公钥哈希（20字节\160比特），添加版本信息，再来两次SHA256运算、取前4比特字节，放到哈希公钥加版本信息后，再经过base58编码，最终得到地址。 2.merkle tree：是数据结构中的一种树结构，可以是二叉树，也可以是多叉树，他和数据结构中树的特点几乎一致，和普通树不同的是：merkle tree上的叶节点存放hash计算后的hash值，非叶节点是其对应的子节点串联的字符串的hash值。用于区块头和SPV认证中。 3.比特币中的挖矿，工作量证明（pow），计算的其实就是一个nonce，当这个随机数和其他散列过的数据合并时，产生一个比规定目标小（target）值。挖矿也可以理解一种快速不可逆的计算。SHA256(SHA256(version + prev_hash + merkle_root + ntime + nbits + x )) &lt; TARGET。 4.比特币中的bloom filter布隆过滤器，布隆过滤器基于hash函数的快速查找。解决了客户端检索的问题，原理是Bloom filter可以快速判断出某检索值一定不存在于某个指定的集合，从而可以过滤掉大量无关数据，减少客户端不必要的下载量。 简单介绍了HASH算法，和区块链中用到的HASH算法，区块链是多个技术的结合，结合各自特点出现的一种新的技术架构，HASH算法和加密技术为区块链的自证信任化及安全控制提供了基础，算法的碰撞和现在量子计算的发展，之前在区块链的安全性的文章中笔者有过说明，技术不断发展，肯定会有更适合的技术保障应用的实现。 SHA (Secure Hash Algorithm，译作安全散列算法) 是美国国家安全局 (NSA) 设计，美国国家标准与技术研究院 (NIST) 发布的一系列密码散列函数，经历了SHA-0，SHA-1，SHA-2，SHA-3系列发展。NSA于2007年正式宣布在全球范围内征集新新一代（SHA-3）算法设计，2012年公布评选结果， Keccak算法最终获胜成为唯一官方标准SHA-3算法，但还有四种算法同时进入了第三轮评选，分别是：BLAKE, GrøSTL, JH和SKEIN，这些算法其实也非常安全，而且经受审查，被各种竞争币频繁使用。 比特币采用SHA256算法，该算法属于SHA-2系列，在中本聪发明比特币时（2008）被公认为最安全最先进的算法之一。除了生成地址中有一个环节使用了REPID-160算法，比特币系统中但凡有需要做Hash运算的地方都是用SHA256。随着比特币被更多人了解，大家开始好奇中本聪为何选择了SHA256，同时对SHA256的安全性发表各种意见，SHA256妥妥经受了质疑，到目前为止，没有公开的证据表明SHA256有漏洞，SHA256依然牢牢抗住保卫比特币安全的大旗。当然大家心里都明白，没有永远安全的算法，SHA256被替代是早晚的事，中本聪自己也说明了算法升级的必要和过程。]]></content>
      <categories>
        <category>区块链技术</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>数字货币</tag>
        <tag>互联网金融</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO技巧分享--不借助第三方图库上传图片]]></title>
    <url>%2F2018%2F03%2F06%2Fhexo-photo%2F</url>
    <content type="text"><![CDATA[图片测试，来自Hexo大佬的指导，不通过第三方图床上传图片 1.首先确认_config.yml 中有 post_asset_folder:true。Hexo 提供了一种更方便管理 Asset 的设定：post_asset_folder当您设置post_asset_folder为true参数后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。 2.在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image –save（需要等待一段时间）。 3.完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹。图片就可以放在文件夹下面。结构如下： 本地图片测试├── apppicker.jpg├── logo.jpg└── rules.jpg本地图片测试.md这样的目录结构（目录名和文章名一致），只要使用 ![logo](本地图片测试/logo.jpg)格式 就可以插入图片。其中[]里面不写文字则没有图片标题。生成的结构为 public/2016/3/9/本地图片测试├── apppicker.jpg├── index.html├── logo.jpg└── rules.jpg同时，生成的 html 是 &lt;img src=&quot;/2016/3/9/本地图片测试/logo.jpg&quot; alt=&quot;logo&quot;&gt; 而不是愚蠢的 &lt;img src=&quot;本地图片测试/logo.jpg&quot; alt=&quot;logo&quot;&gt; 注意:通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo3的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。 比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 ，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作） 正确的引用图片方式是使用下列的标签插件而不是markdown 作者：TSimeon链接：https://www.jianshu.com/p/c2ba9533088a來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
      <tags>
        <tag>HEXO技巧</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO技巧分享--busuanzi技术]]></title>
    <url>%2F2018%2F03%2F05%2Ftest2%2F</url>
    <content type="text"><![CDATA[在新版的Next主题中，就内置了不蒜子作为统计工具我们只需要在主题config中配置即可 操作： 打开文件：themes/next/_config.yml busuanzi_count: count values only if the other configs are false enable: true custom uv span for the whole site site_uv: true site_uv_header: 访问人数 site_uv_footer: 人 custom pv span for the whole site site_pv: true site_pv_header: 总访问量 site_pv_footer: 次 custom pv span for one page only page_pv: true page_pv_header: 阅读数 page_pv_footer: 相关操作： enable: true 添加相关中文说明，不添加也行。 但若是我们想自己集成不蒜子具体实现方法 打开\themes\next\layout_partials\footer.swig文件,在copyright前加上这段代码 &lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt; &lt;/script&gt; 然后再合适的位置添加显示统计的代码 themes\iissnan\layout_third-party\analytics\busuanzi-counter.swig中 在这里有两中不同计算方式的统计代码： pv的方式，单个用户连续点击n篇文章，记录n次访问量&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次 &lt;/span&gt; uv的方式，单个用户连续点击n篇文章，只记录1次访客数&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;次 &lt;/span&gt; 添加之后再执行hexo d -g，然后再刷新页面就能看到效果]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
      <tags>
        <tag>HEXO技巧</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO技巧分享--如何建立分类及标签]]></title>
    <url>%2F2018%2F03%2F05%2Fhexo-tech2%2F</url>
    <content type="text"><![CDATA[在hexo框架中，建立分类和标签的方法如下 添加标签hexo new page tags这个是自动创建tags文件夹的命令,里面会自动生成index.md文件，当然也可以手动创建tags文件夹和md文件，不过这样就会没有时间显示 确认站点配置文件里有tag_dir: tags确认主题配置文件里有tags: /tags编辑站点的source/tags/index.md，添加 title: tags #标签的标题，可以说是几个共同特性标签的集合 type: &quot;tags&quot; #这里是对应站点配置文件中的tags comments: false 调好后，我们就可以在文章中自由添加标签了比如 `—title: HEXO技巧分享–如何建立分类及标签date: 2018-03-05 16:03:27tags: - HEXO技巧 - hexo —`HEXO技巧和hexo这两个标签会在tags页面自动生成并导航 添加分类hexo new page categories确认站点配置文件里有category_dir: categories确认主题配置文件里有categories: /categories编辑站点的source/categories/index.md，添加 title: categories type: &quot;categories&quot; comments: false 调好后，我们就可以在文章中自由添加分类了比如 `—title: HEXO技巧分享–如何建立分类及标签date: 2018-03-05 16:03:27categories: “Hexo教程” —` 添加关于hexo new page “about”在about文件夹下的index.md文件中写上文字后更新就可以在页面中看到了]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
      <tags>
        <tag>HEXO技巧</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO技巧分享--德文错误显示修改]]></title>
    <url>%2F2018%2F03%2F05%2Fhexo-tech%2F</url>
    <content type="text"><![CDATA[在所应用的主题的languages文件夹中将 zh—Hans.yml 改成 zh—CN.yml然后在HEXO主目录下的_config.yml配置文件中修改 language： zh—CN 即可 更新操作 hexo clean hexo g hexo s（预览检查） hexo deploy #部署]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
      <tags>
        <tag>HEXO技巧</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo驱动+Github搭载Blog系统]]></title>
    <url>%2F2018%2F03%2F04%2Fhexo_init1%2F</url>
    <content type="text"><![CDATA[分享HEXO+GITHUB搭载驱动的博文系统使用github pages服务搭建博客的好处有： 全是静态文件，访问速度快；免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；博客内容可以轻松打包、转移、发布到其它平台； 什么是Hexo?Hexo官网中说是这么描述的：A fast, simple &amp; powerful blog framework,即:一个快速、简单且强大的博客快速生产工具。它的简单体现在你完全有可能在30分钟内就生成属于你的个人博客。而它的强大体现在你对细节的调整上完全有可能花上一天的时间。Hexo(中文官方网站)是一个快速, 简洁且高效的博客框架. 让上百个页面在几秒内瞬间完成渲染. Hexo支持Github Flavored Markdown的所有功能, 甚至可以整合Octopress的大多数插件. 并自己也拥有强大的插件系统. Blazing FastNode.js brings you incredible generating speed. Hundreds of files take only seconds to build. Markdown SupportAll features of GitHub Flavored Markdown are supported. You can even use most Octopress plugins in Hexo. One-Command DeploymentYou only need one command to deploy your site to GitHub Pages, Heroku or other sites. Various PluginsHexo has a powerful plugin system. You can install more plugins for Jade, CoffeeScript plugins. 1.安装node.jsNode.js 的实质是一个JavaScript运行环境,这里我们主要使用它来生成我们博客的静态页面.Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world.Window 上安装Node.js你可以采用以下两种方式来安装。 Windows 安装包(.msi)形式32 位安装包下载地址 : https://nodejs.org/dist/v4.4.3/node-v4.4.3-x86.msi64 位安装包下载地址 : https://nodejs.org/dist/v4.4.3/node-v4.4.3-x64.msi步骤 1 : 双击下载后的安装包步骤 2 : 点击以上的Run(运行)步骤 3 : 勾选接受协议选项，点击 next（下一步） 按钮步骤 4 : Node.js默认安装目录为 “C:\Program Files\nodejs\” , 你可以修改目录，并点击 next（下一步）步骤 5 : 点击树形图标来选择你需要的安装模式 , 然后点击下一步 next（下一步）步骤 6 :点击 Install（安装） 开始安装Node.js。你也可以点击 Back（返回）来修改先前的配置。 然后并点击 next（下一步）点击 Finish（完成）按钮退出安装向导即可 检测PATH环境变量是否配置了Node.js，点击开始=》运行=》输入”cmd” =&gt; 输入命令”path”，输出如下结果： PATH=C:\oraclexe\app\oracle\product\10.2.0\server\bin;C:\Windows\system32; C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\; c:\python32\python;C:\MinGW\bin;C:\Program Files\GTK2-Runtime\lib; C:\Program Files\MySQL\MySQL Server 5.5\bin;C:\Program Files\nodejs\; C:\Users\rg\AppData\Roaming\npm 我们可以看到环境变量中已经包含了C:\Program Files\nodejs\检查Node.js版本 Windows 二进制文件 (.exe)安装形式32 位安装包下载地址 : http://nodejs.org/dist/v0.10.26/node.exe64 位安装包下载地址 : http://nodejs.org/dist/v0.10.26/x64/node.exe 步骤 1 : 双击下载的安装包 Node.exe点击 Run（运行）按钮将出现命令行窗口进入 node.exe 所在的目录，若是获得版本显示则证明安装成功 当然也可以在安装完成之后安装完成后可以使用cmd（win+r然后输入cmd进入）测试下是否安装成功。方法：在cmd下输入node -v若是出现版本号则证明安装成功 npm的安装。由于新版的NodeJS已经集成了npm，所以之前npm也一并安装好了。同样可以使用cmd命令行输入”npm -v”来测试是否成功安装 Build amazing thingsnpm is the package manager for JavaScript and the world’s largest software registry. Discover packages of reusable code — and assemble them in powerful new ways. npm Orgs is powerful collaboration — for freeEncourage code discovery and re-use within teamsPublish and control access to your own namespaceManage public and private code with the same workflow What is npm?Use npm to install, share, and distribute code; manage dependencies in your projects; and share &amp; receive feedback with others. NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：允许用户从NPM服务器下载别人编写的第三方包到本地使用。允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 安装好Node.js和npm后可以进入下一步 2.安装git环境git是最流行的分布式版本控制系统，我们使用它主要是与github进行交互。安装git使用默认选项安装即可关于Git的学习http://https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/这里即可点击：https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/ Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency. Git is easy to learn and has a tiny footprint with lightning fast performance. It outclasses SCM tools like Subversion, CVS, Perforce, and ClearCase with features like cheap local branching, convenient staging areas, and multiple workflows.Git(读音为/gɪt/。)是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。[1] Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Torvalds 开始着手开发 Git 是为了作为一种过渡方案来替代 BitKeeper，后者之前一直是 Linux 内核开发人员在全球使用的主要源代码工具。开放源码社区中的有些人觉得BitKeeper 的许可证并不适合开放源码社区的工作，因此 Torvalds 决定着手研究许可证更为灵活的版本控制系统。尽管最初 Git 的开发是为了辅助 Linux 内核开发的过程，但是我们已经发现在很多其他自由软件项目中也使用了 Git。例如 很多 Freedesktop 的项目迁移到了 Git 上。 这里引用www.liaoxuefeng.com廖雪峰的官网上的说法，很清楚明朗的了解Git的原理 Git是目前世界上最先进的分布式版本控制系统那什么是版本控制系统？ 如果你用Microsoft Word写过长篇大论，那你一定有这样的经历： 想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档变成了这样七零八乱的一改二改的版本过了一周，你想找回被删除的文字，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找，真麻烦。 看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，真郁闷。 更要命的是，有些部分需要你的财务同事帮助填写，于是你把文件Copy到U盘里给她（也可能通过Email发送一份给她），然后，你继续修改Word文件。一天后，同事再把Word文件传给你，此时，你必须想想，发给她之后到你收到她的文件期间，你作了哪些改动，得把你的改动和她的部分合并，真困难。 于是你想，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？ 这个软件用起来就应该像这个样子，能记录每次文件的改动这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的20世纪。 最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。 在Windows上安装Git在Windows上使用Git，可以从Git官网直接下载安装程序，（网速慢的同学请移步国内镜像），然后按默认选项安装即可。 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 安装完成后，还需要最后一步设置，在命令行输入： $ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址 创建版本库什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 创建一个空目录 通过git init命令把这个目录变成Git可以管理的仓库 把文件添加到版本库 首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。 不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。 因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载Notepad++代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可 搭载好Git后以后就可以通过Git Base Here命令行来操控Hexo了用windows的cmd也可以操作，但是有时候一些命令无法实现，所以尽量全部使用Git Base Here来操作 3.注册githubgithub就不用说了吧，它是一个面向开源及私有软件项目的托管平台。几乎所有的程序员都听说过它的大名。就正常注册一个账号就好了。注册号以后首先给我们的账号添加本机的SSH，具体方法及原因在这篇文章已经有了详细说明，并且方法也很简单]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 秘密的h收集资源密站 女儿，要对爸爸保密喔[32P]https://www.3344mf.com/tupianqu/katong/10029.html 来次悸动的H好吗？（上）https://www.3344mf.com/tupianqu/katong/10097.html 来次悸动的H好吗？（下）https://www.3344mf.com/tupianqu/katong/10077.html 主婦喝醉后遭遇的瘋狂倫奸[14P]https://www.3344mf.com/tupianqu/katong/11305.html https://www.3344mf.com/tupianqu/katong/12741.html]]></content>
  </entry>
</search>
